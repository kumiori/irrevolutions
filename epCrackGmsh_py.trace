 * Tensile plate, clamped at the bottom 
 * with controlled displacement at the top 
 *CPDP= 'DP'; 
 CPDP= 'CP'; 
 *Plane strains 
 SI (EGA CPDP  'DP'); 
 OPTION DIME 2 ELEM qua4 MODE PLAN DEFO  ; 
 FINSI; 
 *Plane stresses * 
 SI (EGA CPDP  'CP'); 
 OPTION DIME 2 ELEM qua4 MODE PLAN CONT  ; 
 FINSI; 
 *opti dime 2 mode plan cont; 
 opti elem tri3; 
 *opti elem tri6; 
 *opti epsilon lineaire; 
 ************************************************************************ 
 *----------- INPUT DATAS------------- 
 * Material constants 
 YOU0=1.; 
 v0=0.4; 
 * Applied Displacement 
 u0= 1.; 
   
   
 TAB1 = LIRE 'UNV' './meshes/twoCrack_ep2.unv'; 
 list TAB1; 
 s0 = TAB1.'MAILLAGE'; 
   
   
 liptopL = TAB1.'Lliptop'; 
 lipbotL = TAB1.'Llipbot'; 
   
   
 top0 = TAB1.'top'; 
 bot0 = TAB1.'bottom'; 
   
 pF0 = Noeud 9; 
 *pF0 = TAB1.'nodeLeftMiddle'; 
 *Problematic 
 *trac (s0 coul blanc); 
   
   
 s0 = rege s0; 
 s0 = (s0 ELEM TRI3); 
   
 *trac s0; 
   
 *********************************************************************** 
 *----------- CONSTITUTIVE LAW------------- 
 * 
 *Plane strains 
 SI (EGA CPDP  'DP'); 
 OPTION DIME 2 MODE PLAN DEFO  ; 
 FINSI; 
 *Plane stresses * 
 SI (EGA CPDP  'CP'); 
 OPTION DIME 2 MODE PLAN CONT  ; 
 FINSI; 
   
 opti elem qua8; 
   
 MOD0 = MODE S0 MECANIQUE ELASTIQUE ISOTROPE ; 
 MAT0 = MATE MOD0 YOUNG YOU0 NU v0; 
 *----------- BOUNDARY CONDITIONS----------- 
 * Clamped at the bottom 
 CL01 = BLOQ UX bot0 ; 
 CL02 = BLOQ UY bot0 ; 
 CL0=CL01 et CL02; 
 *displacement in the y-direction at the top 
 CL2 = BLOQ UY top0 ; 
 CL3 = BLOQ UX top0; 
 CHA0 = DEPI CL2 (u0); 
 CL0 =  CL0 et CL2 et CL3; 
   
 * STIFFNESS MATRIX 
 rig0 = rigi mod0 mat0 ; 
   
 * DETERMINATION OF THE DISPLACEMENT FIELD 
 u0 = reso (rig0 et cl0) cha0 ; 
 *********************************************************************** 
 *----------- POST-PROCESSING ---------------- 
 ************* PLOT 
 * Plot of the deformation 
 *titre 'deformee' ; 
 *def0 = defo s0 u0 0. bleu ; 
 *def1 = defo s0 u0  roug ; 
 *trac (def0 et def1); 
 ** plot of the stress state 
 *sig1 = sigma mod0 mat0 u0 ; 
 *trac sig1 mod0; 
   
 ************* DETERMINATION OF THE SIF 
 *----By interpolation of the displacement field  ---------------------; 
 *SIFTAB = TABL; 
 *SIFTAB.'MODMIXTE' = VRAI; 
 *SIFTAB.'LEVRE_1' = liptopL; 
 *SIFTAB.'LEVRE_2' = lipbotL; 
 *SIFTAB.'FRTFISS' = pF0; 
 *SIF SIFTAB MAT0 U0; 
   
 *K1INT = SIFTAB.K1; 
 *K2INT = SIFTAB.K2; 
   
   
 *----By G-theta methods ---------------------; 
 GTAB = TABL; 
 GTAB . 'OBJECTIF' = MOT 'DECOUPLAGE'; 
 GTAB . 'FRONT_FISSURE'  = pF0 ; 
 GTAB . 'LEVRE_SUPERIEURE' = liptopL; 
 GTAB . 'LEVRE_INFERIEURE' = lipbotL; 
 GTAB . 'COUCHE' = 6; 
 GTAB . 'SOLUTION_RESO'  = u0; 
 GTAB . 'CARACTERISTIQUES' = mat0; 
 GTAB . 'MODELE' = mod0; 
 GTAB . 'CHARGEMENTS_MECANIQUES' = cha0 ; 
 G_THETA GTAB; 
 * G_THETA   PROCEDUR  JB251061  20/11/04    21:17:46     10763 
 DEBPROC G_THETA SUPTAB*'TABLE' ; 
 *|=====================================================================| 
 *|                                                                     | 
 *|    OBJECTIF :                                                       | 
 *|    ==========                                                       | 
 *|                                                                     | 
 *| 1) calculer l'integrale caracteristique de mecanique de la rupture  | 
 *|    a) J en elasto-plasticite ou en elasto-dynamique pour un         | 
 *|       materiau isotrope.                                            | 
 *|    b) dJ/da en elasto-plasticite, utilisable uniquement dans le cas | 
 *|       de materiau isotrope et homogene pour les elements massifs.   | 
 *|    c) C* dans le cas de fluage secondaire stationnaire pour un      | 
 *|       materiau isotrope.                                            | 
 *|    d) C*H dans le cas de fluage primaire sous un chargement radial  | 
 *|       pour un materiau isotrope.                                    | 
 *|                                                                     | 
 *| 2) separer les modes K1, K2 et K3 en elasticite, utilisable         | 
 *|    uniquement dans le cas de materiau homogene et isotrope          | 
 *|    pour les elements massifs.                                       | 
 *|                                                                     | 
 *|                                                                     | 
 *|    ENTREE :                                                         | 
 *|    ========                                                         | 
 *|                                                                     | 
 *| SUPTAB  objet de type TABLE. En entree, SUPTAB sert a definir les   | 
 *|         options et les parametres du calcul. Ses indices sont des   | 
 *|         objets de type MOTS (a ecrire en toutes lettres) dont voici | 
 *|         la liste :                                                  | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Arguments obligatoires dans tous les cas                         | 
 *|    ----------------------------------------                         | 
 *|                                                                     | 
 *| SUPTAB.'OBJECTIF' = MOT pour preciser le but du calcul, vaut        | 
 *|                     1) 'J' pour calculer l'integrale J (ou G),      | 
 *|                         caracteristique en elasto-plastique.        | 
 *|                     2) 'J_DYNA' pour calculer l'integrale J (ou G), | 
 *|                         caracteristique en elasto-dynamique.        | 
 *|                     3) 'C*' pour calculer l'integrale C*,           | 
 *|                         caracteristique en fluage secondaire        | 
 *|                         stationnaire.                               | 
 *|                     4) 'C*H' pour calculer l'integrale C*(h),       | 
 *|                         caracteristique en fluage primaire ou       | 
 *|                         tertiaire.                                  | 
 *|                     5) 'DJ/DA' pour calculer l'integrale de la      | 
 *|                         derivation dJ/da, caracteristique pour      | 
 *|                         analyser la stabilite de propagation d'une  | 
 *|                         fissure ou des fissures interagissantes.    | 
 *|                     6) 'DECOUPLAGE' pour decouper les modes mixtes, | 
 *|                         c'est a dire la separation des facteurs K1, | 
 *|                         K2 (et K3 et 3D).                           | 
 *|                                                                     | 
 *| SUPTAB.'COUCHE' = ENTIER representant le nombre de couches          | 
 *|                   d'elements autour du front de la fissure          | 
 *|                   qui se deplacent pour simuler la propagtion       | 
 *|                   de la fissure. Il vaut 0 si seul la pointe de     | 
 *|                   la fissure se deplace, 1 si c'est la premiere     | 
 *|                   couche d'elements entourant la fissure, 2 si      | 
 *|                   c'est l'ensemble des premiere et deuxieme couches | 
 *|                   d'elements etc. Il convient veiller a ce que      | 
 *|                   l'ensemble des elements a deplacer n'atteint pas  | 
 *|                   le bord de la structure fissuree.                 | 
 *|                   Si COUCHE et CHAMP_THETA sont tous deux donnés,   | 
 *|                   CHAMP_THETA est écrasé (cf.8.)                    | 
 *|                                                                     | 
 *| SUPTAB.'FRONT_FISSURE' = POINT en 2D ou MAILLAGE en 3D massif       | 
 *|                          representant le front de la fissure.       | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Arguments obligatoires avec des elements standards               | 
 *|    --------------------------------------------------               | 
 *|                                                                     | 
 *| SUPTAB.'LEVRE_SUPERIEURE' = Selon la convention de definition, cet  | 
 *|                             objet (type MAILLAGE) representant la   | 
 *|                             levre superieure de la fissure.         | 
 *|                                                                     | 
 *| SUPTAB.'LEVRE_INFERIEURE' = Selon la convention de definition, cet  | 
 *|                             objet (type MAILLAGE) representant la   | 
 *|                             la levre inferieure de la fissure. Si   | 
 *|                             une seule levre est modelisee, un des   | 
 *|                             des deux mots ici (LEVRE_SUPERIEURE ou  | 
 *|                             LEVRE_INFERIEURE) sera suffisant pour   | 
 *|                             decrire la fissure.                     | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Arguments obligatoires avec des elements enrichis (XFEM)         | 
 *|    --------------------------------------------------------         | 
 *|                                                                     | 
 *| SUPTAB.'PSI' =   1ere level set (CHPOINT) decrivant la fissure dans | 
 *|                  le cas ou l'on utilise des elements XFEM .         | 
 *| SUPTAB.'PHI' =   2eme level set.                                    | 
 *|                                                                     | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Solution obligatoire issus de la procedure PASAPAS               | 
 *|    --------------------------------------------------               | 
 *|                                                                     | 
 *| SUPTAB.'SOLUTION_PASAPAS' = TABLE sortant de la procedure PASAPAS.  | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Solution obligatoire issus de l'operateur RESO                   | 
 *|    ----------------------------------------------                   | 
 *|                                                                     | 
 *| SUPTAB.'SOLUTION_RESO' = CHPOINT de deplacement issus de RESO.      | 
 *| SUPTAB.'CARACTERISTIQUES' = Champ de caractristiques matrielles     | 
 *|                             et eventuellement geometriques          | 
 *|                             si necessaire.                          | 
 *| SUPTAB.'MODELE' = Objet modele (type MMODEL) englobant toute la     | 
 *|                   structure.                                        | 
 *| SUPTAB.'TEMPERATURES' = CHPOINT de temperature creant une contrainte| 
 *|                         thermique non nulle si elle existe.         | 
 *| SUPTAB.'CHARGEMENTS_MECANIQUES' = CHPOINT representant l'ensemble   | 
 *|                                   des forces exterieures            | 
 *|                                   (surfaciques, volumiques ou       | 
 *|                                   ponctuelles ....) appliquees sur  | 
 *|                                   le systeme si elles existent, SAUF| 
 *|                                   la pression sur les levres de la  | 
 *|                                   fissure                           | 
 *| SUPTAB.'BLOCAGES_MECANIQUES' = RIGIDITE representant le blocages    | 
 *|                                mecanique du probleme, a fournir     | 
 *|                                uniquement dans le cas de calcul     | 
 *|                                de la derivation dJ/da.              | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Arguments optionnels                                             | 
 *|    --------------------                                             | 
 *|                                                                     | 
 *|                                                                     | 
 *|    1 : Materiaux composites (2D massif ou 3D coque seulement)       | 
 *|                                                                     | 
 *| SUPTAB.'MODELES_COMPOSITES' = TABLE indicee par des entiers (1 2... | 
 *|                               M, M = nombre de Materiaux composites)| 
 *|                               pour donner les modeles des materiaux | 
 *|                               ayant des discontinutes de proprietes | 
 *|                               materielles.                          | 
 *|                                                                     | 
 *|    2 : Pour un front de fissure tridimensionnel massif              | 
 *|                                                                     | 
 *| SUPTAB.'NOEUDS_AVANCES' = MAILLAGE de type POI1 pour donner les     | 
 *|                           points du front pour lesquels le calcul   | 
 *|                           sera effectue. Si cet argument est        | 
 *|                           obsent, le calcul sera fait pour tous     | 
 *|                           les noeuds sur le front de la fissure.    | 
 *|                                                                     | 
 *|    3 : Calcul des termes croises de la matrice dJi/daj              | 
 *|        (i non egal a j) dans le cas des fisures interagissantes.    | 
 *|                                                                     | 
 *| SUPTAB.'FISSURE_2' = Objet de type MAILLAGE representant une autre  | 
 *|                      fissure (levres superieure + inferieure si     | 
 *|                      toutes les deux levres sont presentes).        | 
 *| SUPTAB.'FRONT_FISSURE_2' = POINT ou MAILLAGE reprsentant le front   | 
 *|                            de la fissure 2 decrite ci-dessus.       | 
 *|                                                                     | 
 *|                                                                     | 
 *|    4 : Cas d'une fissure circulaire dans une geometrie plane        | 
 *|                                                                     | 
 *| SUPTAB.'POINT_CENTRE'  = centre de la fissure circulaire            | 
 *|                                                                     | 
 *|    5 : Cas ou l'extension de la fissure correspond a une simple     | 
 *|        translation dans un tuyauterie droite (3D). Dans ce cas      | 
 *|        on effectue dans la procedure CH_THETA une transformation    | 
 *|        de tuyau en plaque en passant au systeme de coordonnees      | 
 *|        cylindriques. Il est alors necessaire de fournir :           | 
 *|                                                                     | 
 *| SUPTAB.'POINT_1' = centre du systeme de coordonnees                 | 
 *| SUPTAB.'POINT_2' = POINT tel que l'axe defini par POINT_1           | 
 *|                    vers POINT_2 soit l'axe Z poisitif               | 
 *| SUPTAB.'POINT_3' = POINT tel que le plan defini par les 3 points    | 
 *|                    POINT_1 POINT_2 POINT_3 donne l'angle theta nul  | 
 *|                                                                     | 
 *|    6 : Cas ou l'extension de la fissure ne correspond               | 
 *|        pas a une simple translation (3D)                            | 
 *|                                                                     | 
 *|      6.1 Fissure dans un tuyauterie droite (3D, Rotation)           | 
 *|                                                                     | 
 *| SUPTAB.'POINT_1' = Objet de type POINT                              | 
 *| SUPTAB.'POINT_2' = Objet de type POINT qui, avec le point POINT_1,  | 
 *|                    constitue l'axe perpendiculaire a la section     | 
 *|                    fissuree.                                        | 
 *|                                                                     | 
 *|      6.2 Fissure dans un coude (3D, rotation + transformation)      | 
 *|          Outre les deux points SUPTAB.'POINT_1' et SUPTAB.'POINT_2' | 
 *|          definis en haut on donne encore :                          | 
 *|                                                                     | 
 *| SUPTAB.'CHPOINT_TRANSFORMATION' = Objet de type CHPOINT utilise     | 
 *|                                   pour transformer une coude en un  | 
 *|                                   tuyauterie droite.                | 
 *| SUPTAB.'OPERATEUR' = Objet de type MOT valant 'PLUS' ou 'MOIN' pour | 
 *|                      indiquer l'operateur PLUS ou MOIN a utiliser   | 
 *|                      si l'on veut transformer la coude en un        | 
 *|                      tuyauterie droite.                             | 
 *|                                                                     | 
 *|    7 : Rotation rigidifiante imposee dans le calcul par PASAPAS     | 
 *|                                                                     | 
 *| SUPTAB.'ROTATION_RIGIDIFIANTE' = table indicee par entiers 0,1,2... | 
 *|                                  donnant les champs de deplacements | 
 *|                                  due a une rotation rigidifiante de | 
 *|                                  la piece autour d'un point. Cette  | 
 *|                                  rotation rigidifiante est imposee  | 
 *|                                  dans le calcul par PASAPAS en tant | 
 *|                                  d'un calcul en grand deplacement.  | 
 *|                                                                     | 
 *|    8 : Cas ou on souhaite donner soi-meme le champ THETA            | 
 *|                                                                     | 
 *| SUPTAB.'CHAMP_THETA' = Objet de type CHPOINT caracterisant la       | 
 *|                        propagation de la fissure. Dans ce cas,      | 
 *|                        ne pas fournir l'indice 'COUCHE' de SUPTAB,  | 
 *|                        mais fournir 'CHAMP_THETA' a chaque appel.   | 
 *|                                                                     | 
 *|    9 : Cas ou on souhaite calculer une integrale dans l epaisseur   | 
 *|        d une structure en coque (rapport DMT/96-317)                | 
 *|                                                                     | 
 *|        On utilise pour cela la technique de multicouche, qui        | 
 *|        consiste, avant d'appeler la proceduer G_THETA, a :          | 
 *|        1) Etablir un modele multicouches (cf MODE CONS) sur un ou   | 
 *|           des element(s) proche(s) de la fissure sachant qu'il faut | 
 *|           au moins une couche en peau inferieure, une couche en     | 
 *|           peau superieure, une couche en ligne moyenne {ces couches | 
 *|           doivent avoir une epaisseur inferieure a 1e-4*(epaisseur  | 
 *|           totale de la coque) et donc 2 couches intermediaires.     | 
 *|        2) Penser a donner un excentrement et un nom constituant     | 
 *|           different a ces couches.                                  | 
 *|        3) Assembler le modele multicouches avec le modele du reste  | 
 *|           de la structure.                                          | 
 *|        4) Effectuer le calcul des contraintes et des deplacements   | 
 *|           avec le modele total et le materiau qui en decoule.       | 
 *|        Le calcul de l'integrale avec la procedure G_THETA sera      | 
 *|        realise sur un seul element en multicouche et pour toutes les| 
 *|        couches dans cet element qui ont une epaisseur inferieure a  | 
 *|        1e-4*(epaisseur totale de la coque). Un tel element doit     | 
 *|        etre designe par l'argument suivant :                        | 
 *|                                                                     | 
 *| SUPTAB.'ELEMENT_MULTICOUCHE' = Objet MAILLAGE comportant UN SEUL    | 
 *|                                element modelise en multicouche. Il  | 
 *|                                doit etre a l'interieur de la zone   | 
 *|                                THETA, c'est a dire dans la zone     | 
 *|                                definie par le nombre SUPTAB.'COUCHE'. 
 *|                                Il ne doit pas etre trop loin, ni    | 
 *|                                trop proche de la pointe de la       | 
 *|                                fissure. Theoriquement, l'integrale  | 
 *|                                a calculer est independant du choix  | 
 *|                                de l'element pres de la fissure, ce  | 
 *|                                qui est numeriquement verifiable en  | 
 *|                                la determinant sur des elemens en    | 
 *|                                multicouche differents. NOTA : Cette | 
 *|                                technique necessite un maillage tres | 
 *|                                fin dans la zone de la pointe de la  | 
 *|                                fissure.                             | 
 *|                                                                     | 
 *|                                                                     | 
 *|    SORTIE :                                                         | 
 *|    ========                                                         | 
 *|                                                                     | 
 *| Les resultats du calcul correspondant a un champ THETA specifie par | 
 *| l'objet SUPTAB.'COUCHE' (ou SUPTAB.'CHAMP_THETA' dans le cas ou on  | 
 *| souhaite donner soi-meme un champ de type Theta) sont sauves de la  | 
 *| maniere suivante :                                                  | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Dans tous les cas de calcul                                      | 
 *|    ---------------------------                                      | 
 *|                                                                     | 
 *| SUPTAB.'RESULTATS' = Objet contenant la valeur numerique du calcul. | 
 *|                      Son type est variable selon qu'on est en 2D ou | 
 *|                      3D et selon la solution du probleme traite :   | 
 *|                                                                     | 
 *|                      1) valeur de l'integrale de contour dans le cas| 
 *|                         d'une solution provenant de l'operateur RESO| 
 *|                         2D        => FLOTTANT                       | 
 *|                         3D massif => TABLE indicee par              | 
 *|                            .(points au front de fissure)            | 
 *|                            .'GLOBAL' pour une estimation globale    | 
 *|                         3D coque  => TABLE indicee par mots         | 
 *|                            .'SUPERI' en peau superieure             | 
 *|                            .'INFERI' en peau inferieure             | 
 *|                            .'MEDIAN' au plan median et              | 
 *|                            .'GLOBAL' pour une estimation globale    | 
 *|                                                                     | 
 *|                      2) valeur de l'integrale de contour a un       | 
 *|                         certain pas du calcul dans le cas d'une     | 
 *|                         solution provenant de la procedure PASAPAS  | 
 *|                         2D        => TABLE indicee par              | 
 *|                            .(numero du pas de calcul)               | 
 *|                         3D massif => TABLE indicees par             | 
 *|                            .(numero du pas de calcul).(points au    | 
 *|                              front de fissure)                      | 
 *|                         3D coque  => TABLE indicees                 | 
 *|                            .(numero du pas de calcul).'SUPERI'      | 
 *|                            .(numero du pas de calcul).'INFERI'      | 
 *|                            .(numero du pas de calcul).'MEDIAN' et   | 
 *|                            .(numero du pas de calcul).'GLOBAL'      | 
 *|                                                                     | 
 *|                      3) valeur des F.I.C. (facteurs d'intensite des | 
 *|                         contraintes) dans le cas de decouplage des  | 
 *|                         modes avec une solution provenant de        | 
 *|                         l'operateur RESO                            | 
 *|                         2D        => TABLE indicee par mots         | 
 *|                            .'I'  pour KI                            | 
 *|                            .'II' pour KII                           | 
 *|                         3D massif => TABLE indicees par             | 
 *|                            .'I'  .(points au front de fissure)      | 
 *|                              pour KI                                | 
 *|                            .'II' .(points au front de fissure)      | 
 *|                              pour KII                               | 
 *|                            .'III'.(points au front de fissure)      | 
 *|                              pour KIII et                           | 
 *|                            .'GLOBAL'.(points au front de fissure)   | 
 *|                                                                     | 
 *|                      4) valeur des F.I.C. (facteurs d'intensite des | 
 *|                         contraintes) a un certain pas du calcul     | 
 *|                         dans le cas de decouplage des modes avec    | 
 *|                         une solution provenant de la procedure      | 
 *|                         PASAPAS                                     | 
 *|                         2D        => TABLE indicees                 | 
 *|                            .'I' .(numero du pas de calcul) pour KI  | 
 *|                            .'II'.(numero du pas de calcul) pour KII | 
 *|                         3D massif => TABLE indicees par             | 
 *|                            .'I'  .(numero du pas de calcul).(point  | 
 *|                              au front de fissure) pour KI           | 
 *|                            .'II' .(numero du pas de calcul).(points | 
 *|                              au front de fissure) pour KII          | 
 *|                            .'III'.(numero du pas de calcul).(points | 
 *|                              au front de fissure) pour KIII         | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Dans le cas de calcul effectue pas a pas                         | 
 *|    ----------------------------------------                         | 
 *|                                                                     | 
 *| SUPTAB.'EVOLUTION_RESULTATS' = Objet contenant l'evolution des      | 
 *|                                resultats en fonction du temps.      | 
 *|                                Son type est variable selon la       | 
 *|                                configuration du probleme traite :   | 
 *|                                                                     | 
 *|                             1) Evolution de l'integrale de contour  | 
 *|                                2D        => EVOLUTION               | 
 *|                                3D massif => TABLE indicee par       | 
 *|                                   .(points au front de fissure)     | 
 *|                                   .'GLOBAL' evolution pour une      | 
 *|                                     estimation globale              | 
 *|                                3D coque  => TABLE indicee par MOTS  | 
 *|                                   .'SUPERI' en peau superieure      | 
 *|                                   .'INFERI' en peau inferieure      | 
 *|                                   .'MEDIAN' au plan median et       | 
 *|                                   .'GLOBAL' evolution pour une      | 
 *|                                     estimation globale              | 
 *|                                                                     | 
 *|                             2) Evolution des F.I.C. (facteurs       | 
 *|                                d'intensite de contrainte)           | 
 *|                                2D        => TABLE indicee par       | 
 *|                                   .'I'  pour KI                     | 
 *|                                   .'II' pour KII                    | 
 *|                                3D massif => TABLE indicee par       | 
 *|                                   .'I'.  (points au front de fissure) 
 *|                                   .'II'. (points au front de fissure) 
 *|                                   .'III'.(points au front de fissure) 
 *|                                   .'GLOBAL' evolution pour une      | 
 *|                                     estimation globale              | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Dans le cas des elements de coque                                | 
 *|    ---------------------------------                                | 
 *|                                                                     | 
 *| SUPTAB.'EPAISSEUR_RESULTATS' = representant l'evolution de la valeur| 
 *|                                des integrales dans l'epaisseur de la| 
 *|                                coque. Son type est variable selon la| 
 *|                                solution du probleme traite :        | 
 *|                             1) EVOLUTION dans le cas d'une solution | 
 *|                                provenant de l'operateur RESO        | 
 *|                             2) TABLE indicee par .(numero du pas de | 
 *|                                calcul) dans le cas d'une solution   | 
 *|                                provenant de la procedure PASAPAS    | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Dans le cas de calcul elasto-plastique                           | 
 *|    --------------------------------------                           | 
 *|                                                                     | 
 *| SUPTAB.'CRITERE_DECHARGE' = En cas de calcul elasto-plastique       | 
 *|         isotrope ou cinematique, eventuellement thermique, on       | 
 *|         calcul un critere de decharge des contraintes defini par    | 
 *|         (si, F = courbe de traction ): crit = F(EPSeq)/ SIGeq.      | 
 *|         crit = 1. si non-decharge et crit > 1. si decharge.         | 
 *|         SUPTAB.'CRITERE_DECHARGE' est une table indicee par les     | 
 *|         temps de calcul.                                            | 
 *|                                                                     | 
 *|                                                                     | 
 *|    Dans le cas du contact frottement sur les levres                 | 
 *|    --------------------------------------                           | 
 *|                                                                     | 
 *| A ce jour, cela est traite pour le cas xfem (these de B.Trolle).    | 
 *|                                                                     | 
 *|=====================================================================| 
   
 * INTRODUCTION DE VARIABLES UTILES 
 * -------------------------------- 
   
 * CREATION DE LA TABLE DE BOOLEENS 
 * ******************************** 
   
 BOOL = TABL ; 
 BOOL.'TRAC' = FAUX ; 
 BOOL.'MESS' = VRAI ; 
 SI BOOL.'MESS' ; 
         SAUT 'LIGNE' ; 
         MESS '------------------' 'DEBUT DE LA PROCEDURE G_THETA' 
         '--------------------' ; 
 FINSI ; 
 SAUT 'LIGNE' ; 
   
 * CONFIGURATION INITIALE 
 * ********************** 
   
 CONFIG0 = FORM ; 
   
   
 * ============================================================================= 
   
 * DETERMINATION DU CAS DEMANDE ET VERIFICATION DES DONNEES OBLIGATOIRES 
 * --------------------------------------------------------------------- 
   
 * APPEL A G_CAS 
 * ************* 
   
 OBJUTI = G_CAS SUPTAB BOOL ; 
 SI (EGA (TYPE OBJUTI) (MOT 'ANNULE')) ; 
         MESS 'ERREUR : IL Y A EU UN PROBLEME INATTENDU PENDANT LA LECTURE DES' ; 
         MESS '         DONNEES' ; 
         QUIT G_THETA ; 
 FINSI ; 
   
   
 * LECTURE DES DONNEES FOURNIES 
 * **************************** 
   
 GDIME = OBJUTI.'DIMENSION' ; 
 GMODE = OBJUTI.'MODE' ; 
 MOD_TOT = OBJUTI.'MOD_TOT' ; 
 MOD_MEC = OBJUTI.'MOD_MEC' ; 
 MAT_MEC = OBJUTI.'MAT_MEC' ; 
 SI BOOL.'PASAPAS' ; 
         WTAB = OBJUTI.'WTAB' ; 
 FINSI ; 
 MAILLAGE = OBJUTI.'MAILLAGE' ; 
 M_FRONT = OBJUTI.'FRONT' ; 
   
   
 * QUELQUES DONNEES NON ISSUES DE G_CAS 
 * ************************************ 
   
 * TYPE D'ELEMENTS DU MAILLAGE 
 LELEM1 = MAILLAGE ELEM 'TYPE' ; 
   
 SI BOOL.'MODE_PRES' ; 
         MODCHA = EXTR MOD_TOT 'FORM' 'CHARGEMENT' ; 
         MODPRE = EXTR MODCHA 'COMP' 'PRESSION' ; 
         SI (NON BOOL.'PASAPAS') ; 
                 MATPRE = REDU (SUPTAB.'PRESSION') MODPRE ; 
         FINSI ; 
         MAILPTOT = EXTR MODPRE 'MAIL' ; 
         MAILPF = INTE MAILPTOT (SUPTAB.'FISSURE') ; 
 FINSI ; 
 * VERIFICATIONS DANS LE CAS DE PERSO1 
 SI BOOL.'PERSO1' ; 
         SI BOOL.'MESS' ; 
                 MESS 'utilisation de PERSO1 en cours de dvlpt' ; 
         FINSI ; 
         SI (EXIS SUPTAB.'SOLUTION_PASAPAS' 'ESTIMATION') ; 
                 ESTIM = SUPTAB.'SOLUTION_PASAPAS'.'ESTIMATION' ; 
         SINON ; 
                 MESS 'ERREUR : il faut une ESTIMATION dans la SOLUTION_PASAPAS' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         SI (NON (EXIS SUPTAB 'MAILLAGE_REDUIT')) ; 
                 MESS 'Attention! utilisation de PERSO1 sans MAILLAGE_REDUIT' ; 
                 MESS 'uniquement valable dans le cas de fissure stationnaire' ; 
         FINSI ; 
 FINSI ; 
   
   
 * MOTS DE COMPOSANTES UTILES 
 * ************************** 
   
 * LISTMOT SCAL : 
 MTS1 = MOTS 'SCAL' ; 
 * LISTMOTS POUR LE DEPLACEMENT ET POUR LA FORCE : 
 * ON EXTRAIT LES GDIME PREMIERS MOTS CAR ON NE VEUT PAS DES ROTATIONS 
 * DANS LE CAS DES COQUES 
 MUI = EXTR (EXTR MOD_MEC 'DEPL') (LECT 1 PAS 1 GDIME) ; 
 MFI = EXTR (EXTR MOD_MEC 'FORC') (LECT 1 PAS 1 GDIME) ; 
 MU1 = EXTR MUI 1 ; MU2 = EXTR MUI 2 ; 
 MF1 = EXTR MFI 1 ; MF2 = EXTR MFI 2 ; 
 SI (EGA GDIME 3) ; 
         MF3 = EXTR MFI 3 ; 
 FINSI ; 
   
   
 * CREATION DE CHAR1 SI PASAPAS 
 * **************************** 
   
 SI BOOL.'PASAPAS' ; 
         CHAR1 = SUPTAB.'SOLUTION_PASAPAS'.'CHARGEMENT' ; 
 FINSI ; 
   
   
 * DONNEES EN CAS DE CONTACT 
 * ************************* 
   
 SI ((NON BOOL.'PASAPAS') ET BOOL.'FROT') ; 
         OBJCON = SUPTAB.'MODELE_FISSURE' ; 
         MAICON = EXTR OBJCON 'MAILLAGE' ; 
 FINSI ; 
   
   
 * ============================================================================= 
   
 * EXTRACTION DU MAILLAGE, DU CHAMP THETA ET DE LA DIRECTION DE PROPAGATION 
 * ------------------------------------------------------------------------ 
   
 * MODELE MULTICOUCHES DANS LE CAS DE COQUE 
 * **************************************** 
   
 SI BOOL.'COQ' ; 
         M_DETA = EXTR MOD_MEC 'ZONE' ; 
         SI (EXIS SUPTAB 'ELEMENT_MULTICOUCHE') ; 
                 ELMULT = SUPTAB.'ELEMENT_MULTICOUCHE' ; 
                 SI (NEG (TYPE ELMULT) 'MAILLAGE') ; 
                         MESS 'ERREUR : L ELEMENT EN MULTICOUCHE DOIT' ; 
                         MESS '         ETRE UN OBJET DE TYPE MAILLAGE' ; 
                         ERRE 21 ; QUIT G_THETA ; 
                 FINSI ; 
                 SI (NEG (NBEL ELMULT) 1) ; 
                         MESS 'ERREUR : ON VEUT UN SEUL ELEMENT EN MULTICOUCHE' ; 
                         ERRE 21 ; QUIT G_THETA ; 
                 FINSI ; 
         SINON ; 
                 MESS 'ERREUR : IL FAUT DESIGNER UN ELEMENT EN MULTICOUCHE' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         M_ELMU = EXTR (REDU MOD_MEC ELMULT) 'ZONE' ; 
         SI ((DIME M_ELMU) '<' 10) ; 
                 MESS 'ERREUR : IL FAUT AU MOINS 3 COUCHES (peau inf, peau' ; 
                 MESS '         sup, ligne moyenne) D EPAISSEUR INFERIEURE' ; 
                 MESS '         A 1E-4*(EPAISSEUR TOTALE) + 2 COUCHES' ; 
                 MESS '         INTERMEDIAIRES POUR L ELEMENT DESIGNE EN' ; 
                 MESS '         MULTICOUCHE PROCHE DE LA FISSURE.' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         PEX1 = PROG ; LMO1 = LECT ; MODCOU = TABLE ; EPAITO = 0. ; 
         REPE NBJ5 ((DIME M_ELMU)/2) ; 
                 I1 = (2 * &NBJ5) - 1 ; 
                 MODCOU.&NBJ5 = M_ELMU.I1 ; 
                 EX1 = EXTR (REDU MODCOU.&NBJ5 MAT_MEC) 'EXCE' 1 1 1 ; 
                 EP1 = EXTR (REDU MODCOU.&NBJ5 MAT_MEC) 'EPAI' 1 1 1 ; 
                 EPAITO = EPAITO + EP1 ; 
                 PEX1 = PEX1 ET (PROG EX1) ; 
                 LMO1 = LMO1 ET (LECT &NBJ5) ; 
         FIN NBJ5 ; 
         NSUPE = 0 ; NMOYE = 0 ; NINFE = 0 ; 
         REPE NBJ6 (DIME MODCOU) ; 
                 EX1 = EXTR PEX1 &NBJ6 ; 
                 LM1 = EXTR LMO1 &NBJ6 ; 
                 SI (EGA EX1 (EPAITO/2.) 1.E-4) ; 
                         NSUPE = LM1 ; 
                 FINSI ; 
                 SI (EGA EX1 0. 1.E-10) ; 
                         NMOYE = LM1 ; 
                 FINSI ; 
                 SI (EGA EX1 (EPAITO/(-2.)) 1.E-4) ; 
                         NINFE = LM1 ; 
                 FINSI ; 
         FIN NBJ6 ; 
         SI (EGA NSUPE 0) ; 
                 MESS 'ERREUR : IL FAUT UNE COUCHE EN PEAU SUPERIEURE' ; 
                 MESS '         D EPAISSEUR INFERIEURE A' ; 
                 MESS '         1E-4*(EPAISSEUR TOTALE) ' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         SI (EGA NMOYE 0) ; 
                 MESS 'ERREUR : IL FAUT UNE COUCHE AU PLAN MEDIAN' ; 
                 MESS '         AYANT UN EXCENTREMENT NUL' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         SI (EGA NINFE 0) ; 
                 MESS 'ERREUR : IL FAUT UNE COUCHE EN PEAU INFERIEURE' ; 
                 MESS '         D EPAISSEUR INFERIEURE A' ; 
                 MESS '         1E-4*(EPAISSEUR TOTALE) ' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         SUPTAB.'EPAISSEUR' = EPAITO ; 
         M_SUPE = MODCOU.NSUPE ; 
         M_MOYE = MODCOU.NMOYE ; 
         M_INFE = MODCOU.NINFE ; 
 FINSI ; 
   
   
 * MAILLAGE UTILISE DANS LA RESOLUTION PAR E.F. 
 * ******************************************** 
   
 SI BOOL.'COQ' ; 
         TMULT = TABL ; 
         REPE NBJ8 ((DIME M_DETA)/2) ; 
                 M1 = M_DETA.(2*&NBJ8) ; 
                 SI (EXIS TMULT M1) ; 
                         ITER NBJ8 ; 
                 FINSI ; 
                 M2 = EXTR (REDU MOD_MEC M1) 'ZONE' ; 
                 SI (> (DIME M2) 2) ; 
                         TMULT.M1 = VRAI ; 
                         REPE NBJ9 (((DIME M2)/2) - 1) ; 
                                 MAILLAGE = DIFF MAILLAGE M1 ; 
                         FIN NBJ9 ; 
                 FINSI ; 
         FIN NBJ8 ; 
 FINSI ; 
 SUPTAB.'MAILLAGE' = MAILLAGE ; 
   
   
 * DETERMINATION DES CHAMPS THETA ET PI ET DE LA ZONE DE TRAVAIL ELTETA 
 * ******************************************************************** 
   
 SI BOOL.'MESS' ; 
         MESS 'DETERMINATION DES CHAMPS THETA' ; 
 FINSI ; 
 SI ((EXIS SUPTAB 'COUCHE') ET (EXIS SUPTAB 'CHAMP_THETA')) ; 
 *       COUCHE ET CHAMP_THETA TOUS LES DEUX DONNES 
         MESS 'NOMBRE DE COUCHES DONNE => LE CHAMP_THETA FOURNI SERA ECRASE' ; 
 FINSI ; 
 * DETERMINATION DE CHAMP_THETA 
 SI (EXIS SUPTAB 'COUCHE') ; 
 *       NOMBRE DE COUCHE DONNE => ON APPELLE CH_TETX OU CH_TETA POUR CALCULER 
 *       CHAMP_THETA 
 *       SI CHAMP_THETA EST EGALEMENT FOURNI, IL EST ECRASE 
         SI BOOL.'XFEM' ; 
                 SUPTAB.'CHAMP_THETA' SUPTAB.'UTILTET1' = CH_THETX SUPTAB ; 
         SINON ; 
                 SUPTAB.'CHAMP_THETA' SUPTAB.'UTILTET1' = CH_THETA SUPTAB ; 
                 SI BOOL.'DJ/DA' ; 
                         SI (NON (EXIS SUPTAB 'FRONT_FISSURE_2')) ; 
                                 SUPTAB.'COUCHE' = (SUPTAB.'COUCHE') - 1 ; 
                                 SUPTAB.'CHAMP_PI' UTILPI = CH_THETA SUPTAB ; 
                                 SUPTAB.'COUCHE' = (SUPTAB.'COUCHE') + 1 ; 
                         SINON ; 
                                 P1 = SUPTAB.'FRONT_FISSURE' ; 
                                 SUPTAB.'FRONT_FISSURE' = SUPTAB.'FRONT_FISSURE_2' ; 
                                 SUPTAB.'FISSURE' = SUPTAB.'FISSURE_2' ; 
                                 SUPTAB.'CHAMP_PI' UTILPI = CH_THETA SUPTAB ; 
                                 SUPTAB.'FRONT_FISSURE' = P1 ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
 SINON ; 
         MESS 'CHAMP_THETA FOURNI PAR L UTILISATEUR' ; 
 FINSI ; 
 CHTHETA = SUPTAB.'CHAMP_THETA' ; 
 SI (NEG (TYPE CHTHETA) 'CHPOINT') ; 
         CHTHETA = CHTHETA.'GLOBAL' ; 
 FINSI ; 
 * DETERMINATION DE ELTETA 
 * ELTETA1 = MAILLAGE OU TETA N EST PAS NUL + 1 COUCHE 
 UU = EXTR CHTHETA 'MAILLAGE' ; 
 ELTETA1 = ELEM MAILLAGE 'APPU' 'LARG' UU ; 
 SI (EXIS SUPTAB 'MAILLAGE_REDUIT') ; 
 *       ELTETA = MAILLAGE FOURNI PAR L UTILISATEUR 
         ELTETA = SUPTAB.'MAILLAGE_REDUIT' ; 
 *       VERIFICATION DE LA COMPATIBILITE AVEC CHTHETA 
         SI ((NBEL (DIFF ELTETA ELTETA1)) NEG 0) ; 
                 MESS 'ATTENTION : LE MAILLAGE_REDUIT DONNE EST INCOMPATIBLE AVEC LE' ; 
                 MESS '            CHAMP THETA, IL SERA DONC IGNORE.' ; 
                 ELTETA = ELTETA1 ; 
         FINSI ; 
 SINON ; 
         ELTETA = ELTETA1 ; 
 FINSI ; 
 * DETERMINATION DE LA DIRECTION DE PROPAGATION ET DES NORMALES 
 SI BOOL.'XFEM' ; 
 *       ON EST DANS LE CAS XFEM 
         MOD7 = MODE ELTETA 'THERMIQUE' ; 
         GPSI = GRAD MOD7 (NOMC 'T' SUPTAB.'PSI' 'NATU' 'DIFFUS') ; 
         GPSI = CHAN 'NOEUD' MOD7 GPSI 'SCALAIRE' ; 
         GPHI = GRAD MOD7 (NOMC 'T' SUPTAB.'PHI' 'NATU' 'DIFFUS') ; 
         GPHI = CHAN 'NOEUD' MOD7 GPHI 'SCALAIRE' ; 
         NCOMP = EXTR GPSI 'COMP' ; 
         SI (EGA GDIME 2) ; 
 *               LA DIRECTION DE PROPAGATION EST PERPENDICULAIRE A GRAD PHI ET DANS LE 
 *               MEME SENS QUE GRAD PSI => ON UTILISE UN PRODUIT VECTORIEL 
 *               ETAPE 1 : PROJECTION SUR LE FRONT DE FISSURE ET PASSAGE EN CHPO 
                 PGPSI = PROI M_FRONT GPSI ; 
                 PGPHI = PROI M_FRONT GPHI ; 
 *               ETAPE 2 : PRODUIT VECTORIEL AVEC LA NORMALE AU PLAN 
 *               NB : ON FAIT ATTENTION AU SENS DE TETA GRACE A SIGN 
                 TETA = PVEC PGPHI NCOMP MUI ; 
                 SIGN1 = SIGN (PSCA TETA PGPSI MUI NCOMP) ; 
                 TETA = SIGN1 * TETA ; 
 *               ETAPE 3 : NORMALISATION ET CALCUL DE DIR2 
                 NTETA = (PSCA TETA TETA MUI MUI)**0.5 ; 
                 DIR1 = TETA / NTETA ; 
                 DIR2 = PVEC DIR1 MUI MUI ; 
         SINON ; 
 *               PASSAGE DES DIRECTIONS EN CHPO ET PRODUITS VECTORIELS 
                 DIR1 = CHAN 'CHPO' MOD7 GPSI 'MOYE' ; 
                 DIR2 = CHAN 'CHPO' MOD7 GPHI 'MOYE' ; 
                 DIR3 = PVEC DIR1 NCOMP DIR2 NCOMP MUI ; 
                 DIR1 = PVEC DIR2 NCOMP DIR3 MUI MUI ; 
 *               NORMALISATION, INTERPOLATION PUIS RENORMALISATION : 
 *               POUR DIR1 ON FAIT ATTENTION CAR ON PEUT AVOIR UN POINT SINGULIER 
                 NDIR1 = (PSCA DIR1 DIR1 MUI MUI)**0.5 ; 
                 MASQ1 = MASQ NDIR1 'SUPERIEUR' 1.E-2 ; 
                 BORN1 = BORN NDIR1 'SCAL' 'MINIMUM' 1.E-2 ; 
                 DIR1 = CHAN 'ATTRIBUT' (DIR1 / BORN1 * MASQ1) 'NATURE' 'DIFFUS' ; 
                 V1 = DIR1 ; 
                 DIR1 = INT_COMP ELTETA DIR1 M_FRONT ; 
                 DIR1 = DIR1 / ((PSCA DIR1 DIR1 MUI MUI)**0.5) ; 
 *               POUR DIR2 PAS DE PROBLEME 
                 DIR2 = NOMC NCOMP MUI DIR2 ; 
                 NDIR2 = (PSCA DIR2 DIR2 MUI MUI)**0.5 ; 
                 DIR2 = CHAN 'ATTRIBUT' (DIR2 / NDIR2) 'NATURE' 'DIFFUS' ; 
                 V2 = DIR2 ; 
                 DIR2 = INT_COMP ELTETA DIR2 M_FRONT ; 
                 DIR2 = DIR2 / ((PSCA DIR2 DIR2 MUI MUI)**0.5) ; 
 *               POUR DIR3 ON FAIT ATTENTION CAR ON PEUT AVOIR UN POINT SINGULIER 
                 NDIR3 = (PSCA DIR3 DIR3 MUI MUI)**0.5 ; 
                 MASQ3 = MASQ NDIR3 'SUPERIEUR' 1.E-2 ; 
                 BORN3 = BORN NDIR3 'SCAL' 'MINIMUM' 1.E-2 ; 
                 DIR3 = CHAN 'ATTRIBUT' (DIR3 / BORN3 * MASQ3) 'NATURE' 'DIFFUS' ; 
                 V3 = DIR3 ; 
                 DIR3 = INT_COMP ELTETA DIR3 M_FRONT ; 
                 DIR3 = DIR3 / ((PSCA DIR3 DIR3 MUI MUI)**0.5) ; 
         FINSI ; 
 SINON ; 
 *       ON EST DANS LE CAS STD 
         DIR1 = REDU CHTHETA (SUPTAB.'FRONT_FISSURE') ; 
         NDIR1 = (PSCA DIR1 DIR1 MUI MUI)**0.5 ; 
         DIR1 = DIR1 / NDIR1 ; 
         SI (NON BOOL.'COQ') ; 
                 SI (EXIS SUPTAB 'LEVRE_SUPERIEURE') ; 
                         F1 = PRES 'MASS' MOD_MEC SUPTAB.'LEVRE_SUPERIEURE' 1. ; 
                 SINON ; 
                         F1 = PRES 'MASS' MOD_MEC SUPTAB.'LEVRE_INFERIEURE' -1. ; 
                 FINSI ; 
                 DIR2 = REDU F1 (SUPTAB.'FRONT_FISSURE') ; 
                 DIR2 = EXCO DIR2 MFI MUI 'NOID' ; 
                 NDIR2 = (PSCA DIR2 DIR2 MUI MUI)**0.5 ; 
                 DIR2 = DIR2 / NDIR2 ; 
                 SI (EGA GDIME 3) ; 
                         DIR3 = PVEC DIR1 DIR2 MUI MUI MUI ; 
                 FINSI ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'TRAC' ; 
         VCHTHETA = VECT CHTHETA 'DEPL' 'BLEU' ; 
         TRAC VCHTHETA (MAILLAGE ET M_FRONT) 'TITR' 'CHAMP_THETA' ; 
 FINSI ; 
   
   
 * DETERMINATION DU REPERE LOCAL 
 * ***************************** 
   
 * ON STOCKE LES DIRECTIONS DANS UTILTETA 
 * DIRECTION DE PROPAGATION : DIR1 
 * DIRECTION TANGENTE AU FRONT : DIR2 
 * DIRECTION DE CISAILLEMENT SI SEPARATION DE MODES : DIR3 
 UTILTETA = TABL ; 
 UTILTETA.'DIRECTION1' = DIR1 ; 
 SI (NON BOOL.'COQ') ; 
         UTILTETA.'DIRECTION2' = DIR2 ; 
         SI (EGA GDIME 3) ; 
                 UTILTETA.'DIRECTION3' = DIR3 ; 
         FINSI ; 
 FINSI ; 
   
   
 * ON COMPLETE ELTETA 
 * ****************** 
   
 * AJOUT EVENTUEL DE ELPI A ELTETA 
  SI ((EXIS SUPTAB 'FRONT_FISSURE_2') ET BOOL.'DJ/DA') ; 
         ELPI = SUPTAB.'FRONT_FISSURE_2' ; 
         REPE MAIL2 ((SUPTAB.'COUCHE') + 1) ; 
                 ELPI = MAILLAGE ELEM 'APPU' 'LARG' ELPI ; 
         FIN MAIL2 ; 
         ELTETA = ELTETA ET ELPI ; 
  FINSI ; 
   
 * AJOUT DU NOEUD SUPPORT EN DEF.PL.GENERALISEES 
 SI (EGA GMODE 'PLANGENE') ; 
         ELTETA = ELTETA ET (VALE 'MODE' 'PLANGENE') ; 
 FINSI ; 
 ELPOI1 = CHAN ELTETA 'POI1' ; 
   
 * L'ELEMENT SUPPORTANT LE MODELE MULTICOUCHE 
 * DOIT ETRE DANS LA ZONE THETA 
 SI BOOL.'COQ' ; 
         N1 = NBNO ELTETA ; 
         N2 = NBNO (ELTETA ET (EXTR M_MOYE 'MAIL')) ; 
         SI (NEG N1 N2) ; 
                 MESS 'ERREUR : L ELEMENT EN MULTICOUCHE DESIGNE POUR CALCULER' ; 
                 MESS '         L INTEGRALE SE TROUVE EN DEHORS DE LA ZONE' ; 
                 MESS '         DEFINIE PAR LE NOMBRE DE COUCHES DONNE.' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
 FINSI ; 
   
   
 * TESTS DE COMPATIBILITE 
 * ********************** 
   
 * BOOL.'REPRI' = VRAI SI REPRISE DE CALCUL, FAUX SINON 
 BOOL.'REPRI' = FAUX ; 
 SI (BOOL.'PASAPAS' ET (NON BOOL.'PERSO1')) ; 
         N1 = DIME (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS') ; 
         SI ((EXIS SUPTAB 'IABC') ET 
                 (EXIS SUPTAB 'ELTET1') ET 
                 (EXIS SUPTAB 'RESULTATS') ET 
                 (EXIS SUPTAB 'EVOLUTION_RESULTATS')) ; 
                 BOOL.'REPRI' = (N1 - 1) > SUPTAB.'IABC' ; 
                 MESS 'on tente une reprise...' ; 
         FINSI ; 
 FINSI ; 
   
 * TESTS DE COMPATIBILITE SI REPRISE DE CALCUL 
 SI BOOL.'REPRI' ; 
 *       ON VERIFIE QUE L OBJECTIF RESTE LE MEME 
         SI (NEG SUPTAB.'OBJ1' SUPTAB.'OBJECTIF') ; 
                 MESS 'ERREUR : REPRISE IMPOSSIBLE CAR L OBJECTIF DU' ; 
                 MESS '         CALCUL ACTUEL N EST PAS LE MEME QUE' ; 
                 MESS '         CELUI DU CALCUL PRECEDENT' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
 *       ON DOIT AVOIR LE MEME NOMBRE DE COUCHE (ON SUPPOSE LA FISSURE FIXE) 
         SI ((EXIS SUPTAB 'COUCHE') ET (EXIS SUPTAB 'COU1')) ; 
                 SI (NEG SUPTAB.'COU1' SUPTAB.'COUCHE') ; 
                         MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE NOMBRE DE' ; 
                         MESS '         COUCHE ACTUEL N EST PAS LE MEME QUE' ; 
                         MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT' ; 
                         ERRE 21 ; QUIT G_THETA ; 
                 FINSI ; 
         FINSI ; 
 *       RESTE A VERIFIER LA COMPATIBILITE DES SUPPORT DE CHAMP TETA VIA ELTETA 
 *       ELTETA DOIT ETRE INCLUS DANS ELTET1 
         ELTET1 = SUPTAB.'ELTET1' ; 
         SI(NEG (NBNO ELTETA) (NBNO (ELTET1 INTE ELTETA))) ; 
                 MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE SUPPORT DU ' ; 
                 MESS '         CHAMP_THETA FOURNI N EST PAS INCLUS DANS' ; 
                 MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         MESS 'REPRISE DU CALCUL AUTORISE !' ; 
 FINSI ; 
   
 * TESTS DE COMPATIBILITE SI UTILISATION DE PERSO1 
 SI (BOOL.'PERSO1' ET (EXIS SUPTAB 'ELTET1')) ; 
         ELTET1 = SUPTAB.'ELTET1' ; 
         SI(NEG (NBNO ELTETA) (NBNO (ELTET1 INTE ELTETA))) ; 
                 MESS 'ERREUR : REPRISE IMPOSSIBLE CAR LE SUPPORT DU ' ; 
                 MESS '         CHAMP_THETA FOURNI N EST PAS INCLUS DANS' ; 
                 MESS '         CELUI UTILISE POUR LE CALCUL PRECEDENT' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
         SI BOOL.'MESS' ; 
                 MESS 'POURSUITE DU CALCUL VIA PERSO1 AUTORISE !' ; 
         FINSI ; 
 FINSI ; 
   
   
 * ============================================================================= 
   
 * MODELES ET MATERIAUX DANS LA ZONE DE TRAVAIL 
 * -------------------------------------------- 
   
 * VERIFICATION DES DONNEES D ENTREE POUR MODELES_COMPOSITES 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES') ; 
         N1 = DIME SUPTAB.'MODELES_COMPOSITES' ; 
         M1 = EXTR MOD_MEC 'MAIL' ; 
         M2 = VIDE 'MAILLAGE' ; 
         REPE BIN4 N1 ; 
                 T1 = TYPE SUPTAB.'MODELES_COMPOSITES'.&BIN4 ; 
                 SI (NEG T1 'MMODEL  ') ; 
                         MESS 'ERREUR : LE TYPE DE L OBJET No' &BIN4 'DANS LA' ; 
                         MESS '         TABLE MODELES_COMPOSITES EST INCORRECTE' ; 
                         ERRE 21 ; QUIT G_THETA ; 
                 FINSI ; 
                 M2 = M2 ET (EXTR SUPTAB.'MODELES_COMPOSITES'.&BIN4 'MAIL') ; 
         FIN BIN4 ; 
         SI (NEG (NBNO M1) (NBNO M2)) ; 
                 MESS 'ERREUR : TOUS LES MODELES DE MATERIAUX' ; 
                 MESS '         COMPOSITES NE SONT PAS DONNES' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
 FINSI ; 
   
 * CREATION DE MOD_MEC ET TABMOD 
 TABMOD = TABL ; 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES') ; 
 *       CAS DE MODELES COMPOSITES (AVEC DISCONTINUITE) : ON A DU TRAVAIL 
         MOD_MEC_R = VIDE 'MMODEL' ; 
         REPE BIN1 (DIME SUPTAB.'MODELES_COMPOSITES') ; 
                 M1 = SUPTAB.'MODELES_COMPOSITES'.&BIN1 ; 
                 M2 = EXTR M1 'MAIL' ; 
                 N1 = NBNO M2 ; 
                 N2 = NBNO ELTETA ; 
                 N3 = NBNO (ELTETA ET M2) ; 
 *               SI ON A DES NOEUDS EN COMMUN, ... 
                 SI (NEG (N1 + N2) N3) ; 
                         M2 = CHAN M2 'POI1' ; 
 *                       ... ON LES RECUPERE 
                         E1 = (DIFF ELPOI1 M2) DIFF (ELPOI1 ET M2) ; 
                         N1 = NBNO (CONT ELTETA) ; 
                         N2 = NBNO (E1 ET (CONT ELTETA)) ; 
 *                       SI TOUS LES NOEUDS EN COMMUN SONT SUR LE CONTOUR 
 *                       => PAS D ELEMENTS A RECUPERER => ON PASSE AU MODELE SUIVANT 
                         SI (EGA N1 N2) ; 
                                 ITER BIN1 ; 
                         FINSI ; 
 *                       SINON, ON RECUPERE LES ELEMENTS CONCERNES ET LE MODELE REDUIT 
                         E1 = MAILLAGE ELEM 'APPU' 'STRI' E1 ; 
                         N1 = (DIME TABMOD) + 1 ; 
                         TABMOD.N1 = REDU M1 E1 ; 
                         MOD_MEC_R = MOD_MEC_R ET TABMOD.N1 ; 
                 FINSI ; 
         FIN BIN1 ; 
 SINON ; 
 *       CAS DE MODELES SANS DISCONTINUITE : ON A MOINS DE TRAVAIL 
         MOD_MEC_R = REDU MOD_MEC ELTETA ; 
         TABMOD.1 = MOD_MEC_R ; 
 FINSI ; 
 NBOBJ = DIME TABMOD ; 
 MAT_MEC = REDU MAT_MEC MOD_MEC_R ; 
   
 * CHAMP EPAISSEUR DANS LA ZONE DE TRAVAIL 
 SI BOOL.'COQ' ; 
         EPAICH = (CHAN (EXCO MAT_MEC 'EPAI' 'SCAL') 
                                 'STRESSES' MOD_MEC_R) CHAN 'TYPE' 'SCALAIRE' ; 
 FINSI ; 
   
   
 * CALCUL DE C* PAR DEUX TYPES DE MODELE FLUAGE 
 * ******************************************** 
 *** ITYPEF = 1  MODELE FLUAGE POUR LEQUEL ON A UNE EXPRESSION 
 ***             EXPLICITE DE L'INTEGRATION DE LA VITESSE DE 
 ***             DEFORMATION DE FLUAGE SUR LE TEMPS 
 *** ITYPEF = 2  MODELE FLUAGE POUR LEQUEL ON N'OBTIENT PAS 
 ***             FACILEMENT CETTE EXPRESSION EXPLICITE 
 *** ITYPEF = 99 SI EN ELASTO OU THERMO-ELASTO-PLASTICITE 
   
 * DETERMINATION DE ITYPEF 
 ITYPEF = 99 ; 
 SI (BOOL.'C*' OU BOOL.'C*H') ; 
         SI ((EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'NORTON') OU 
                 (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'POLYNOMIAL')) ; 
                 ITYPEF = 1 ; 
         FINSI ; 
         SI ((EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'BLACKBURN') OU 
                 (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'RCCMR_316') OU 
                 (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'RCCMR_304') OU 
                 (EXIS MOD_MEC_R 'MATE' 'FLUAGE' 'LEMAITRE')) ; 
                 ITYPEF = 2 ; 
         FINSI ; 
 FINSI ; 
   
   
 * INTERFACES DANS LA ZONE DE TRAVAIL 
 * ********************************** 
   
 * CREATION DES INTERFACES INTER-MODELE 
 BOOL.'PARAL' = VRAI ; LINTER = TABL ; 
 SI ((EXIS SUPTAB 'MODELES_COMPOSITES') ET ((DIME TABMOD) > 1)) ; 
 *       ON BOUCLE SUR LES MODELES QUI APPARTIENNENT A ELTETA 
         REPE BIN2 ((DIME TABMOD) - 1) ; 
                 M1 = EXTR (TABMOD.&BIN2) 'MAIL' ; 
                 IIN3 = &BIN2 ; 
                 NIN3 = (DIME TABMOD) - &BIN2 ; 
                 REPE BIN3 NIN3 ; 
                         IIN3 = IIN3 + 1 ; 
                         LE1 = LECT &BIN2 IIN3 ; 
                         M2 = EXTR (TABMOD . IIN3) 'MAIL' ; 
 *                       ON ITERE SI (M1 INCLUT DANS M2) OU (M2 INCLUT DANS M1) 
                         SI (EGA (NBNO (M1 DIFF M2)) 0) ; 
                                 ITER BIN3 ; 
                         FINSI ; 
 *                       ON ITERE SI M1 ET M2 N ONT PAS DE NOEUDS COMMUNS 
                         SI (EGA ((NBNO M1) + (NBNO M2)) (NBNO (M1 ET M2))) ; 
                                 ITER BIN3 ; 
                         FINSI ; 
 *                       ON RECUPERE L INTERFACE M1-M2 
                         L1 = (CONT M1) ELEM 'APPU' (CONT M2) ; 
                         N1 = NBNO M1 ; N2 = NBNO M2 ; 
 *                       LO1=VRAI <=> IL EXISTE DES NOEUDS COMMUNS A M1 ET M2 
                         LO1 = NEG (N1 + N2) (NBNO (M1 ET M2)) ; 
 *                       LO2=VRAI <=> IL N'Y A PAS 1 NOEUD COMMUN A M1 ET M2 
                         LO2 = NEG ('ABS' ((N1 + N2) - (NBNO (M1 ET M2)))) 1 ; 
 *                       LO4 = M1 ET M2 FORMENT BIEN UNE INTERFACE ET NE SE CHEVAUCHENT PAS 
                         LO4 = NEG (NBEL L1) 0 ; 
                         SI (LO1 ET LO2 ET LO4) ; 
 *                               ON AJOUTE L INTERFACE CAR ON A >1 NOEUDS EN COMMUN A M1 ET M2 
                                 LINTER.LE1 = L1 ; 
 *                               BOOL.'PARAL'=VRAI <=> TOUTES LES INTERFACES SONT // A LA FISSURE 
 *                               SI BOOL.'PARAL'=FAUX IL FAUT AJOUTER DES TERMES D INTERFACES AU C 
                                 P1 = (POIN L1 1) MOIN (POIN L1 2) ; 
                                 P1 = P1 / (NORM P1) ; 
 *                               PETITE MODIF CAR DIR1 DOIT ETRE UN CHPOINT DESORMAIS 
 *                               -> A VERIFIER ? 
                                 PDIR1 = RESU DIR1 ; 
                                 PRESU = (EXTR PDIR1 'MAIL') POIN 1 ; 
                                 XDIR1 = EXTR PDIR1 PRESU 'UX' ; 
                                 YDIR1 = EXTR PDIR1 PRESU 'UY' ; 
                                 SI (GDIME EGA 2) ; 
                                         PDIR1 = XDIR1 YDIR1 ; 
                                 SINON ; 
                                         ZDIR1 = EXTR PDIR1 PRESU 'UZ' ; 
                                         PDIR1 = XDIR1 YDIR1 ZDIR1 ; 
                                 FINSI ; 
                                 PDIR1 = PDIR1 / (NORM PDIR1) ; 
                                 LO1 = ((EGA P1 PDIR1 1.E-6) OU 
                                                 (EGA P1 (-1.*PDIR1) 1.E-6)) ; 
                                 BOOL.'PARAL' = BOOL.'PARAL' ET LO1 ; 
                         FINSI ; 
                 FIN BIN3 ; 
         FIN BIN2 ; 
 FINSI ; 
   
 * DANS LE CAS DECOUPLAGE SEULEMENT : 
 * TEST SI FRONT_FISSURE EST DANS UNE INTERFACE 
 BOOL.'DANS' = FAUX ; 
 SI ((NEG (DIME LINTER) 0) ET BOOL.'DECOUPLAGE') ; 
         IND1 = INDE LINTER ; 
         REPE BIN4 (DIME IND1) ; 
                 LE1 = IND1.&BIN4 ; 
                 M1 = CHAN LINTER.LE1 'POI1' ; 
                 N1 = NBNO M1 ; 
                 N2 = NBNO (M1 ET SUPTAB.'FRONT_FISSURE') ; 
                 SI (EGA N1 N2) ; 
                         BOOL.'DANS' = VRAI ; 
                         QUIT BIN4 ; 
                 SINON ; 
                         ITER BIN4 ; 
                 FINSI ; 
         FIN BIN4 ; 
 FINSI ; 
 * SI OUI (BOOL.'DANS'),ON DETERMINE LES MODELES SUP ET INF 
 MODINF = 0 ;  MODSUP = 0 ; 
 SI BOOL.'DANS' ; 
 *       ON REDEFINIT : BOOL.'PARAL'=VRAI <=> L'INTERFACE A LAQUELLE APPARTIENT LA FISSURE E 
         BOOL.'PARAL' = FAUX ; 
         M1 = EXTR TABMOD.(EXTR LE1 1) 'MAIL' ; 
         M2 = EXTR TABMOD.(EXTR LE1 2) 'MAIL' ; 
         LSUP = SUPTAB.'LEVRE_SUPERIEURE' ; 
         LINF = SUPTAB.'LEVRE_INFERIEURE' ; 
         N1 = NBNO M1 ; 
         N2 = NBNO M2 ; 
         NLSUP = NBNO LSUP ; 
         NLINF = NBNO LINF ; 
         N1SUP = NBNO (M1 ET LSUP) ; 
         N2INF = NBNO (M2 ET LINF) ; 
         SI ( ((N1 + NLSUP - N1SUP) > 1) ET ((N2 + NLINF - N2INF) > 1)) ; 
 *               LSUP ET MOD1 ONT PLUS D'1 POINT COMMUN  ET  IDEM POUR LINF ET MOD2 
                 MODSUP = TABMOD.(EXTR LE1 1) ; 
                 MODINF = TABMOD.(EXTR LE1 2) ; 
         SINON ; 
                 N1INF = NBNO (M1 ET LINF) ; 
                 N2SUP = NBNO (M2 ET LSUP) ; 
                 SI ( ((N1 + NLINF - N1INF) > 1) ET ((N2 + NLSUP - N2SUP) > 1)) ; 
                         MODSUP = TABMOD.(EXTR LE1 2) ; 
                         MODINF = TABMOD.(EXTR LE1 1) ; 
                 SINON ; 
                         MESS 'ERREUR : INCOMPATIBILITE ENTRE LE MODELES_COMPOSITES' ; 
                         MESS '         ET LES LEVRE_SUPERIEURE ET _INFERIEURE' ; 
                         ERRE 21 ; QUIT G_THETA ; 
                 FINSI ; 
         FINSI ; 
 *       LA FISSURE EST BIEN DANS LE PROLONGEMENT DE L' INTERFACE 
         BOOL.'PARAL' = VRAI ; 
 FINSI ; 
 * REM: il faudrait egalement verifier que MODSUP et MODINF suffisent a decrire E 
   
   
 * MODPLA : table indicee par entier pour stocker les modeles 
 *          mecaniques de chaque objet MMODEL. 
 ************************************************** 
 *** Elle est vide si le modele est elastique ou elastoplastique 
 *** avec une courbe de traction independante de la temperature. 
 *** Dans le cas contraire la table vaut : 
 ***    1 si le modele est plastique isotrope. Alors une 
 ***      nouvelle courbe de traction EPSE-SIGMA est faite. 
 ***    2 si le modele est plastique cinematique 
 ***    3 si le modele est plastique parfaite 
   
 BOOL.'GRADYOUN' = FAUX ; BOOL.'GRADNU' = FAUX ; 
 BOOL.'GRADALPH' = FAUX ; MODPLA = TABLE ; TABTRA = TABLE ; 
   
 REPE BCMOD1 NBOBJ ; 
         MODEI = TABMOD.&BCMOD1 ; 
         MATEI = REDU MAT_MEC MODEI ; 
   
 *       BOOL.'GRADYOUN' 
         YO1 = EXCO MATEI 'YOUN' ; 
         TYPYO = TYPE (EXTR YO1 'YOUN' 1 1 1) ; 
         SI (EGA TYPYO 'EVOLUTIO') ; 
                 BOOL.'GRADYOUN' = VRAI ; 
         SINON ; 
                 TEST1 = ((MAXI YO1) - (MINI YO1))/(MINI YO1) ; 
                 SI (TEST1 '>' 1.E-10) ; 
                         BOOL.'GRADYOUN' = VRAI ; 
                 FINSI ; 
         FINSI ; 
   
 *       BOOL.'GRADNU' 
         NU1 = EXCO MATEI 'NU' ; 
         TYPNU = TYPE (EXTR NU1 'NU' 1 1 1) ; 
         SI (EGA TYPNU 'EVOLUTIO') ; 
                 BOOL.'GRADNU' = VRAI ; 
         SINON ; 
                 TEST1 = ((MAXI NU1) - (MINI NU1))/(MINI NU1) ; 
                 SI (TEST1 '>' 1.E-10) ; 
                         BOOL.'GRADNU' = VRAI ; 
                 FINSI ; 
         FINSI ; 
   
 *       BOOL.'GRADALPH' 
         SI BOOL.'THER' ; 
                 AL1 = EXCO MATEI 'ALPH' ; 
                 TYPAL = TYPE (EXTR AL1 'ALPH' 1 1 1) ; 
                 SI (EGA TYPAL 'EVOLUTIO') ; 
                         BOOL.'GRADALPH' = VRAI ; 
                 SINON ; 
                         TEST1 = ((MAXI AL1) - (MINI AL1))/(MINI AL1) ; 
                         SI (TEST1 '>' 1.E-10) ; 
                                 BOOL.'GRADALPH' = VRAI ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
   
 *       COURBE DE TRACTION 
         SI (EXIS MATEI 'ECRO') ; 
                 TR1 = EXCO MATEI 'ECRO' ; 
                 TYPTR = TYPE (EXTR TR1 'ECRO' 1 1 1) ; 
                 SI (EGA TYPTR 'NUAGE   ') ; 
                         MODPLA.&BCMOD1 = 1 ; 
                         TRA1 = EXTR TR1 'ECRO' 1 1 1 ; COM1 = EXTR TRA1 'COMP' ; 
                         NOMEVO1 = MOT 'ECRO' ; NOMFLO1 = MOT 'T' ; 
                         REPE BNUA1 (DIME TRA1 'UPLE') ; 
                                 SI (EGA &BNUA1 1) ; 
                                         NUA1 = EXTR TRA1 'MINI' NOMFLO1 ; 
                                 SINON ; 
                                         NUA1 = EXTR TRA1 'SUPE' NOMFLO1 (T1 + 1.E-10) ; 
                                 FINSI ; 
                                 T1 =  EXTR NUA1 NOMFLO1 ; 
                                 EV1 = EXTR NUA1 NOMEVO1 ; 
                                 PSIG1 = EXTR EV1 ORDO ; PEPS1 = EXTR EV1 'ABSC' ; 
                                 VYOU1 = (EXTR 2 PSIG1) / (EXTR 2 PEPS1) ; 
                                 PEPS2 = PROG ; 
                                 REPE BSIG1 ((DIME PSIG1) - 1) ; 
                                         VA1 = (EXTR (&BSIG1 + 1) PEPS1) - 
                                         ((EXTR (&BSIG1 + 1) PSIG1) / VYOU1) ; 
                                         PEPS2 = PEPS2 ET (PROG VA1) ; 
                                 FIN BSIG1 ; 
                                 EV1 = EVOL 'MANU' 'EPSE' PEPS2 SIGM ('ENLE' PSIG1 1) ; 
                                 SI (&BNUA1 EGA 1) ; 
                                         TRA2 = 'NUAG' 'COMP' NOMFLO1 T1 'COMP' NOMEVO1 EV1 ; 
                                 SINON ; 
                                         TRA2 = TRA2 ET ('NUAG' 'COMP' NOMFLO1 
                                         T1 'COMP' NOMEVO1 EV1) ; 
                                 FINSI ; 
                         FIN BNUA1 ; 
                         TABTRA.&BCMOD1 = TRA2 ; 
 *                       ON ENLEVE LA COURBE DE TRACTION SI ELLE DEPEND DE 
 *                       LA TEMPERATURE (OPERATION TROP COUTEUSE POUR VARI) 
                         MAT0 = MATEI ; LCOMP1 = EXTR MAT0 'COMP' ; 
                         REPE BCOM1 (DIME LCOMP1) ; 
                                 C1 = EXTR LCOMP1 &BCOM1 ; 
                                 SI (NEG C1 'ECRO') ; 
                                         SI (EGA &BCOM1 1) ; 
                                                 MATEI = 'MATE' MODEI C1 (EXCO C1 MAT0) ; 
                                         SINON ; 
                                                 MATEI = MATEI ET ('MATE' MODEI C1 (EXCO C1 MAT0)) ; 
                                         FINSI ; 
                                 FINSI ; 
                         FIN BCOM1 ; 
                 FINSI ; 
 *       SIGY (et pas TRAC) 
         SINON ; 
                 SI (EXIS MATEI 'SIGY') ; 
                         SI1 = EXCO MATEI 'SIGY' ; 
                         TYPSI = TYPE (EXTR SI1 'SIGY' 1 1 1) ; 
                         SI (EXIS MATEI 'H') ; 
                                 H1 = EXCO MATEI 'H' ; 
                                 TYPH = TYPE (EXTR H1 'H' 1 1 1) ; 
                                 SI ((EGA TYPH 'EVOLUTIO') OU 
                                         (EGA TYPSI 'EVOLUTIO')) ; 
                                         MODPLA.&BCMOD1 = 2 ; 
                                 FINSI ; 
                         SINON ; 
                                 SI (EGA TYPSI 'EVOLUTIO') ; 
                                         MODPLA.&BCMOD1 = 3 ; 
                                 FINSI ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
 FIN BCMOD1 ; 
 BOOL.'GRADPROP' = BOOL.'GRADYOUN' OU BOOL.'GRADNU' OU BOOL.'GRADALPH'  OU ((DIME MODPLA) '>' 0) ; 
   
   
 * CAS IMPOSSIBLE A TRAITER 
 * ************************ 
   
 SI (EXIS SUPTAB 'MODELES_COMPOSITES') ; 
         SI (BOOL.'DECOUPLAGE' ET (BOOL.'DANS' ET (NON BOOL.'PARAL'))) ; 
                 MESS 'ERREUR : ON NE PEUT ENCORE DECOUPLER LES MODES' ; 
                 MESS '         DANS LE CAS DES MATERIAUX COMPOSITES' ; 
                 MESS '         SI LA FISSURE N APPARTIENT PAS A L INTERFACE' ; 
                 ERRE 21 ; QUIT G_THETA ; 
         FINSI ; 
 FINSI ; 
   
   
 * ============================================================================= 
   
 * PREREQUIS POUR EFFECTUER LES CALCULS 
 * ------------------------------------ 
   
 * TITRES A AFFICHER SELON LE PROBLEME TRAITER 
 * ******************************************* 
   
 SI BOOL.'PASAPAS' ; 
         TXMECANI= MOT '  Mecanique' ; 
         TXTERMI = MOT '    Thermique' ; 
         TXPRESS = MOT '    Volumique' ; 
 SINON ; 
         TXMECANI= MOT ' Mecanique' ; 
         TXTERMI = MOT '    Thermique' ; 
         TXPRESS = MOT '    Volumique' ; 
 FINSI ; 
 MC1 = MOT ' EN VISCO-THERMO-PLASTIQUE' ; 
 MC2 = MOT ' EN VISCO-PLASTICITE' ; 
 MC3 = MOT ' EN THERMO-PLASTICITE' ; 
 MC4 = MOT ' EN ELASTO-PLASTICITE' ; 
 SI (EXIS SUPTAB 'COUCHE') ; 
         MC10 = CHAI ' (Theta ' SUPTAB.'COUCHE' ')' ; 
 SINON ; 
         MC10 = CHAI ' (Theta utilisateur)' ; 
 FINSI ; 
 SI BOOL.'J' ; 
         CHA1 = CHAI 'INTEGRALE J EN FONCTION DU TEMPS' ; 
         MOTTI = MOT 'J' ; 
         MOTCO = MOT '         J' ; 
         SI BOOL.'THER' ; 
                 TX1 = CHAI '        INTEGRALE J' MC3 ; 
         SINON ; 
                 TX1 = CHAI '        INTEGRALE J' MC4 ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'C*' ; 
         CHA1 = CHAI 'INTEGRALE C* EN FONCTION DU TEMPS' ; 
         MOTTI = MOT 'C*' ; 
         MOTCO = MOT '        C*' ; 
         SI BOOL.'THER' ; 
                 TX1 = CHAI '       INTEGRALE C*' MC1 ; 
         SINON ; 
                 TX1 = CHAI '        INTEGRALE C*' MC2 ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'C*H' ; 
         CHA1 = CHAI 'INTEGRALE C*H EN FONCTION DU TEMPS' ; 
         MOTTI = MOT 'C*H' ; 
         MOTCO = MOT '       C*(H)' ; 
         SI BOOL.'THER' ; 
                 TX1 = CHAI '          INTEGRALE C*H' MC1 ; 
         SINON ; 
                 TX1 = CHAI '       INTEGRALE C*H' MC2 ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'DJ/DA' ; 
         SI (EXIS SUPTAB 'FISSURE_2') ; 
                 CHA1 = CHAI 'INTEGRALE CROISEE DJi/DAj EN FONCTION DU TEMPS' ; 
                 MOTTI = MOT 'DJi/DAj' ; 
                 MOTCO = MOT '      dJi/dAj' ; 
                 SI BOOL.'THER' ; 
                         TX1 = CHAI '      INTEGRALE CROISEE DJi/DAj' MC3 ; 
                 SINON ; 
                         TX1 = CHAI '  INTEGRALE CROISEE DJi/DAj' MC4 ; 
                 FINSI ; 
         SINON ; 
                 CHA1 = CHAI 'INTEGRALE DJ/DA EN FONCTION DU TEMPS' ; 
                 MOTTI = MOT 'DJ/DA' ; 
                 MOTCO = MOT '       dJ/dA' ; 
                 SI BOOL.'THER' ; 
                         TX1 = CHAI '      INTEGRALE DJ/DA' MC3 ; 
                 SINON ; 
                         TX1 = CHAI '      INTEGRALE DJ/DA' MC4 ; 
                 FINSI ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'J_DYNA' ; 
         CHA1 = CHAI 'INTEGRALE J DYNAMIQUE EN FONCTION DU TEMPS' ; 
         MOTTI = MOT 'J_DYNA' ; 
         MOTCO = MOT '      J_DYNA' ; 
         SI BOOL.'THER' ; 
                 TX1 = CHAI '     INTEGRALE J EN THERMO-ELASTO-DYNAMIQUE' ; 
         SINON ; 
                 TX1 = CHAI '         INTEGRALE J EN ELASTO-DYNAMIQUE' ; 
         FINSI ; 
 FINSI ; 
 SI BOOL.'DECOUPLAGE' ; 
         CHA1=CHAI 'F.I.C. Ki EN FONCTION DU TEMPS' ; 
         MOTTI = MOT 'Ki' ; 
         MOTCO = MOT '         K' ; 
         SI BOOL.'THER' ; 
                 TX1 = CHAI ' SEPARATION DES F.I.C.' MC3 ; 
         SINON ; 
                 TX1 = CHAI ' SEPARATION DES F.I.C.' MC4 ; 
         FINSI ; 
 FINSI ; 
 TX2 = CHAI ' Contribution due au chargement' MC10 ; 
 TX3 = CHAI ' ________________________________________' ; 
 SI (EXIS SUPTAB 'COUCHE') ; 
         SI (SUPTAB.'COUCHE' > 9) ; 
                 TX3 = CHAI ' _________________________________________' ; 
         FINSI ; 
         SI (SUPTAB.'COUCHE' > 99) ; 
                 TX3 = CHAI ' __________________________________________' ; 
         FINSI ; 
 SINON ; 
         TX3 = CHAI ' _____________________________________________' ; 
 FINSI ; 
   
 * AFFICHAGE DU TITRE 
 * ****************** 
   
 SI BOOL.'PASAPAS' ; 
         SI (EGA GDIME 2) ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         MESS '          ' TX1 ; 
                         MESS '           ' TX2 ; MESS '           ' TX3 ; 
                         MESS 'Mode  No.Pas ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 SINON ; 
                         MESS '       ' TX1 ; 
                         MESS '          ' TX2 ; MESS '          ' TX3 ; 
                         MESS ' No.Pas ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 FINSI ; 
         FINSI ; 
         SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         MESS '              ' TX1 ; 
                         MESS '               ' TX2 ; MESS '               ' TX3 ; 
                         MESS 'Mode  Noeud  No.Pas ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 SINON ; 
                         MESS '           ' TX1 ; 
                         MESS '              ' TX2 ; MESS '              ' TX3 ; 
                         MESS '  Noeud  No.Pas ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 FINSI ; 
         FINSI ; 
         SI BOOL.'COQ' ; 
                 MESS '           ' TX1 ; 
                 MESS ; 
                 MESS '              ' TX2 ; MESS '              ' TX3 ; 
                 MESS '  Plan   No.Pas ' TXMECANI TXTERMI TXPRESS MOTCO ; 
         FINSI ; 
 SINON ; 
         SI (EGA GDIME 2) ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         MESS '        ' TX2 ; MESS '        ' TX3 ; 
                         MESS 'Mode  ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 SINON ; 
                         MESS '    ' TX2 ; MESS '    ' TX3 ; 
                         MESS ' ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 FINSI ; 
         FINSI ; 
         SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         MESS '            ' TX2 ; MESS '            ' TX3 ; 
                         MESS ' Mode   Noeud  ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 SINON ; 
                         MESS '          ' TX2 ; MESS '          ' TX3 ; 
                         MESS '  Noeud  ' TXMECANI TXTERMI TXPRESS MOTCO ; 
                 FINSI ; 
         FINSI ; 
         SI BOOL.'COQ' ; 
                 MESS '          ' TX2 ; MESS '          ' TX3 ; 
                 MESS '  Plan   ' TXMECANI TXTERMI TXPRESS MOTCO ; 
         FINSI ; 
 FINSI ; 
   
 * FORCE, DEPLACEMENT ET GRADIENT NULS 
 * *********************************** 
   
 FOR000 = CHAN 'CHPO' MOD_MEC_R (ZERO MOD_MEC_R 'FORCES  ') ; 
 DEP000 = CHAN 'CHPO' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM') ; 
 SI (EGA GMODE 'PLANGENE') ; 
         FOR000 = MANU 'CHPO' (EXTR MOD_MEC_R 'MAIL') 2 'FX' 0. 
                                 'FY' 0. 'TITR' 'FORCES  ' 'NATURE' 'DIFFUS' ; 
         FOR000 = FOR000 ET (MANU 'CHPO' (VALE 'MODE' 'PLANGENE') 
                                 3 'FZ' 0. 'MX' 0. 'MY' 0. 
                                 'TITR' 'FORCES  ' 'NATURE' 'DIFFUS') ; 
         DEP000 = MANU 'CHPO' (EXTR MOD_MEC_R 'MAIL') 2 'UX' 0. 
                                 'UY' 0. 'TITR' 'DEPLACEM' 'NATURE' 'DIFFUS' ; 
         DEP000 = DEP000 ET (MANU 'CHPO' (VALE 'MODE' 'PLANGENE') 
                                 3 'UZ' 0. 'RX' 0. 'RY' 0. 
                                 'TITR' 'DEPLACEM' 'NATURE' 'DIFFUS') ; 
 FINSI ; 
 CMD001 = CHAN 'STRESSES' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM') ; 
 GRA000 = ZERO MOD_MEC_R 'GRADIENT' ; 
 VAR000 = ZERO MOD_MEC_R 'VARINTER' ; 
   
   
 * NOMBRE DE BOUCLE POUR LE CALCUL DES INTEGRALES 
 * ********************************************** 
   
 SI BOOL.'PASAPAS' ; 
         NBG = -1 ; 
         NBDEP = DIME (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS') ; 
         SI BOOL.'REPRI' ; 
                 NBG = SUPTAB.'IABC' ; 
                 NBDEP = NBDEP - 1 - NBG ; 
         FINSI ; 
         SI BOOL.'PERSO1' ; 
                 NBG = (WTAB . 'PAS') - 1 ; 
                 NBDEP = 1 ; 
         FINSI ; 
 SINON ; 
         NBG = -1 ; 
         NBDEP = 1 ; 
 FINSI ; 
   
   
 * SOLUTION DU PAS PRECEDENT SI REPRISE DE CALCUL OU SI PERSO1 
 * *********************************************************** 
   
 SI (BOOL.'REPRI' OU (BOOL.'PERSO1' ET (NBG >EG 0))) ; 
         SIG1 = (SUPTAB.'SOLUTION_PASAPAS'.'CONTRAINTES'.NBG) REDU MOD_MEC_R ; 
         SI (EXIS (SUPTAB.'SOLUTION_PASAPAS') 'VARIABLES_INTERNES') ; 
                 VAR1 = (SUPTAB.'SOLUTION_PASAPAS'.'VARIABLES_INTERNES'.NBG) 
                                 REDU MOD_MEC_R ; 
         SINON ; 
                 VAR1 = VAR000 ; 
         FINSI ; 
         MAT_INST = SUPTAB.'MAT_INST' ; 
         WELAS = 0.5*('ENER' MOD_MEC_R SIG1 ('ELAS' MOD_MEC_R SIG1 MAT_INST)) ; 
         WPLAS = (REDU MOD_MEC_R SUPTAB.'END1') - WELAS ; 
         SI (EGA ITYPEF 2) ; 
                 VDI1 = SUPTAB.'VDI1' ; 
         FINSI ; 
         SI (((DIME MODPLA) > 0) ET BOOL.'THER') ; 
                 WVMIS = SUPTAB.'ENV1' ; 
         FINSI ; 
         SI BOOL.'MESS' ; 
                 MESS 'RECUP DU PAS PRECEDENT OK' ; 
         FINSI ; 
 FINSI ; 
   
 * CALCUL DE LA DEFORMATION THERMIQUE A TREF 
 SI (BOOL.'THER' ET (NON BOOL.'COQ')) ; 
         SI (EXIS MAT_MEC 'TREF') ; 
                 TREF = REDU (EXCO 'TREF' MAT_MEC 'T') ELTETA ; 
                 TREF = CHAN 'TYPE' TREF 'TEMPERATURES' ; 
         SINON ; 
                 TREF = MANU 'CHML' MOD_MEC_R 'T' 0. 'TYPE' 'TEMPERATURES' ; 
         FINSI ; 
         MATREF = VARI 'NUAG' MOD_MEC_R MAT_MEC TREF ; 
         EPTREF = EPTH MOD_MEC_R MATREF TREF ; 
         EPTREF VAR2 VAR3 = INVA MOD_MEC_R EPTREF ; 
         EPTREF = CHAN 'CHAM' (EPTREF/3.) MOD_MEC_R 'NOEUD' ; 
         OBJUTI.'EPTREF' = EPTREF ; 
 FINSI ; 
   
   
 * REMPLISSAGE DE OBJUTI 
 * ********************* 
   
 OBJUTI.'MOD_MEC_R' = MOD_MEC_R ; 
 OBJUTI.'MOTTI' = MOTTI ; 
 OBJUTI.'MODCOU' = MODCOU ; 
 OBJUTI.'TABMOD' = TABMOD ; 
 OBJUTI.'LINTER' = LINTER ; 
 OBJUTI.'ELTETA' = ELTETA ; 
 OBJUTI.'MODPLA' = MODPLA ; 
 OBJUTI.'FOR000' = FOR000 ; 
 OBJUTI.'DEP000' = DEP000 ; 
 OBJUTI.'CMD001' = CMD001 ; 
 OBJUTI.'GRA000' = GRA000 ; 
 OBJUTI.'ITYPEF' = ITYPEF ; 
 OBJUTI.'DIRECTION1' = DIR1 ; 
 OBJUTI.'DIRECTION2' = DIR2 ; 
 OBJUTI.'DIRECTION3' = DIR3 ; 
 OBJUTI.'ELTETA' = ELTETA ; 
 * DECOUPLAGE 
 OBJUTI.'MODSUP' = MODSUP ; 
 OBJUTI.'MODINF' = MODINF ; 
 * AJOUT BP BT POUR LE CONTACT FROTTANT 
 SI BOOL.'FROT' ; 
         OBJUTI.'OBJCON' = OBJCON ; 
         OBJUTI.'MAILCON' = MAILCON ; 
 FINSI ; 
 * FIN AJOUT BP BT 
 SI BOOL.'PERSO1' ; 
         OBJUTI.'ESTIMATION' = ESTIM ; 
 FINSI ; 
   
 *************************************************** 
 ** DECLARATION DES TABLES STOCKANT LES RESULTATS ** 
 *************************************************** 
 SI BOOL.'PERSO1' ; 
         FLCREA = NBG EGA -1 ; 
 SINON ; 
         FLCREA = NON BOOL.'REPRI' ; 
 FINSI ; 
 SI FLCREA ; 
         SI BOOL.'MESS' ; 
                 MESS 'ON VA CREER SUPTAB.RESULTATS' ; 
         FINSI ; 
         SI ((EGA GDIME 3) OU BOOL.'PASAPAS' OU BOOL.'DECOUPLAGE') ; 
                 SUPTAB.'RESULTATS' = TABL ; 
         FINSI ; 
         SI BOOL.'PASAPAS' ; 
                 SI ((EGA GDIME 3) OU BOOL.'DECOUPLAGE') ; 
                         SUPTAB.'EVOLUTION_RESULTATS' = TABL ; 
                 FINSI ; 
                 SI (EGA ITYPEF 99) ; 
                         SUPTAB.'CRIT_DECHA_GLOBAL1' = TABLE ; 
                         SUPTAB.'CRIT_DECHA_LOCAL1' = TABLE ; 
                         SUPTAB.'CRIT_DECHA_GLOBAL2' = TABLE ; 
                         SUPTAB.'CRIT_DECHA_GLOBAL2_L' = TABLE ; 
                         SUPTAB.'CRIT_DECHA_LOCAL2' = TABLE ; 
                 FINSI ; 
         FINSI ; 
         SI (BOOL.'COQ' ET (BOOL.'PASAPAS' OU BOOL.'DECOUPLAGE')) ; 
                 SUPTAB.'EPAISSEUR_RESULTATS' = TABL ; 
         FINSI ; 
         SI BOOL.'DECOUPLAGE' ; 
                 REPE IRUPT GDIME ; 
                         MODE_RUPT = (EXTR 'III' 1 &IRUPT) ; 
                         SI ((EGA GDIME 3) OU BOOL.'PASAPAS') ; 
                                 SUPTAB.'RESULTATS'.MODE_RUPT = TABL ; 
                         FINSI ; 
                         SI ((EGA GDIME 3) ET BOOL.'PASAPAS') ; 
                                 SUPTAB.'EVOLUTION_RESULTATS'.MODE_RUPT = TABL ; 
                         FINSI ; 
                         SI (BOOL.'COQ' ET BOOL.'PASAPAS') ; 
                                 SUPTAB.'EPAISSEUR_RESULTATS'.MODE_RUPT = TABL ; 
                         FINSI ; 
                 FIN IRUPT ; 
         FINSI ; 
 FINSI ; 
   
   
 *********************************************** 
 *********************************************** 
 ********* BOUCLE SUR LE PAS DE CALCUL ********* 
 *********************************************** 
 *********************************************** 
   
 REPE BOUCEXT NBDEP ; 
         IABC = NBG + &BOUCEXT ; 
   
 *       DECLARATION DES TABLES STOCKANT LES RESULTATS POUR LE PAS DE TEMPS IABC 
         SI (BOOL.'PASAPAS' ET (EGA GDIME 3)) ; 
                 SI  BOOL.'DECOUPLAGE' ; 
                         REPE IRUPT GDIME ; 
                                 SUPTAB.'RESULTATS'.(EXTR 'III' 1 &IRUPT).IABC = TABL ; 
                         FIN IRUPT ; 
                 SINON ; 
                         SUPTAB.'RESULTATS'.IABC = TABL ; 
                 FINSI ; 
         FINSI ; 
   
   
 *************************************************** 
 ** DEPLACEMENTS,CONTRAINTES ... A L INSTANT INST ** 
 *************************************************** 
   
         SI BOOL.'PASAPAS' ; 
 *               SOLUTION_PASAPAS 
                 SI BOOL.'PERSO1' ; 
 *                       CAS PERSO1 
                         INST   =  ESTIM . 'TEMPS' ; 
                         DEPINT = (ESTIM . 'DEPLACEMENTS') REDU ELTETA ; 
                         SIGF   = (ESTIM . 'CONTRAINTES' ) REDU MOD_MEC_R ; 
                         SI (BOOL.'GRANDS_DEP' ET (NON BOOL.'ROT_RIG')) ; 
                                 SIGF = 'CAPI' SIGF DEPINT MOD_MEC_R ; 
                         FINSI ; 
                         SI BOOL.'ROT_RIG' ; 
                                 SI (NON (EXIS (SUPTAB.'ROTATION_RIGIDIFIANTE') IABC)) ; 
                                         MESS 'ERREUR : Le deplacement du a une rotation' ; 
                                         MESS '         rigidifiante au pas ' IABC ' n est pas' 
                                         MESS '         donne' ; 
                                         ERRE 21 ; QUIT G_THETA ; 
                                 FINSI ; 
                                 DEPINT = DEPINT - 
                                 (REDU SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC ELTETA) ; 
                         FINSI ; 
                         SI (EXIS ESTIM 'VARIABLES_INTERNES') ; 
                                 VARF = (ESTIM . 'VARIABLES_INTERNES') REDU MOD_MEC_R ; 
                         SINON ; 
                                 VARF = VAR000 ; 
                         FINSI ; 
                         SI BOOL.'C*' ; 
                                 SI (EGA IABC 0) ; 
                                         DELTAT = INST + 1.E+30 ; 
                                         DEPINT = ESTIM . 'DEPLACEMENTS' ; 
                                         VITDFI = ESTIM . 'DEFORMATIONS_INELASTIQUES' ; 
                                         SIG1 = SIGF * 1. ; 
                                 FINSI ; 
                                 SI (IABC '>' 0) ; 
                                         DELTAT= INST - (ESTIM . 'TEMPS') ; 
                                         DEPINT= (ESTIM.'DEPLACEMENTS') - (ESTIM.'DEPLACEMENTS') ; 
                                         VITDFI= (ESTIM.'DEFORMATIONS_INELASTIQUES') 
                                                                 - (ESTIM.'DEFORMATIONS_INELASTIQUES') ; 
                                 FINSI ; 
                                 DEPINT = (REDU ELTETA DEPINT) / DELTAT ; 
                                 VITDFI = (REDU ELTETA VITDFI) / DELTAT ; 
                         FINSI ; 
                         SI BOOL.'J_DYNA' ; 
                                 VITF = (ESTIM .'VITESSES')      REDU ELTETA ; 
                                 ACCF = (ESTIM .'ACCELERATIONS') REDU ELTETA ; 
                         FINSI ; 
                 SINON ; 
 *                       CAS OU ON APPELLE G_THETA APRES PASAPAS 
                         INST = SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.IABC ; 
                         DEPINT = (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC) 
                         REDU ELTETA ; 
                         SIGF = (SUPTAB.'SOLUTION_PASAPAS'.'CONTRAINTES'.IABC) 
                                         REDU MOD_MEC_R ; 
                         SI (BOOL.'GRANDS_DEP' ET (NON BOOL.'ROT_RIG')) ; 
                                 SIGF = 'CAPI' SIGF DEPINT MOD_MEC_R ; 
                         FINSI ; 
                         SI BOOL.'ROT_RIG' ; 
                                 SI (NON (EXIS (SUPTAB.'ROTATION_RIGIDIFIANTE') IABC)) ; 
                                         MESS 'ERREUR : Le deplacement du a une rotation' ; 
                                         MESS '         rigidifiante au pas ' IABC ' n est pas' 
                                         MESS '         donne' ; 
                                         ERRE 21 ; QUIT G_THETA ; 
                                 FINSI ; 
                                 DEPINT = DEPINT - 
                                 (REDU SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC ELTETA) ; 
                         FINSI ; 
                         SI (EXIS (SUPTAB.'SOLUTION_PASAPAS') 'VARIABLES_INTERNES') ; 
                                 VARF = (SUPTAB.'SOLUTION_PASAPAS'.'VARIABLES_INTERNES'.IABC) 
                                 REDU MOD_MEC_R ; 
                         SINON ; 
                                 VARF = VAR000 ; 
                         FINSI ; 
                         SI BOOL.'C*' ; 
                                 SI (EGA IABC 0) ; 
                                         DELTAT = INST + 1.E+30 ; 
                                         DEPINT = SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC ; 
                                         VITDFI = SUPTAB.'SOLUTION_PASAPAS'. 
                                         'DEFORMATIONS_INELASTIQUES'.IABC ; 
                                         SIG1 = SIGF * 1. ; 
                                 FINSI ; 
                                 SI (IABC > 0) ; 
                                         DELTAT = INST - (SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'. 
                                                                 (IABC - 1)) ; 
                                         DEPINT = (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.IABC) - 
                                         (SUPTAB.'SOLUTION_PASAPAS'.'DEPLACEMENTS'.(IABC - 1)) ; 
                                         VITDFI = (SUPTAB.'SOLUTION_PASAPAS'. 
                                                                 'DEFORMATIONS_INELASTIQUES'.IABC) - 
                                                                 (SUPTAB.'SOLUTION_PASAPAS'. 
                                                                 'DEFORMATIONS_INELASTIQUES'.(IABC - 1)) ; 
                                 FINSI ; 
                                 DEPINT = (REDU ELTETA DEPINT) / DELTAT ; 
                                 VITDFI = (REDU ELTETA VITDFI) / DELTAT ; 
                         FINSI ; 
                         SI BOOL.'J_DYNA' ; 
                                 VITF = (SUPTAB.'SOLUTION_PASAPAS'.'VITESSES'.IABC) 
                                 REDU ELTETA ; 
                                 ACCF = (SUPTAB.'SOLUTION_PASAPAS'.'ACCELERATIONS'.IABC) 
                                 REDU ELTETA ; 
                         FINSI ; 
                 FINSI ; 
         SINON ; 
 *               SOLUTION_RESO 
                 DEPINT = REDU (SUPTAB.'SOLUTION_RESO') ELTETA ; 
                 SIGF = SIGM 'LINE' DEPINT MOD_MEC_R MAT_MEC ; 
         FINSI ; 
   
 *       ON CHANGE LE DEPLACEMENT DEPINT EN MCHAML AU NOEUD 
         DEPINT = CHAN 'CHAM' DEPINT MOD_MEC_R 'NOEUD' 'DEPLACEMENTS' ; 
   
   
 **************************************************** 
 * MODIFICATION DES CHAMPS THETA ET PI SI GRANDE ROT 
 **************************************************** 
   
         SI (BOOL.'PASAPAS' ET BOOL.'ROT_RIG') ; 
                 FORM SUPTAB.'ROTATION_RIGIDIFIANTE'.IABC ; 
                 SUPTAB.'CHAMP_THETA' UTILTETA = CH_THETA SUPTAB ; 
                 SI BOOL.'DJ/DA' ; 
                         SI (NON (EXIS SUPTAB 'FRONT_FISSURE_2')) ; 
                                 SUPTAB.'COUCHE' = (SUPTAB.'COUCHE') - 1 ; 
                                 SUPTAB.'PI' UTILPI = CH_THETA SUPTAB ; 
                                 SUPTAB.'COUCHE' = (SUPTAB.'COUCHE') + 1 ; 
                         SINON ; 
                                 P1 = SUPTAB.'FRONT_FISSURE' ; 
                                 SUPTAB.'FRONT_FISSURE' = SUPTAB.'FRONT_FISSURE_2' ; 
                                 SUPTAB.'FISSURE' = SUPTAB.'FISSURE_2' ; 
                                 SUPTAB.'PI' UTILPI = CH_THETA SUPTAB ; 
                                 SUPTAB.'FRONT_FISSURE' = P1 ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
   
   
 *************************************************** 
 ********** TEMPERATURES A L INSTANT INST ********** 
 *************************************************** 
   
         SI BOOL.'THER' ; 
                 SI BOOL.'PASAPAS' ; 
                         SI BOOL.'THER_DECO' ; 
                                 TEPINT = 'TIRE' CHAR1 INST 'T' ; 
                         SINON ; 
 *                               bp, 2014-11-13 : ajout distinction cas BOOL.'THER' et BOOL.'THER_DECO' 
                                 TEPINT = REDU ELTETA SUPTAB.'SOLUTION_PASAPAS'.'TEMPERATURES'. 
                                                         IABC ; 
                         FINSI ; 
                 SINON ; 
                         TEPINT = SUPTAB.'TEMPERATURES' ; 
                 FINSI ; 
         FINSI ; 
   
   
 *************************************************** 
 ********** DEF IMPOSEE A L INSTANT INST ********** 
 *************************************************** 
   
         SI BOOL.'DEF_IMP' ; 
                 SI BOOL.'PASAPAS' ; 
                         DEFI = 'TIRE' CHAR1 INST 'DEFI' ; 
                 SINON ; 
                         DEFI = SUPTAB.'DEFORMATIONS_IMPOSEES' ; 
                 FINSI ; 
         FINSI ; 
   
   
 *************************************************** 
 ********** CONTACT FROTTANT ********** 
 *************************************************** 
   
         SI BOOL.'FROT' ; 
                 SI BOOL.'PASAPAS' ; 
 *                       ...TODO 
                 SINON ; 
 *                       A PRIORI DEPLACEMENT_FISSURE PAS TRES UTILE ... 
                         SI (EXIS SUPTAB 'DEPLACEMENT_FISSURE') ; 
                                 WDEP  = SUPTAB . 'DEPLACEMENT_FISSURE' ; 
                         SINON ; 
                                 WDEP  = REDU (SUPTAB.'SOLUTION_RESO') MAICON ; 
                         FINSI ; 
                         TOTO = EXTR WDEP 'MAIL' ; 
                         SI (EGA (NBEL TOTO) 0) ; 
                                 MESS 'ERREUR : IL FAUT DEPLACEMENT_FISSURE SI MODELE_FISSURE' ; 
                                 ERRE 21 ; QUIT G_THETA ; 
                         FINSI ; 
                         SI (EXIS SUPTAB 'PRESSION_FISSURE') ; 
                                 SIGCON = SUPTAB . 'PRESSION_FISSURE' ; 
                         SINON ; 
                                 SIGCON = REDU SIGF OBJCON ; 
                         FINSI ; 
 *                       PEUT ETRE FAIRE UN TEST SUR SIGCON ... 
                 FINSI ; 
         FINSI ; 
   
   
 ***************************************************** 
 * CONTRAINTE RECALCULEE SI BOOL.'THER' = VRAI et NON BOOL.'PASAPAS' * 
 ***************************************************** 
   
         SI (BOOL.'THER' ET (NON BOOL.'PASAPAS')) ; 
                 SIGF = SIGF - (THET MOD_MEC_R MAT_MEC TEPINT) ; 
         FINSI ; 
   
   
 *************************************************** 
 ************ MATERIAU A L INSTANT INST ************ 
 *************************************************** 
   
         SI (BOOL.'GRADPROP' ET BOOL.'THER' ET BOOL.'PASAPAS') ; 
                 MAT_INST = VARI 'NUAG' MOD_MEC_R MAT_MEC (EXCO 'T' TEPINT 'T') ; 
         SINON ; 
                 MAT_INST = MAT_MEC ; 
 *               bp: ne devrait on pas ecrire ci dessous..? inutile? 
 *               MAT_INST = REDU MOD_MEC_R MAT_MEC 
         FINSI ; 
         OBJUTI.'MAT_INST' = MAT_INST ; 
   
   
 *************************************************** 
 ********* RIGIDITE TOTALE A L INSTANT INST ******** 
 *************************************************** 
   
 *       bp: utilite? 
         SI ( BOOL.'DJ/DA' OU (BOOL.'DECOUPLAGE' 
         ET (NON BOOL.'XFEM') ET (EGA GDIME 3) ET (NON BOOL.'DANS')) ) ; 
                 SI BOOL.'PASAPAS' ; 
                         SI (BOOL.'GRADPROP' ET BOOL.'THER') ; 
                                 M1 = VARI 'NUAG' MOD_MEC_R (EXCO 'T' TEPINT 'T') 
                                 (SUPTAB.'SOLUTION_PASAPAS'.'CARACTERISTIQUES') ; 
                         SINON ; 
                                 M1 = SUPTAB.'SOLUTION_PASAPAS'.'CARACTERISTIQUES' ; 
                         FINSI ; 
                         RIGTOT = RIGI M1 (SUPTAB.'SOLUTION_PASAPAS'.'MODELE') ; 
                 SINON ; 
                         RIGTOT = RIGI (SUPTAB.'CARACTERISTIQUES') (SUPTAB.'MODELE') ; 
                 FINSI ; 
         FINSI ; 
         OBJUTI.'RIGTOT' = RIGTOT ; 
   
   
 ******************************************************************** 
 ****** CHARGEMENT MECANIQUE (FORCES NODALES) A L INSTANT INST ****** 
 ******************************************************************** 
   
         PREINT = FOR000 ; 
         SI BOOL.'PASAPAS' ; 
 *** SOLUTION_PASAPAS ****************************** 
                 SI (EXIS CHAR1 'MECA') ; 
                         PREINT = PREINT + ((TIRE CHAR1 INST 'MECA') REDU ELTETA) ; 
                 FINSI ; 
                 SI BOOL.'MODE_PRES' ; 
 *                       Dans le cas ou il y a un modele de pression 
                         MATPRE = TIRE CHAR1 'PRES' INST ; 
 *                       --> on isole la partie du MMODEL de pression qui est appliquee 
 *                       sur la fissure 
                         SI BOOL.'PRES_FISS' ; 
                                 MODPF = REDU MODPRE MAILPF ; 
                                 MATPF = REDU MATPRE MODPF ; 
                         FINSI ; 
 *                       --> on calcule les forces nodales equivalentes aux pressions 
 *                       appliquees hors de la fissure 
                         MAILPEXT = DIFF MAILPTOT MAILPF ; 
                         SI ((NBEL MAILPEXT) > 0) ; 
                                 MODPEXT = REDU MODPRE MAILPEXT ; 
                                 MATPEXT = REDU MATPRE MODPEXT ; 
                                 PREINT = PREINT + (BSIG MODPEXT MATPEXT) ; 
                         FINSI ; 
                 FINSI ; 
         SINON ; 
 *** SOLUTION_RESO ********************************** 
                 SI (EXIS SUPTAB 'CHARGEMENTS_MECANIQUES') ; 
                         PREINT = PREINT + (SUPTAB.'CHARGEMENTS_MECANIQUES' REDU ELTETA) ; 
                 FINSI ; 
                 SI BOOL.'MODE_PRES' ; 
 *                       Dans le cas ou il y a un modele de pression 
 *                       --> on isole la partie du MMODEL de pression qui est appliquee sur 
 *                       la fissure 
                         SI BOOL.'PRES_FISS' ; 
                                 MODPF = REDU MODPRE MAILPF ; 
                                 MATPF = REDU MATPRE MODPF ; 
                         FINSI ; 
 *                       --> on calcule les forces nodales equivalentes aux pressions 
 *                       appliquees hors de la fissure 
                         MAILPEXT = DIFF MAILPTOT MAILPF ; 
                         SI ((NBEL MAILPEXT) > 0) ; 
                                 MODPEXT = REDU MODPRE MAILPEXT ; 
                                 MATPEXT = REDU MATPRE MODPEXT ; 
                                 PREINT = PREINT + (BSIG MODPEXT MATPEXT) ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
   
   
 ********************************************************************** 
 ******** POUR LES PRESSIONS APPLIQUEES SUR LA FISSURE 
 *        on calcule le MCHAML vectoriel de [pression * normale] 
 ********************************************************************** 
   
         SI BOOL.'PRES_FISS' ; 
 *               champ de normale unitaire au maillage de la fissure 
                 MAT_INSTF = PRES MODPF 'PRES' 1. ; 
                 NF1   = BSIG MODPF MAT_INSTF ; 
                 LCOMP = EXTR NF1 'COMP' ; 
                 NF2   =  CHAN 'CHAM' NF1 MODPF 'STRESSES' ; 
                 XX    = PSCA NF2 NF2 LCOMP LCOMP ; 
                 NF    = NF2 / (XX**0.5) ; 
 *               champ de pression normale au maillage de la fissure 
                 PF    = CHAN 'STRESSES' MODPF MATPF ; 
                 PF    = CHAN 'TYPE' PF 'FORCES' ; 
                 NCOMP = DIME LCOMP ; 
                 LCP   = MOTS NCOMP*'PRES' ; 
                 PNF   = PF * NF LCP LCOMP LCOMP ; 
         FINSI ; 
   
   
 **************************************************** 
 ***** APPEL A G_AUX POUR LES CHAMPS AUXILIAIRES **** 
 **************************************************** 
   
 *       TEST DE G_AUX 
         SI BOOL.'DECOUPLAGE' ; 
                 CH_AUX = G_AUX SUPTAB OBJUTI BOOL ; 
                 SI (EGA (TYPE CH_AUX) (MOT 'ANNULE')) ; 
                         MESS 'ERREUR : G_AUX A RENCONTRE UN PROBLEME' ; 
                         QUIT G_THETA ; 
                 FINSI ; 
         FINSI ; 
   
 *       BOUCLE SUR LES INTEGRALES A CALCULER ==============================* 
 *       NBMIXT = nbre d integrale a calculer (=1 si J, =2 si K1 K2, =3 
 *       si K1 K2 K3) 
         NBMIXT = 1 ; 
         IM = 0 ; 
         SI BOOL.'DECOUPLAGE' ; 
                 NBMIXT = 2 ; 
                 SI (EGA GDIME 3) ; 
                         NBMIXT = 3 ; 
                 FINSI ; 
         FINSI ; 
         REPE BOUCMIX NBMIXT ; 
                 IM = IM + 1 ; 
   
 **************************************************** 
 **************** EN CAS DE DECOUPLAGE ************** 
 **************************************************** 
   
                 SI BOOL.'DECOUPLAGE' ; 
                         MOTMIX = CH_AUX.IM.'MOTMIX' ; 
                         MOTMIA = CH_AUX.IM.'MOTMIA' ; 
                         A_PREI = CH_AUX.IM.'A_PREI' ; 
                         A_DEPI = CH_AUX.IM.'A_DEPI' ; 
                         A_SIGF = CH_AUX.IM.'A_SIGF' ; 
                         A_DEPGR = CH_AUX.IM.'A_DEPGR' ; 
                         C_MATE = OBJUTI.'C_MATE' ; 
                 FINSI ; 
   
   
 **************************************************** 
 ******* EN CAS DE CALCUL EN VISCO_PLASTICITE ******* 
 **************************************************** 
   
 *               INITIALISATION DE FACT1 
                 FACT1 = 1. ; 
                 SI (BOOL.'C*' OU BOOL.'C*H') ; 
                         SI (EGA ITYPEF 1) ; 
                                 CHAF1 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF1 ' MAT_INST 'SCAL')) 
                                 CHAN 'TYPE' 'SCALAIRE' ; 
                                 CHAF2 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF2 ' MAT_INST 'SCAL')) 
                                 CHAN 'TYPE' 'SCALAIRE' ; 
                                 CHAF3 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF3 ' MAT_INST 'SCAL')) 
                                 CHAN 'TYPE' 'SCALAIRE' ; 
                                 SI (EXIS MAT_INST 'AF0 ') ; 
                                         CHAF4 =( CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF4 ' MAT_INST 'SCAL')) 
                                         CHAN 'TYPE' 'SCALAIRE' ; 
                                         CHAF5 =( CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF5 ' MAT_INST 'SCAL')) 
                                         CHAN 'TYPE' 'SCALAIRE' ; 
                                         CHAF6 = (CHAN 'STRESSES' MOD_MEC_R (EXCO 'AF6 ' MAT_INST 'SCAL')) 
                                         CHAN 'TYPE' 'SCALAIRE' ; 
                                 FINSI ; 
                         FINSI ; 
                         SI BOOL.'C*' ; 
                                 SI (EGA ITYPEF 1) ; 
 *                                       DENSITE D'ENERGIE POUR LES FLUAGES DONT ON A UNE 
 *                                       EXPRESSION EXPLICITE DE L'INTEGRATION SUR LE TEMPS 
                                         SI (EXIS MAT_INST 'AF0 ') ; 
                                                 COE1 = ((MINI (CHAF2 + 1.)) + (MAXI (CHAF2 + 1.)))/2. ; 
                                                 COE2 = ((MINI (CHAF4 + 1.)) + (MAXI (CHAF4 + 1.)))/2. ; 
                                                 COE3 = ((MINI (CHAF6 + 1.)) + (MAXI (CHAF6 + 1.)))/2. ; 
                                                 VMI1 = (EXCO ('VMIS' MOD_MEC_R SIGF MAT_INST) 'SCAL') 
                                                 CHAN 'TYPE' 'SCALAIRE'         ; 
                                                 ENERM1 = (CHAF2*((CHAF2 + 1.)**(-1.)))*CHAF1*(VMI1**COE1) ; 
                                                 ENERM2 = (CHAF4*((CHAF4 + 1.)**(-1.)))*CHAF3*(VMI1**COE2) ; 
                                                 ENERM3 = (CHAF6*((CHAF6 + 1.)**(-1.)))*CHAF5*(VMI1**COE3) ; 
                                                 ENERM = ENERM1 + ENERM2 + ENERM3 ; 
                                         SINON ; 
                                                 COE1 = ((MINI (CHAF2 + 1.)) + (MAXI (CHAF2 + 1.)))/2. ; 
                                                 COE2 = ((MINI CHAF3) + (MAXI CHAF3))/2. ; 
                                                 VMI1 = (EXCO ('VMIS' MOD_MEC_R SIGF MAT_INST) 'SCAL') 
                                                 CHAN 'TYPE' 'SCALAIRE'     ; 
                                                 SI ((EGA INST 0. 1.E-10) ET ('<'(COE2 - 1) 0.)) ; 
                                                         V1 = 0. ; 
                                                 SINON ; 
                                                         V1 = INST**(COE2 - 1) ; 
                                                 FINSI ; 
                                                 ENERM = (CHAF2*((CHAF2 + 1.)**(-1.)))* 
                                                                         CHAF1*(VMI1**COE1)*CHAF3*V1 ; 
                                         FINSI ; 
                                         SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; ENERM = ENERM*MOD_MEC_R EPAICH ; FINSI ; 
                                 FINSI ; 
                                 SI (EGA ITYPEF 2) ; 
 *                                       ON N'A PAS UNE EXPRESSION EXPLICITE DE 
 *                                       L'INTEGRATION DU FLUAGE SUR LE TEMPS 
                                         SIGMOY = 0.5*(SIG1 + SIGF) ; 
                                         SI ((EGA IABC 0) ET (NON BOOL.'REPRI')) ; 
                                                 ENERM = 'ENER' MOD_MEC_R VITDFI SIGMOY ; 
                                         SINON ; 
                                                 ENERM = ENERM + ('ENER' MOD_MEC_R (VITDFI - VDI1) SIGMOY) ; 
                                         FINSI ; 
                                         SIG11 = SIG1 ; SIG1 = SIGF ; VDI1 = VITDFI ; 
                                 FINSI ; 
                         FINSI ; 
 *                       FACTEUR AFFECTE A J SI ON CALCULE C*(H) 
                         SI BOOL.'C*H' ; 
                                 CHAR2 = EXTR CHAR1 'MECA' ; 
                                 COE1 = ((MINI CHAF1) + (MAXI CHAF1)) / 2. ; 
                                 COE2 = ((MINI CHAF2) + (MAXI CHAF2)) / 2. ; 
                                 COE3 = ((MINI CHAF3) + (MAXI CHAF3)) / 2. ; 
                                 N1 = COE2 / COE3 ; 
                                 SI (EGA INST 0. 1.E-10) ; INST = 1.E-10 ; FINSI ; 
                                 P1 = PROG 0. 'PAS' (INST / 100.) INST ; 
                                 P2 = PROG ; 
                                 REPE BF1 (DIME P1) ; 
                                         T1 = EXTR P1 &BF1 ; 
                                         V1 = 0. ; 
                                         REPE BF2 (DIME CHAR2) ; 
                                                 E1 = EXTR CHAR2 'EVOL' &BF2 ; 
                                                 V1 = V1 + ('IPOL' T1 (EXTR E1 'ABSC') (EXTR E1 ORDO)) ; 
                                         FIN BF2 ; 
                                         P2 = P2 ET (PROG V1) ; 
                                 FIN BF1 ; 
                                 E1 = EVOL 'MANU' 'TEMPS' P1 'FORCE' (P2 ** N1) ; 
                                 FACT1 = EXTR (INTG E1) 1 ; 
                                 SI (EGA FACT1 0. 1.E-10) ; FACT1 = 1.E+30 ; FINSI ; 
                                 FACT1 = ((V1 ** N1) / FACT1) ** COE3 ; 
                         FINSI ; 
                 FINSI ; 
   
 ******************************************************** 
 * SI LA COURBE DE TRACTION DEPEND DE LA TEMPERATURE ON * 
 * CALCULE LA VARIATION DE CONTRAINTES DE VON-MISES LORS* 
 * D'UNE AUGMENTATION (DETATE) DE LA TEMPERATURE A INST * 
 ******************************************************** 
 *bp 11/08/2011 : on calcule plutot la variation de la limite d elasticite 
 *                ce qui est moins faux si presence de decharge... 
 *            => on construit VM1 comm VM2 ! 
                 SI (((DIME MODPLA) '>' 0) ET BOOL.'THER') ; 
                         DETATE = 1. ; 
                         TEP1 = TEPINT + (MANU 'CHPO' ELTETA 1 'T' DETATE) ; 
                         EPS1 = (EXCO VARF 'EPSE') CHAN 'TYPE' 'SCALAIRE' ; 
                         MSQ1 = 'MASQ' 'SUPERIEUR' EPS1 1.E-10 ; 
                         EPS1 = MSQ1 * EPS1 ; 
 *rem : on pourrait utiliser BORN dans le futur 
 *     VMI1 = (CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) 
 *                     'TYPE' 'SCALAIRE')*MSQ1 ; 
 *     DETAVM = VMI1 * 0. ; 
                         DETAVM = 0. ; 
                         REPETER BCMOD2 NBOBJ ; 
                                 MODI = TABMOD.&BCMOD2 ; 
 *       VM1 = REDU VMI1 MODI ; 
                                 EPS2 = redu EPS1 MODI ; 
                                 SI (EXIS MODPLA &BCMOD2) ; 
                                         SI (EGA MODPLA.&BCMOD2 1) ; 
                                                 MA1 = VARI 'NUAG' MODI (MATE MODI 
                                                                 'ECRO' TABTRA.&BCMOD2) TEPINT ; 
                                                 VM1 = VARI 'NUAG' MODI (EXCO 'ECRO' MA1 'SIGM') 
                                                 EPS2 'STRESSES' 'SCALAIRE' ; 
                                                 VM1 = (EXCO VM1 'SIGM' 'SCAL') CHAN 'TYPE' 'SCALAIRE' ; 
                                                 MA2 = 'VARI' 'NUAG' MODI (MATE MODI 
                                                                 'ECRO' TABTRA.&BCMOD2) TEP1 ; 
 *            VM2 = 'VARI' 'NUAG' MODI (EXCO 'ECRO' MA2 SIGM) 
 *                  (REDU EPS1 MODI) 'STRESSES' 'SCALAIRE' ; 
 *            VM2 = ((EXCO VM2 SIGM 'SCAL')CHAN 'TYPE' 'SCALAIRE') 
 *                         * (REDU MSQ1 MODI) ; 
                                                 VM2 = VARI 'NUAG' MODI (EXCO 'ECRO' MA2 'SIGM') 
                                                                 EPS2 'STRESSES' 'SCALAIRE' ; 
                                                 VM2 = (EXCO VM2 SIGM 'SCAL') CHAN 'TYPE' 'SCALAIRE' ; 
                                         FINSI ; 
                                         SI ((EGA MODPLA.&BCMOD2 2) OU 
                                                 (EGA MODPLA.&BCMOD2 3)) ; 
                                                 MA1 = VARI 'NUAG' MODI (REDU MAT_MEC MODI) TEPINT ; 
                                                 VM1 = CHAN 'STRESSES' MODI (EXCO MA1 'SIGY' 'SCAL') ; 
                                                 MA2 = VARI 'NUAG' MODI (REDU MAT_MEC MODI) TEP1 ; 
 *           EPS2 = REDU EPS1 MODI ; 
                                                 VM2 = CHAN 'STRESSES' MODI (EXCO MA2 'SIGY' 'SCAL') ; 
                                                 SI (EGA MODPLA.&BCMOD2 2) ; 
                                                         HSCAL1 = (EXCO MA1 'H' 'SCAL') CHAN 'TYPE' 'SCALAIRE' ; 
                                                         VM1 = VM1 + ((CHAN 'STRESSES' MODI HSCAL1)*EPS2) ; 
                                                         HSCAL2 = (EXCO MA2 'H' 'SCAL') CHAN 'TYPE' 'SCALAIRE' ; 
                                                         VM2 = VM2 + ((CHAN 'STRESSES' MODI HSCAL2)*EPS2) ; 
                                                 FINSI ; 
 *           VM2 = VM2 * (REDU MSQ1 MODI) ; 
                                         FINSI ; 
                                         SI (EGA (TYPE DETAVM) 'FLOTTANT') ; 
                                                 DETAVM = ((VM2 - VM1) / DETATE) ; 
                                         SINON ; 
                                                 DETAVM = DETAVM + ((VM2 - VM1) / DETATE) ; 
                                         FINSI ; 
                                 FINSI ; 
                         FIN BCMOD2 ; 
                 FINSI ; 
   
   
 ******************************************************* 
 **** ENERGIE DE DEFORMATION ELASTIQUE ET PLASTIQUE **** 
 ******************************************************* 
 *** 
 *** DENSITE D'ENERGIE EN ELASTO OU THERMO-ELASTO-PLASTICITE ET 
 *** DENSITE D'ENERGIE LIEE A LA VARIATION DE COURBE DE TRACTION 
 *** 
                 SI (NON BOOL.'C*') ; 
                         WELAS = 0.5*('ENER' MOD_MEC_R SIGF ('ELAS' MOD_MEC_R SIGF MAT_INST)) ; 
 *     SI (BOOL.'PASAPAS' ET (NON BOOL.'DECOUPLAGE')) ; 
                         SI (BOOL.'PASAPAS') ; 
                                 SI (EGA IABC 0) ; 
                                         VMI1 = CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) 'TYPE' 'SCALAIRE' ; 
                                         SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; VMI1 = VMI1*MOD_MEC_R EPAICH ; FINSI ; 
                                         WPLAS=0.5*VMI1*((EXCO VARF 'EPSE')CHAN 'TYPE' 'SCALAIRE') ; 
                                         SI (((DIME MODPLA) '>' 0) ET BOOL.'THER') ; 
                                                 WVMIS = 0.5*DETAVM*((EXCO VARF 'EPSE') 
                                                                         CHAN 'TYPE' 'SCALAIRE') ; 
                                         FINSI ; 
                                 SINON ; 
                                         VMI1 = CHAN (0.5*(('VMIS' MOD_MEC_R SIG1 MAT_INST) + 
                                                         ('VMIS' MOD_MEC_R SIGF MAT_INST))) 'TYPE' 'SCALAIRE' ; 
                                         SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; VMI1 = VMI1*MOD_MEC_R EPAICH ; FINSI ; 
                                         WPLAS = WPLAS + (VMI1*((EXCO (VARF - VAR1) 'EPSE') 
                                                                 CHAN 'TYPE' 'SCALAIRE')) ; 
                                         SI (((DIME MODPLA) '>' 0) ET BOOL.'THER') ; 
                                                 WVMIS = WVMIS + ((0.5*(DETAV1 + DETAVM))* 
                                                                         ((EXCO (VARF - VAR1) 'EPSE') 
                                                                         CHAN 'TYPE' 'SCALAIRE') ) ; 
                                         FINSI ; 
                                 FINSI ; 
                                 ENERM = WELAS + WPLAS ; 
                                 SIG11 = SIG1 ; SIG1 = SIGF*1. ; VAR11 = VAR1 ; VAR1 = VARF*1. ; 
                                 SI (((DIME MODPLA) '>' 0) ET BOOL.'THER') ; 
                                         DETAV1 = DETAVM ; 
                                 FINSI ; 
                         SINON ; 
                                 ENERM = WELAS ; 
                         FINSI ; 
                 FINSI ; 
   
   
   
 *************************************************** 
 *********** APPEL A LA PROCEDURE G_CALCUL ********* 
 *************************************************** 
   
 *               REMPLISSAGE DE OBJUTI 
                 OBJUTI.'&BOUCMIX' = &BOUCMIX ; 
                 OBJUTI.'IABC' = IABC ; 
                 OBJUTI.'&BOUCEXT' = &BOUCEXT ; 
                 OBJUTI.'INST' = INST ; 
                 OBJUTI.'C_MATE' = C_MATE ; 
                 OBJUTI.'FACT1' = FACT1 ; 
                 OBJUTI.'MAT_INST' = MAT_INST ; 
                 OBJUTI.'RIGTOT' = RIGTOT ; 
                 OBJUTI.'ENERM' = ENERM ; 
                 OBJUTI.'WVMIS' = WVMIS ; 
                 OBJUTI.'TEPINT' = TEPINT ; 
                 OBJUTI.'PREINT' = PREINT ; 
                 OBJUTI.'DEFI' = DEFI ; 
 *               PRESSION SUR LES LEVRES 
                 SI BOOL.'PRES_FISS' ; 
                         OBJUTI.'MODE_PRESSION_FISSURE'= MODPF ; 
                         OBJUTI.'PRESSION_FISSURE' = PNF ; 
                 FINSI ; 
                 OBJUTI.'DEPINT' = DEPINT ; 
                 OBJUTI.'SIGF' = SIGF ; 
                 OBJUTI.'SIG1' = SIG11 ; 
                 OBJUTI.'VARF' = VARF ; 
 *               DYNAMIQUE 
                 OBJUTI.'VITF' = VITF ; 
                 OBJUTI.'ACCF' = ACCF ; 
 *               DECOUPLAGE 
                 OBJUTI.'MOTMIX' = MOTMIX  ; 
                 OBJUTI.'MOTMIA' = MOTMIA ; 
                 OBJUTI.'A_PREI' = A_PREI ; 
                 OBJUTI.'A_DEPI' = A_DEPI ; 
                 OBJUTI.'A_SIGF' = A_SIGF ; 
                 OBJUTI.'A_DEPGR'= A_DEPGR ; 
 *               FROTTEMENT 
                 SI BOOL.'FROT' ; 
                         OBJUTI . 'WDEP'  = WDEP ; 
                         OBJUTI . 'SIGCON' = SIGCON ; 
                 FINSI ; 
   
 *               APPEL A G_CALCUL 
                 G_CALCUL SUPTAB OBJUTI BOOL ; 
   
         FIN BOUCMIX ; 
 * FIN DE BOUCLE SUR LES INTEGRALES A CALCULER ========================* 
   
   
 **************************************************** 
 ****** ON RECUPERE LA CONFIGURATION INITIALE ******* 
 **************************************************** 
   
         SI (BOOL.'PASAPAS' ET BOOL.'ROT_RIG') ; 
                 FORM CONFIG0 ; 
         FINSI ; 
   
   
 **************************************************** 
 ******* FIN DE BOUCLE SUR LES PAS DE CALCUL ******** 
 **************************************************** 
 FIN BOUCEXT ; 
   
   
 **************************************************** 
 ** STOCKAGE DES RESULTATS DANS L OBJET EVOLUTIONS ** 
 **************************************************** 
 * en plus de ce qui existe dans SUPTAB.'RESULTATS' 
 * et dans CHPO_RESULTATS (fait dans G_calcul) 
 SI (BOOL.'PASAPAS' ET (NON BOOL.'PERSO1')) ; 
         IND1 = INDE (SUPTAB.'RESULTATS') ; 
   
 *       Cas 2D ******************************************* 
         SI (EGA GDIME 2) ; 
                 TITR CHA1 ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         REPE BB1 (DIME IND1) ; 
                                 MOT1 = IND1.&BB1 ; PT = PROG ; PG = PROG ; 
                                 IND2 = INDE (SUPTAB.'RESULTATS'.MOT1) ; 
                                 REPE BB2 (DIME IND2) ; 
                                         P1 = &BB2 - 1 ; 
                                         PT = PT ET (PROG SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.P1) ; 
                                         PG = PG ET (PROG SUPTAB.'RESULTATS'.MOT1.P1) ; 
                                 FIN BB2 ; 
                                 E1 = EVOL 'MANU' 'TEMPS' PT MOTTI PG ; 
                                 SUPTAB.'EVOLUTION_RESULTATS'.MOT1 = E1 ; 
                         FIN BB1 ; 
                 SINON ; 
                         PT = PROG ; PG = PROG ; 
                         REPE BB1 (DIME IND1) ; 
                                 P1 = &BB1 - 1 ; 
                                 PT = PT ET (PROG SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.P1) ; 
                                 PG = PG ET (PROG SUPTAB.'RESULTATS'.P1) ; 
                         FIN BB1 ; 
                         E1 = EVOL 'MANU' 'TEMPS' PT MOTTI PG ; 
                         SUPTAB.'EVOLUTION_RESULTATS' = E1 ; 
                 FINSI ; 
         FINSI ; 
   
 * Cas 3D ******************************************* 
 * Rem BP : 
 * !!! Attention passer ici lorsque la fissure propage doit conduire 
 *     a des erreurs, puisque les points du front changent ...!!! 
 *     Il faudrait a terme supprimer cette mise en forme des resultats 
 *     ainsi que celle utilisant la table RESULTATS (cf g_calcul). 
 *     Seul CHPO_RESULTATS semblent perenne pour la porpagation. 
         SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
                 SI BOOL.'DECOUPLAGE' ; 
                         REPE BB1 (DIME IND1) ; 
                                 MOT1 = IND1.&BB1 ; 
                                 IND2 = INDE (SUPTAB.'RESULTATS'.MOT1) ; 
                                 IND3 = INDE (SUPTAB.'RESULTATS'.MOT1.(IND2.1)) ; 
                                 REPE BB2 (DIME IND3) ; 
                                         PM = IND3.&BB2 ; PT = PROG ; PG = PROG ; 
                                         SI (EGA &BB2 (DIME IND3)) ; 
                                                 CHA2 = CHAI ' (Global)' ; 
                                         SINON ; 
 *              CHA2 = CHAI ' (Pt ' ('NOEUD' PM) ')' ; 
                                                 CHA2 = CHAI ' (Pt ' (&BB2) ')' ; 
                                         FINSI ; 
                                         TITR (CHAI CHA1 CHA2) ; 
                                         REPE BB3 (DIME IND2) ; 
                                                 P1 = &BB3 - 1 ; 
                                                 PT = PT ET (PROG SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.P1) ; 
                                                 PG = PG ET (PROG SUPTAB.'RESULTATS'.MOT1.P1.PM) ; 
                                         FIN BB3 ; 
                                         E1 = EVOL 'MANU' 'TEMPS' PT MOTTI PG ; 
                                         SUPTAB.'EVOLUTION_RESULTATS'.MOT1.PM = E1 ; 
                                 FIN BB2 ; 
                         FIN BB1 ; 
                 SINON ; 
                         IND2 = INDE (SUPTAB.'RESULTATS'.(IND1.1)) ; 
                         REPE BB1 (DIME IND2) ; 
                                 PM = IND2.&BB1 ; PT = PROG ; PG = PROG ; 
                                 SI (EGA &BB1 (DIME IND2)) ; 
                                         CHA2 = CHAI ' (Global)' ; 
                                 SINON ; 
 *            CHA2 = CHAI ' (Pt ' ('NOEUD' PM) ')' ; 
                                         CHA2 = CHAI ' (Pt ' (&BB1) ')' ; 
                                 FINSI ; 
                                 TITR (CHAI CHA1 CHA2) ; 
                                 REPE BB2 (DIME IND1) ; 
                                         P1 = &BB2 - 1 ; 
                                         PT = PT ET (PROG SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.P1) ; 
                                         PG = PG ET (PROG SUPTAB.'RESULTATS'.P1.PM) ; 
                                 FIN BB2 ; 
                                 E1 = EVOL 'MANU' 'TEMPS' PT MOTTI PG ; 
                                 SUPTAB.'EVOLUTION_RESULTATS'.PM = E1 ; 
                         FIN BB1 ; 
                 FINSI ; 
         FINSI ; 
   
 * Cas coque ******************************************* 
         SI BOOL.'COQ' ; 
                 IND2 = INDE (SUPTAB.'RESULTATS'.(IND1.1)) ; 
                 REPE BB1 (DIME IND2) ; 
                         PM = MOT IND2.&BB1 ; PT = PROG ; PG = PROG ; 
 *        CHA2 = CHAI ' (' PM ')' ; 
                         CHA2 = CHAI ' (Pt ' (&BB1) ')' ; 
                         TITR (CHAI CHA1 CHA2) ; 
                         REPE BB2 (DIME IND1) ; 
                                 P1 = &BB2 - 1 ; 
                                 PT = PT ET (PROG SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.P1) ; 
                                 PG = PG ET (PROG SUPTAB.'RESULTATS'.P1.PM) ; 
                         FIN BB2 ; 
                         E1 = EVOL 'MANU' 'TEMPS' PT MOTTI PG ; 
                         SUPTAB.'EVOLUTION_RESULTATS'.PM = E1 ; 
                 FIN BB1 ; 
         FINSI ; 
   
 FINSI ; 
   
   
 ******************************************************** 
 **** STOCKAGE POUR UNE EVENTUELLE REPRISE DE CALCUL **** 
 ******************************************************** 
 SI BOOL.'PASAPAS' ; 
         SUPTAB.'OBJ1' = MOT SUPTAB.'OBJECTIF' ; 
         SUPTAB.'IABC' = IABC ; 
         SUPTAB.'MAT_INST' = MAT_INST ; 
         SUPTAB.'END1' = ENERM ; 
         SI (((DIME MODPLA) '>' 0) ET BOOL.'THER') ; 
                 SUPTAB.'ENV1' = WVMIS ; 
         FINSI ; 
         SI (EGA ITYPEF 2) ; 
                 SUPTAB.'VDI1' = VDI1 ; 
         FINSI ; 
 FINSI ; 
   
 ******************************************************** 
 ************ ENLEVEMENT DES OBJETS INUTILES ************ 
 ******************************************************** 
 SI (EXIS SUPTAB 'COUCHE') ; 
       SUPTAB.'COU1' = SUPTAB.'COUCHE' ; 
 FINSI ; 
   
 *bp: soyons coherent... CHAMP_THETA est deja renseigne 
 SUPTAB.'CHAMP_THET1' = SUPTAB.'CHAMP_THETA' ; 
 OTER SUPTAB 'CHAMP_THETA' ; 
 * UTILTETA sera pratique pour la propagation xfem 
 SUPTAB.'UTILTET1' = UTILTETA ; 
 * ELTETA sera pratique pour les tests de reprise 
 SUPTAB.'ELTET1' = ELTETA ; 
   
 FINPROC ; 
 * G_CAS     PROCEDUR  JB251061  20/12/21    21:15:06     10829 
 * ============================================================================= 
 *        PROCEDURE D'ANALYSE DE LA TABLE D'ENTREE FOURNIE A G_THETA 
 *        ---------------------------------------------------------- 
 * 
 * DESCRIPTION : DETERMINE SI LE CALCUL DEMANDE EST PREVU PAR LA VERSION 
 *               ACTUELLE DE G_THETA, ET PREVIENT L'UTILISATEUR SI LE CAS 
 *               ENVISAGE N'EST PAS TESTE OU VALIDE PAR LA BASE DE CAS TESTS 
 *               ACTUELLE. 
 *               ON EN PROFITE EGALEMENT POUR CREER CERTAINS OBJETS QUI SERONT 
 *               UTILISES PAR G_THETA. 
 * ============================================================================= 
 DEBP G_CAS SUPTAB*'TABLE' BOOL*'TABLE' ; 
   
 * I - DETERMINATION DU CAS DEMANDE ET VERIFICATION DES DONNEES OBLIGATOIRES 
 * ------------------------------------------------------------------------- 
   
 SAUT 'LIGNE' ; 
 MESS 'IDENTIFICATION DU CAS DEMANDE PAR L''UTILISATEUR :' ; 
 SAUT 'LIGNE' ; 
 NDEC = 20 ; 
   
 * I.1 - LECTURE DES DONNEES FOURNIES A SUPTAB 
 * ******************************************* 
   
 * I.1.A - OBJECTIF 
 SI (NON (EXIS SUPTAB 'OBJECTIF')) ; 
     MESS 'ERREUR : IL FAUT SPECIFIER L INTEGRALE' ; 
     MESS '        A CALCULER PAR UN MOT' ; 
     ERRE 21 ; QUIT G_CAS ; 
 SINON ; 
     SI (NEG (TYPE SUPTAB.'OBJECTIF') 'MOT') ; 
         MESS 'ERREUR : OBJECTIF INCORRECT. ON ATTEND UN ''MOT''.' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     GOBJ = MOT SUPTAB.'OBJECTIF' ; 
 FINSI ; 
 * MESSAGE 
 MESSOBJ = CHAI 'OBJECTIF :' (MOT GOBJ)/NDEC ; 
 MESS MESSOBJ ; 
   
 * I.1.B - DIMENSION ET MODE DE CALCUL 
 GDIME = VALE 'DIME' ; 
 GMODE = VALE 'MODE' ; 
 * MESSAGE 
 MESSDIME = CHAI 'DIMENSION :' GDIME/NDEC ; 
 MESS MESSDIME ; 
 MESSMODE = CHAI 'MODE :' GMODE/NDEC ; 
 MESS MESSMODE ; 
   
 * I.1.C - TYPE DE SOLUTION DONNEE 
 SI (NON ((EXIS SUPTAB 'SOLUTION_RESO') OU (EXIS SUPTAB 'SOLUTION_PASAPAS'))) ; 
     MESS 'ERREUR : IL FAUT UNE SOLUTION PROVENANT DE PASAPAS' ; 
     MESS '         OU DE RESO POUR DETERMINER L''INTEGRALE' ; 
     ERRE 21 ; QUIT G_CAS ; 
 SINON ; 
     SI (EXIS SUPTAB 'SOLUTION_RESO') ; 
         SI (NEG (TYPE SUPTAB.'SOLUTION_RESO') 'CHPOINT') ; 
             MESS 'ERREUR : SOLUTION_RESO INCORRECTE.' 
             MESS '         ON ATTEND UN ''CHPOINT''.' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
         GSOLU = 'LINEAIRE' ; 
     SINON ; 
         GSOLU = MOT 'PASAPAS' ; 
     FINSI ; 
 FINSI ; 
   
 * I.1.D - MODELE MECANIQUE, MATERIAU ET HYPOTHESE DE CALCUL 
 SI (EGA GSOLU 'LINEAIRE') ; 
     SI (NON (EXIS SUPTAB 'MODELE')) ; 
         MESS 'ERREUR : UNE SOLUTION ISSUE DE RESO NECESSITE UN MODELE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NON (EXIS SUPTAB 'CARACTERISTIQUES')) ; 
         MESS 'ERREUR : IL FAUT DONNER LE CHAMP CARACTERISTIQUE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     MOD_TOT = SUPTAB.'MODELE' ; 
     MOD_MEC = EXTR MOD_TOT 'FORM' 'MECANIQUE' ; 
     MAT_MEC = REDU (SUPTAB.'CARACTERISTIQUES') MOD_MEC ; 
     GHYPO = 'HPP' ; 
 SINON ; 
     SI (EXIS SUPTAB.'SOLUTION_PASAPAS' 'WTABLE') ; 
         MOD_TOT = SUPTAB.'SOLUTION_PASAPAS'.'MODELE' ; 
         WTAB = SUPTAB.'SOLUTION_PASAPAS'.'WTABLE' ; 
         MOD_MEC = WTAB.'MOD_MEC' ; 
         MAT_MEC = WTAB.'MAT_MEC' ; 
     SINON ; 
         MESS 'Absence de WTABLE !  l execution continue ...' ; 
         MOD_TOT = SUPTAB.'SOLUTION_PASAPAS'.'MODELE' ; 
         WTAB = SUPTAB.'SOLUTION_PASAPAS' ; 
         MOD_MEC = EXTR MOD_TOT 'FORM' 'MECANIQUE' ; 
         MAT_MEC = REDU (WTAB.'CARACTERISTIQUES') MOD_MEC ; 
     FINSI ; 
     SUPTAB.'MODELE' = MOD_MEC ; 
     SI WTAB.'GRANDS_DEPLACEMENTS' ; 
         GHYPO = 'GRANDS_DEPLACEMENTS' ; 
     SINON ; 
         GHYPO = 'HPP' ; 
     FINSI ; 
     SI WTAB.'DYNAMIQUE' ; 
         GSOLU = CHAI GSOLU ' ' 'DYNAMIQUE' ; 
     SINON ; 
         GSOLU = CHAI GSOLU ' ' 'STATIQUE' ; 
     FINSI ; 
 FINSI ; 
 GMTYPE = TABL ; 
 * COMPORTEMENT ELASTIQUE 
 SI (EXIS MOD_MEC 'MATE' 'ISOTROPE') ; 
     GMTYPE.'ELASTIQUE' = MOT 'ELASTIQUE ISOTROPE' ; 
 SINON ; 
     GMTYPE.'ELASTIQUE' = MOT 'ELASTIQUE ANISOTROPE' ; 
 FINSI ; 
 * COMPORTEMENT PLASTIQUE 
 MPLAS = TABL ; 
 MPLAS.(1) MPLAS.(2) MPLAS.(3) = 'ISOTROPE' 'PARFAIT' 'CINEMATIQUE' ; 
 SI (EXIS MOD_MEC 'MATE' 'PLASTIQUE') ; 
     GMTYPE.'PLASTIQUE' = MOT 'PLASTIQUE' ; 
     REPE I (DIME MPLAS) ; 
         SI (EXIS MOD_MEC 'MATE' MPLAS.&I) ; 
             GMTYPE.'PLASTIQUE' = CHAI GMTYPE.'PLASTIQUE' ' ' MPLAS.&I ; 
         FINSI ; 
     FIN I ; 
 FINSI ; 
 * COMPORTEMENT VISCOPLASTIQUE 
 MVISC = TABL ; 
 MVISC.(1) MVISC.(2) MVISC.(3) MVISC.(4) MVISC.(5) MVISC.(6) = 
     'NORTON' 'POLYNOMIAL' 'BLACKBURN' 'RCCMR_316' 'RCCMR_304' 'LEMAITRE' ; 
 SI (EXIS MOD_MEC 'MATE' 'FLUAGE') ; 
     GMTYPE.'FLUAGE' = MOT 'FLUAGE' ; 
     REPE I (DIME MVISC) ; 
         SI (EXIS MOD_MEC 'MATE' MVISC.&I) ; 
             GMTYPE.'FLUAGE' = CHAI GMTYPE.'FLUAGE' ' ' MVISC.&I ; 
         FINSI ; 
     FIN I ; 
 FINSI ; 
 * PROPRIETES QUI DEPENDENT D'UN PARAMETRE 
 CPARA = EXTR MAT_MEC 'COVA' ; 
 PPARA = MOTS ; 
 REPE I (DIME CPARA) ; 
     PPARA = PPARA ET (EXTR CPARA &I) ; 
 FIN I ; 
 * PROPRIETES QUI DEPENDENT DE LA POSITION 
 MCOMP = EXTR MAT_MEC 'COMP' ; 
 PPOSI = MOTS ; 
 REPE I (DIME MCOMP) ; 
     ICOMP = EXTR MCOMP &I ; 
     SI (NON (EXIS PPARA ICOMP)) ; 
         ICHAM = EXCO MAT_MEC ICOMP ; 
         SI (NEG (MINI ICHAM) (MAXI ICHAM)) ; 
             PPOSI = PPOSI ET ICOMP ; 
         FINSI ; 
     FINSI ; 
 FIN I ; 
 * PROPRIETES A GRADIENT 
 PGRAD = PPARA ET PPOSI ; 
 * DISCONTINUITES MATERIELLES 
 SI (EXIS SUPTAB 'MODELES_COMPOSITES') ; 
     DISMAT = VRAI ; 
     TABMOD = SUPTAB.'MODELES_COMPOSITES' ; 
 SINON ; 
     DISMAT = FAUX ; 
 FINSI ; 
 * MESSAGE TYPE DE SOLUTION 
 MESSSOLU = CHAI 'CALCUL :' GSOLU/NDEC ; 
 MESS MESSSOLU ; 
 * MESSAGE HYPOTHESE DE CALCUL 
 MESSHYPO = CHAI 'HYPOTHESE :' GHYPO/NDEC ; 
 MESS MESSHYPO ; 
 * MESSAGE MATERIAU 
 MESSMAT = CHAI 'COMPORTEMENT :' GMTYPE.'ELASTIQUE'/NDEC ; 
 SI (EXIS GMTYPE 'PLASTIQUE') ; 
     MESSMAT = CHAI MESSMAT ' ' GMTYPE.'PLASTIQUE' ; 
 FINSI ; 
 SI (EXIS GMTYPE 'FLUAGE') ; 
     MESSMAT = CHAI MESSMAT ' ' GMTYPE.'FLUAGE' ; 
 FINSI ; 
 MESS MESSMAT ; 
 * MESSAGE VARIATION DES PROPRIETES 
 SI DISMAT ; 
     MESSVAR = CHAI 'PROPRIETES :' 'HOMOGENES PAR MORCEAUX'/NDEC ; 
 SINON ; 
     SI ((DIME PGRAD) > 0) ; 
         MESSVAR = CHAI 'PROPRIETES :' 'HETEROGENES A GRADIENT'/NDEC ; 
     SINON ; 
         MESSVAR = CHAI 'PROPRIETES :' 'HOMOGENES'/NDEC ; 
     FINSI ; 
 FINSI ; 
 MESS MESSVAR ; 
   
 * I.1.E - MAILLAGE ET TYPE D'ELEMENTS 
 MAILLAGE = EXTR MOD_MEC 'MAIL' ; 
 SUPTAB.'FISSURE' = VIDE 'MAILLAGE' ; 
 SI (EXIS SUPTAB 'LEVRE_SUPERIEURE') ; 
     SUPTAB.'FISSURE' = SUPTAB.'FISSURE' ET SUPTAB.'LEVRE_SUPERIEURE' ; 
 FINSI ; 
 SI (EXIS SUPTAB 'LEVRE_INFERIEURE') ; 
     SUPTAB.'FISSURE' = SUPTAB.'FISSURE' ET SUPTAB.'LEVRE_INFERIEURE' ; 
 FINSI ; 
 * ELEMENTS LINEAIRES OU NONLINEAIRES 
 ELTYPE = MAILLAGE ELEM 'TYPE' ; 
 ELLIN = MOTS 'TRI3' 'QUA4' 'CUB8' 'PRI6' 'PYR5' 'TET4' ; 
 ELQUA = MOTS 'TRI6' 'QUA8' 'CU20' 'PR15' 'PY13' 'TE10' ; 
 IENLE = LECT ; 
 REPE I (DIME ELTYPE) ; 
     SI (NON (EXIS (ELLIN ET ELQUA) (EXTR ELTYPE &I))) ; 
         IENLE = IENLE ET (LECT &I) ; 
     FINSI ; 
 FIN I ; 
 SI ((DIME IENLE) NEG 0) ; 
     MESS 'ATTENTION : IL Y A DES ELEMENTS ATYPIQUES DANS LE MAILLAGE...' ; 
     MESS '            LE CALCUL SE POURSUIT QUAND MEME.' ; 
     ELTYPE = ENLE ELTYPE IENLE ; 
 FINSI ; 
 SI (NON ((EXIS ELLIN ELTYPE 'ET') OU (EXIS ELQUA ELTYPE 'ET'))) ; 
     MESS 'ATTENTION : IL Y A A LA FOIS DES ELEMENTS LINEAIRES ET DES' ; 
     MESS '            ELEMENTS QUADRATIQUES DANS LE MAILLAGE' ; 
     GELDEG = 1.5 ; 
 SINON ; 
     SI (EXIS ELLIN ELTYPE 'ET') ; 
         GELDEG = 1 ; 
     SINON ; 
         GELDEG = 2 ; 
     FINSI ; 
 FINSI ; 
 * ELEMENTS XFEM OU STANDARD (MASSIF OU COQUE) 
 SI (EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R') ; 
     GELTYP = MOT 'XFEM' ; 
 SINON ; 
     EL2D = MOTS 'TRI3' 'TRI6' 'QUA4' 'QUA8' ; 
     EL3D = MOTS 'CUB8' 'CU20' 'PRI6' 'PR15' 'PYR5' 'PY13' 'TET4' 'TE10' ; 
     SI (NON ((EXIS EL2D ELTYPE 'ET') OU (EXIS EL3D ELTYPE 'ET'))) ; 
         MESS 'ERREUR : LE MAILLAGE SUPPORT DU MODELE EST CONSTITUE' ; 
         MESS '         D''ELEMENTS 2D ET 3D.' ; 
         ERRE 21 ; QUIT G_CAS ; 
     SINON ; 
         SI ((EGA GDIME 3) ET (EXIS EL2D ELTYPE 'ET')) ; 
             GELTYP = 'STD COQUE' ; 
         SINON ; 
             GELTYP = MOT 'STD MASSIF' ; 
         FINSI ; 
     FINSI ; 
 FINSI ; 
 * MESSAGE 
 MESSELEM = CHAI 'ELEMENTS :' GELTYP/NDEC ; 
 MESSELEM = CHAI MESSELEM ' DEGRE' ' ' GELDEG ; 
 MESS MESSELEM ; 
   
 * I.1.F - CHARGEMENT 
 GCHAR = TABL ; 
 SI (EXIS MOD_TOT 'MATE' 'PRESSION') ; 
     SI (EGA GELTYP 'XFEM') ; 
         GCHAR.'PRESSION' = 'HORS LEVRES' ; 
     SINON ; 
         MODCHA = EXTR MOD_TOT 'FORM' 'CHARGEMENT' ; 
         MODPRE = EXTR MODCHA 'COMP' 'PRESSION' ; 
         MAILPTOT = EXTR MODPRE 'MAIL' ; 
         MAILPF = INTE MAILPTOT (SUPTAB.'FISSURE') ; 
         SI ((NBEL MAILPF) > 0) ; 
             GCHAR.'PRESSION' = 'SUR LEVRES' ; 
         SINON ; 
             GCHAR.'PRESSION' = 'HORS LEVRES' ; 
         FINSI ; 
     FINSI ; 
 SINON ; 
     GCHAR.'PRESSION' = 'AUCUN' ; 
 FINSI ; 
 SI (EGA GSOLU 'LINEAIRE') ; 
     GCHAR.'MECANIQUE' = EXIS SUPTAB 'CHARGEMENTS_MECANIQUES' ; 
     SI (EXIS SUPTAB 'TEMPERATURES') ; 
         GCHAR.'THERMIQUE' = MOT 'DECOUPLE' ; 
     SINON ; 
         GCHAR.'THERMIQUE' = 'AUCUN' ; 
     FINSI ; 
     GCHAR.'DEFORMATIONS IMPOSEES' = EXIS SUPTAB 'DEFORMATIONS_IMPOSEES' ; 
 SINON ; 
     CHAR1 = SUPTAB.'SOLUTION_PASAPAS'.'CHARGEMENT' ; 
     GCHAR.'MECANIQUE' = (EXIS CHAR1 'DIMP') OU (EXIS CHAR1 'MECA') ; 
     SI (EXIS CHAR1 'T') ; 
         GCHAR.'THERMIQUE' = MOT 'DECOUPLE' ; 
     SINON ; 
         SI ((EXIS CHAR1 'TIMP') OU (EXIS CHAR1 'Q') OU 
             (EXIS CHAR1 'TECO') OU (EXIS CHAR1 'TERA')) ; 
             GCHAR.'THERMIQUE' = MOT 'COUPLE' ; 
         SINON ; 
             GCHAR.'THERMIQUE' = 'AUCUN' ; 
         FINSI ; 
     FINSI ; 
     GCHAR.'DEFORMATIONS IMPOSEES' = EXIS CHAR1 'DEFI' ; 
 FINSI ; 
 NMESS = 0 ; 
 MESSCHAR = MOT 'CHARGEMENT :' ; 
 ICHAR = INDE GCHAR ; 
 REPE I (DIME ICHAR) ; 
     MCHAR = MOT ICHAR.&I ; 
     SI (NEG NMESS 0) ; 
         MESSCHAR = ' ' ; 
     FINSI ; 
     SI (EGA (TYPE GCHAR.(MOT ICHAR.&I)) 'LOGIQUE') ; 
         SI GCHAR.MCHAR ; 
             MESSCHAR = CHAI MESSCHAR MCHAR/NDEC ; 
             MESS MESSCHAR ; 
             NMESS = NMESS + 1 ; 
         FINSI ; 
     FINSI ; 
     SI (EGA (TYPE GCHAR.MCHAR) 'MOT') ; 
         SI (NEG GCHAR.MCHAR 'AUCUN') ; 
             MESSCHAR = CHAI MESSCHAR MCHAR/NDEC ; 
             MESSCHAR = CHAI MESSCHAR ' ' GCHAR.MCHAR ; 
             MESS MESSCHAR ; 
             NMESS = NMESS + 1 ; 
         FINSI ; 
     FINSI ; 
 FIN I ; 
   
 * I.1.G - CONTACT ENTRE LEVRES DE FISSURE 
 BCONT = (EXIS SUPTAB 'MODELE_FISSURE') ; 
 MESSCONT = CHAI 'CONTACT LEVRES :' BCONT/NDEC ; 
 MESS MESSCONT ; 
   
   
 * I.2 - VERIFICATION QUE LE CAS EST TRAITABLE 
 * ******************************************* 
   
 * I.2.A - VERIFICATION QUE L'ON CONNAIT L'OBJECTIF 
 OBJPOSS = MOTS 'J' 'C*' 'C*H' 'DJ/DA' 'J_DYNA' 'DECOUPLAGE' ; 
 SI (NON (EXIS OBJPOSS GOBJ)) ; 
     MESS 'ERREUR : ON NE CONNAIT PAS L INTEGRALE SPECIFIEE' ; 
     MESS '         A CALCULER' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
 * I.2.B - VERIFICATION QUE LE MATERIAU EST ISOTROPE 
 SI (EGA GMTYPE.'ELASTIQUE' (MOT 'ELASTIQUE ANISOTROPE')) ; 
     MESS 'ERREUR : ON NE PEUT PAS TRAITER LE CAS DE MATERIAUX ANISOTROPES.' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
 * I.2.C - VERIFICATION QUE L'ON A PAS A LA FOIS DES INTERFACES ET DES GRADIENTS 
 *         DE PROPRIETES 
 SI (DISMAT ET ((DIME PGRAD) > 0)) ; 
     MESS 'ERREUR : ON NE PEUT PAS TRAITER LE CAS DE DISCONTINUITES' ; 
     MESS '         MATERIELLES DANS UN SOLIDE A GRADIENT DE PROPRIETES' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
 * I.2.D - INTERFACES (2D SEULEMENT, ET ON DOIT AVOIR AU MOINS DEUX MODELES) 
 SI DISMAT ; 
     SI (EGA GDIME 3) ; 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE TRAITER LES DISCONTINUITES DE' ; 
         MESS '         PROPRIETES EN 3D' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI ((DIME SUPTAB.'MODELES_COMPOSITES') < 2) ; 
         MESS 'ERREUR : IL FAUT AU MOINS DEUX MODELES POUR' ; 
         MESS '         DETERMINER LA LIGNE COMMUNE D''INTERFACE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.E - OBJECTIF : J 
 SI (EGA GOBJ 'J') ; 
     SI (EXIS GMTYPE 'FLUAGE') ; 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTOPLASTIQUE POUR' ; 
         MESS '         CALCULER L''INTEGRALE J' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.F - OBJECTIF : C* OU C*H 
 SI ((EGA GOBJ 'C*') OU (EGA GOBJ 'C*H')) ; 
     SI (NON (EXIS GMTYPE 'FLUAGE')) ; 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT VISCOPLASTIQUE POUR' ; 
         MESS '         CALCULER L''INTEGRALE' ' ' GOBJ ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GCHAR.'THERMIQUE' 'AUCUN') ; 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE CALCULER L''INTEGRALE' ' ' GOBJ ; 
         MESS '         DANS LE CAS D''UN CHARGEMENT THERMIQUE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GHYPO 'HPP') ; 
         MESS 'ERREUR : ON NE PEUT PAS ENCORE CALCULER L''INTEGRALE' ' ' GOBJ ; 
         MESS '         EN GRANDS DEPLACEMENTS' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (EGA GOBJ 'C*H') ; 
         REPE I (DIME MVISC) ; 
             SI ((NEG MVISC.&I 'NORTON') ET (EXIS MOD_MEC 'MATE' MVISC.&I)) ; 
                 MESS 'ERREUR : IL FAUT UN MODELE DE FLUAGE NORTON' ; 
                 MESS '         SEUL POUR CALCULER L INTEGRALE' ' ' GOBJ ; 
             FINSI ; 
         FIN I ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.G - OBJECTIF : DJ/DA 
 SI (EGA GOBJ 'DJ/DA') ; 
     SI (EXIS GMTYPE 'FLUAGE') ; 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTOPLASTIQUE POUR' ; 
         MESS '         CALCULER L''INTEGRALE DJ/DA' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (DISMAT OU ((DIME PGRAD) > 0)) ; 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QUE' ; 
         MESS '         DANS LE CAS DE PROPRIETES HOMOGENES' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GELTYP 'STD MASSIF') ; 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QU''AVEC' ; 
         MESS '         DES ELEMENTS STANDARDS MASSIFS' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GHYPO 'HPP') ; 
         MESS 'ERREUR : ON NE PEUT CALCULER L''INTEGRALE DJ/DA QUE' ; 
         MESS '         SOUS L''HYPOTHESE DES PETITES PERTURBATIONS' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NON (EXIS SUPTAB 'BLOCAGES_MECANIQUES')) ; 
         MESS 'ERREUR : IL FAUT DONNER LES BLOCAGES MECANIQUES' ; 
         MESS '         POUR CALCULER L''INTEGRALE DJ/DA' 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.H - OBJECTIF : J_DYNA 
 SI (EGA GOBJ 'J_DYNA') ; 
     SI ((EXIS GMTYPE 'PLASTIQUE') OU (EXIS GMTYPE 'FLUAGE')) ; 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTIQUE POUR CALCULER' ; 
         MESS '         L''INTEGRALE J_DYNA' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GSOLU (MOT 'PASAPAS DYNAMIQUE')) ; 
         MESS 'ERREUR : ON ATTEND UNE SOLUTION DE PASAPAS DYNAMIQUE POUR' ; 
         MESS '         CALCULER L''INTEGRALE J_DYNA' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.I - OBJECTIF : DECOUPLAGE 
 SI (EGA GOBJ (MOT 'DECOUPLAGE')) ; 
     SI ((EXIS GMTYPE 'PLASTIQUE') OU (EXIS GMTYPE 'FLUAGE')) ; 
         MESS 'ERREUR : ON ATTEND UN COMPORTEMENT ELASTIQUE POUR UTILISER' ; 
         MESS '         L''OPTION DECOUPLAGE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI ((DIME PGRAD) > 0) ; 
         MESS 'ERREUR : ON NE PEUT PAS UTILISER L''OPTION DECOUPLAGE POUR UN' ; 
         MESS '         SOLIDE A GRADIENT DE PROPRIETES' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (EGA GELTYP 'STD COQUE') ; 
         MESS 'ERREUR : ON NE PEUT PAS UTILISER L''OPTION DECOUPLAGE DANS LE' ; 
         MESS '         CAS DE COQUES' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 *    SI IL Y A DES INTERFACES IL FAUT VERIFIER QU'ELLES SONT PARALLELES A LA 
 *    FISSURE, MAIS LA DIRECTION DE CELLE-CI EST OBTENUE APRES AVOIR CALCULE 
 *    LE CHAMP THETA, DONC CETTE VERIFICATION EST FAITE DANS G_THETA 
 FINSI ; 
   
 * I.2.J - CONTACT ENTRE LES LEVRES : UNIQUEMENT AVEC RESO ET XFEM 
 SI BCONT ; 
     SI (NEG GSOLU 'LINEAIRE') ; 
         MESS 'ERREUR : CONTACT ENTRE LES LEVRES NON PREVU AVEC UNE SOLUTION' ; 
         MESS '         DE PASAPAS' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
     SI (NEG GELTYP (MOT 'XFEM')) ; 
         MESS 'ERREUR : CONTACT ENTRE LES LEVRES NON PREVU AVEC DES ELEMENTS' ; 
         MESS '         STANDARDS' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.2.K - ON VERIFIE QU'IL N'Y A PAS DE GRADIENT DE COEFFICIENT DE POISSON 
 SI (EXIS PGRAD 'NU') ; 
     MESS 'ERREUR : ON NE SAIT PAS ENCORE TRAITER LA PRESENCE D''UN GRADIENT' ; 
     MESS '         DE COEFFICIENT DE POISSON' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
   
 * I.3 - VERIFICATION DES DONNEES NECESSAIRES 
 * ****************************************** 
   
 * I.3.A - FRONT DE FISSURE 
 SI (NON (EXIS SUPTAB 'FRONT_FISSURE')) ; 
     MESS 'ERREUR : ON VEUT LE FRONT DE LA FISSURE' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
 M_FRONT = SUPTAB.'FRONT_FISSURE' ; 
 SI ((NEG (TYPE M_FRONT) 'MAILLAGE') ET (NEG (TYPE M_FRONT) 'POINT')) ; 
     MESS 'ERREUR : LE FRONT DE FISSURE DOIT ETRE DE TYPE MAILLAGE OU POINT' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
 SI (EGA (TYPE M_FRONT) 'POINT') ; 
     M_FRONT = MANU 'POI1' M_FRONT ; 
 FINSI ; 
 M_FRONT = M_FRONT COUL 'OLIV' ; 
   
 * I.3.B - FISSURE_2 ET SON FRONT POUR DJ/DA 
 SI (EGA GOBJ 'DJ/DA') ; 
     SI ((EXIS SUPTAB 'FISSURE_2') OU (EXIS SUPTAB 'FRONT_FISSURE_2')) ; 
         SI (NON (EXIS SUPTAB 'FISSURE_2')) ; 
             MESS 'ERREUR : ON VEUT AUSSI LA FISSURE 2 POUR CALCULER' ; 
             MESS '         LES TERMES CROISES DE LA MATRICE' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
         SI (NON (EXIS SUPTAB 'FRONT_FISSURE_2')) ; 
             MESS 'ERREUR : ON VEUT AUSSI LE FROND DE LA FISSURE 2 POUR' ; 
             MESS '         CALCULER LES TERMES CROISES DE LA MATRICE' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
     SINON ; 
         SI (EGA SUPTAB.'COUCHE' 0) ; 
             MESS 'ERREUR : LE NOMBRE DE COUCHES DOIT ETRE SUPERIEUR A' ; 
             MESS '         0 POUR LE CALCUL DU TERME PRINCIPAL DJi/DAi' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
     FINSI ; 
 FINSI ; 
   
 * I.3.C - PRESSION OBLIGATOIRE SI CALCUL LINEAIRE ET MODELE DE PRESSION 
 SI ((NEG GCHAR.'PRESSION' 'AUCUN') ET (EGA GSOLU 'LINEAIRE')) ; 
     SI (NON (EXIS SUPTAB 'PRESSION')) ; 
         MESS 'ERREUR : IL MANQUE LA DONNEE DU CHAMP DE PRESSION' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.3.D - VERIFICATION QU'ON A LE CHARGEMENT SI SOLUTION LINEAIRE 
 SI (EGA GSOLU 'LINEAIRE') ; 
     SI ((EGA GCHAR.'THERMIQUE' 'AUCUN') 
             ET (EGA GCHAR.'PRESSION' 'AUCUN') 
             ET (NON GCHAR.'MECANIQUE') 
             ET (NON GCHAR.'DEFORMATIONS IMPOSEES')) ; 
         MESS 'ERREUR : IL FAUT LES CHARGEMENTS APPLIQUES :' ; 
         MESS '         MECANIQUES, THERMIQUES OU LES DEUX' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 FINSI ; 
   
 * I.3.E - DEFINITION DE LA FISSURE NECESSAIRE 
 SI (EGA GELTYP (MOT 'XFEM')) ; 
     SI (NON ((EXIS SUPTAB 'PSI') ET (EXIS SUPTAB 'PHI'))) ; 
         MESS 'ERREUR : ON VEUT PSI et PHI LEVELSET DE LA FISSURE' ; 
         ERRE 21 ; QUIT G_CAS ; 
     FINSI ; 
 SINON ; 
     SI (EGA GT_OBJ 'DECOUPLAGE') ; 
         SI (NON ((EXIS SUPTAB 'LEVRE_SUPERIEURE') ET 
                     (EXIS SUPTAB 'LEVRE_INFERIEURE'))) ; 
             MESS 'ERREUR : L''OBJECTIF DECOUPLAGE NECESSITE LES DEUX' ; 
             MESS '         LEVRES DE LA FISSURE' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
     SINON ; 
         SI (NON ((EXIS SUPTAB 'LEVRE_SUPERIEURE') OU 
                     (EXIS SUPTAB 'LEVRE_INFERIEURE'))) ; 
             MESS 'ERREUR : IL FAUT DONNER LA FISSURE' ; 
             MESS '(LEVRE_SUPERIEURE OU LEVRE_INFERIEURE OU LES 2)' ; 
             ERRE 21 ; QUIT G_CAS ; 
         FINSI ; 
     FINSI ; 
 FINSI ; 
   
 * I.3.F - ON VERIFIE QU'ON A OU BIEN LE NOMBRE DE COUCHES OU BIEN CHAM_THETA 
 SI (NON ((EXIS SUPTAB 'COUCHE') OU (EXIS SUPTAB 'CHAMP_THETA'))) ; 
     MESS 'ERREUR : ON VEUT LE NOMBRE DE COUCHES D ELEMENTS' ; 
     MESS '         AUTOUR DE LA FISSURE QUI SE DEPLACE' ; 
     MESS '         OU LE CHAMP_THETA' ; 
     MESS '         POUR SIMULER LA PROPAGATION DE LA FISSURE' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
 * I.3.G - ON NE CALCULE PAS CORRECTEMENT LE CAS THERMIQUE AVEC DES COQUES 
 *         DONC POUR L'INSTANT ON DEBRANCHE L'OPTION 
 SI ((EGA GELTYP 'STD COQUE') ET (NEG GCHAR.'THERMIQUE' 'AUCUN')) ; 
     MESS 'ERREUR : UNE CORRECTION EST NECESSAIRE POUR TRAITER UN CHARGEMENT' ; 
     MESS '         THERMIQUE AVEC LES ELEMENTS COQUE' ; 
     ERRE 21 ; QUIT G_CAS ; 
 FINSI ; 
   
   
 * ============================================================================= 
   
 * II - STOCKAGE DES INFORMATIONS POUR TRANSFERT A G_THETA 
 * ------------------------------------------------------- 
   
 * II.1 - OBJETS ET INFOS UTILES DANS OBJUTI 
 * ***************************************** 
   
 OBJUTI = TABL ; 
 OBJUTI.'DIMENSION' = GDIME ; 
 OBJUTI.'MODE' = GMODE ; 
 OBJUTI.'MOD_TOT' = MOD_TOT ; 
 OBJUTI.'MOD_MEC' = MOD_MEC ; 
 OBJUTI.'MAT_MEC' = MAT_MEC ; 
 OBJUTI.'MAILLAGE' = MAILLAGE ; 
 OBJUTI.'FRONT' = M_FRONT ; 
 SI (NEG GSOLU 'LINEAIRE') ; 
     OBJUTI.'WTAB' = WTAB ; 
 FINSI ; 
   
 * II.2 - BOOLEENS DANS BOOL 
 * ************************* 
   
 * OBJECTIF 
 BOOL.'J' = EGA SUPTAB.'OBJECTIF' 'J' ; 
 BOOL.'C*' = EGA SUPTAB.'OBJECTIF' 'C*' ; 
 BOOL.'C*H' = EGA SUPTAB.'OBJECTIF' 'C*H' ; 
 BOOL.'DJ/DA' = EGA SUPTAB.'OBJECTIF' 'DJ/DA' ; 
 BOOL.'J_DYNA' = EGA SUPTAB.'OBJECTIF' 'J_DYNA' ; 
 BOOL.'DECOUPLAGE' = EGA SUPTAB.'OBJECTIF' (MOT 'DECOUPLAGE') ; 
 * PASAPAS 
 BOOL.'PASAPAS' = NEG GSOLU 'LINEAIRE' ; 
 * GRANDS DEPLACEMENTS 
 BOOL.'GRANDS_DEP' = EGA GHYPO 'GRANDS_DEPLACEMENTS' ; 
 * MODELE DE PRESSION 
 BOOL.'MODE_PRES' = NEG GCHAR.'PRESSION' 'AUCUN' ; 
 * PRESSION SUR FISSURE 
 BOOL.'PRES_FISS' = EGA GCHAR.'PRESSION' 'SUR LEVRES' ; 
 * CHARGEMENTS THERMIQUES 
 BOOL.'THER_DECO' = EGA GCHAR.'THERMIQUE' (MOT 'DECOUPLE') ; 
 BOOL.'THER' = NEG GCHAR.'THERMIQUE' 'AUCUN' ; 
 * DEFORMATIONS IMPOSEES 
 BOOL.'DEF_IMP' = GCHAR.'DEFORMATIONS IMPOSEES' ; 
 * ORDRE DES ELEMENTS 
 BOOL.'EL_LIN' = EGA GELDEG 1 ; 
 BOOL.'EL_QUA' = EGA GELDEG 2 ; 
 * ELEMENTS XFEM 
 BOOL.'XFEM' = EXIS MOD_MEC 'ELEM' 'XQ4R' 'XC8R' ; 
 * ELEMENTS COQUE 
 BOOL.'COQ' = EGA GELTYP 'STD COQUE' ; 
 * ROTATION DE CORPS RIGIDE 
 BOOL.'ROT_RIG' = EXIS SUPTAB 'ROTATION_RIGIDIFIANTE' ; 
 * PERSO1 
 SI (EXIS SUPTAB 'PERSO1') ; 
     BOOL.'PERSO1' = SUPTAB.'PERSO1' ; 
 SINON ; 
     BOOL.'PERSO1' = FAUX ; 
 FINSI ; 
 * FROTTEMENT ENTRE LEVRES DE FISSURE 
 BOOL.'FROT' = EXIS SUPTAB 'MODELE_FISSURE' ; 
   
   
 * SAUT DE LIGNE AVANT DE RETOURNER DANS G_THETA 
 SAUT 'LIGNE' ; 
   
 FINP OBJUTI ; 
 * CH_THETA  PROCEDUR  FD218221  16/10/24    21:15:00     9134 
 'DEBPROC' CH_THETA SUPTAB*TABLE ; 
 *|=====================================================================| 
 *|                                                                     | 
 *|  << OBJET >> :                                                      | 
 *|                                                                     | 
 *|  Procedure determinant un champ/point de type THETA, c'est-a-dire   | 
 *|  un champ/point dont le norme est constant a l'interieur d'une      | 
 *|  courronne entourant le front d'une fissure, zero a l'exterieur de  | 
 *|  cette courronne. Le vecteur represente par le champ THETA indique  | 
 *|  la direction de propagation eventuelle de la fissure.              | 
 *|                                                                     | 
 *|  << ENTREE >> :                                                     | 
 *|                                                                     | 
 *|  SUPTAB = Objet de type TABLE dont les indices sont des             | 
 *|           objets de type MOT (a ecrire en toutes lettres) :         | 
 *|                                                                     | 
 *|  ARGUMENTS OBLIGATOIRES DANS TOUS LES CAS                           | 
 *|                             | 
 *|                                                                     | 
 *|  SUPTAB.'MAILLAGE' = Objet de type MAILLAGE representant soit       | 
 *|                      la structure totale etudiee (maillage          | 
 *|                      utilise dans l'analyse par elements finis,     | 
 *|                      soit, pour reduire le temps de calcul, le      | 
 *|                      maillage entourant le plus grand des contours  | 
 *|                      qu'on a defini pour calculer le champ THETA.   | 
 *|  SUPTAB.'FISSURE'  = Objet de type MAILLAGE donnant toutes les deux | 
 *|                      levres d'une fissure si elle est complete (la  | 
 *|                      fissure presente des noeuds doubles), une      | 
 *|                      seule levre si l'autre levre n'est pas maille | 
 *|                      en raison, par example, de la symetrie du      | 
 *|                      probleme.                                      | 
 *|  SUPTAB.'FRONT_FISSURE' = Objet de type POINT (representant la      | 
 *|                           pointe de la fissure) si la fissure est   | 
 *|                           une ligne, de type MAILLAGE (representant | 
 *|                           le front de la fissure) si la fissure est | 
 *|                           sur un plan en 3D.                        | 
 *|  SUPTAB.'COUCHE'   = Objet de type ENTIER representant le nombre    | 
 *|                      de couches d'elements (autour du point de      | 
 *|                      fissure) qui se deplacent pour simuler la      | 
 *|                      propagtion de la fissure.                      | 
 *|                                                                     | 
 *|  CAS D'UNE FISSURE CIRCULAIRE DANS UNE GEOMETRIE PLANE              | 
 *|                | 
 *|                                                                     | 
 *|  SUPTAB.'PCENTRE'  = centre de la fissure circulaire                | 
 *|                                                                     | 
 *|                                                                     | 
 *|  CAS OU L EXTENSION DE FISSURE CORRESPOND A UNE                     | 
 *|                       | 
 *|  SIMPLE TRANSLATION DANS UN TUYAUTERIE DROITE (3D)                  | 
 *|                    | 
 *|                                                                     | 
 *|  Dans ce cas on effectue dans la procedure une transformation de    | 
 *|  tuyau en plaque en passant au systeme de coordonnees cylindriques. | 
 *|  Il est alors necessaire de fournir :                               | 
 *|                                                                     | 
 *|  SUPTAB.'POINT_1' = centre du systeme de coordonnees                | 
 *|  SUPTAB.'POINT_2' = POINT tel que l'axe defini par POINT_1          | 
 *|                     vers POINT_2 soit l'axe Z poisitif              | 
 *|  SUPTAB.'POINT_3' = POINT tel que le plan defini par les 3 points   | 
 *|                     POINT_1 POINT_2 POINT_3 donne l'angle theta nul | 
 *|                                                                     | 
 *|  CAS OU L EXTENSION DE FISSURE NE CORRESPOND PAS                    | 
 *|                      | 
 *|  A UNE SIMPLE TRANSLATION                                           | 
 *|                                             | 
 *|                                                                     | 
 *|  A) Fissure dans un tuyauterie droite (3D, Rotation)                | 
 *|                                                                     | 
 *|  SUPTAB.'POINT_1' = Objet de type POINT                             | 
 *|  SUPTAB.'POINT_2' = Objet de type POINT qui, avec le point POINT_1, | 
 *|                     constitue l'axe perpendiculaire a la section    | 
 *|                     fissuree.                                       | 
 *|                                                                     | 
 *|  B) Fissure dans un coude (3D, rotation + transformation)           | 
 *|                                                                     | 
 *|     Outre les deux points SUPTAB.'POINT_1' et SUPTAB.'POINT_2'      | 
 *|     definis en haut on donne encore :                               | 
 *|  SUPTAB.'CHPOINT_TRANSFORMATION' = Objet de type CHPOINT utilise    | 
 *|                                    pour transformer une coude en    | 
 *|                                    un tuyauterie droite.            | 
 *|                                                                     | 
 *|  SUPTAB.'OPERATEUR' = Objet de type MOT valant 'PLUS' ou 'MOIN'     | 
 *|                       pour indiquer l'operateur PLUS ou MOIN a      | 
 *|                       utiliser si l'on veut transformer la coude    | 
 *|                       en un tuyauterie droite.                      | 
 *|                                                                     | 
 *|  EN CAS DES ELEMENTS DE COQUE                                       | 
 *|                                         | 
 *|                                                                     | 
 *|  SUPTAB.'EPAISSEUR' = Objet de type FLOTTANT donnant l'paisseur    | 
 *|                       de la coque a la pointe de la fissure         | 
 *|                                                                     | 
 *|                                                                     | 
 *|  << SORTIE >> :                                                     | 
 *|                                                                     | 
 *|  TETA = Objet de type :                                             | 
 *|                                                                     | 
 *|       - TABLE INDICEE PAR DES OBJETS DE TYPE POINT CONTENANT        | 
 *|         DES ELEMENTS DE TYPE CHPOINT DANS LE CAS 3 DIMENSIONS.      | 
 *|         CHAQUE ELEMENT CONTIENT LE CHAMP THETA AU NOEUD DU          | 
 *|         FRONT DE COORDONNEES CELLES DU POINT P : TETA.P. ELLE       | 
 *|         EST EGALEMENT INDICEE PAR LE MOT 'GLOBAL' POUR DONNER       | 
 *|         LE CHAMP THETA GLOBAL LE LONG DE TOUT FRONT DE LA FISSURE   | 
 *|       - ELEMENT DE TYPE CHPOINT CONTENANT LE CHAMP THETA EN 2       | 
 *|         DIMENSIONS (OU EN 3 DIMENSIONS AVEC DES ELEMENTS DE         | 
 *|         COQUE MINCE) A LA POINTE DE FISSURE                         | 
 *|                                                                     | 
 *|=====================================================================| 
 *-- ICOQU = VRAI ==> Elements de coque 
 *-- ILIN =  VRAI ==> Elements lineaires 
 *-- IQUA =  VRAI ==> Elements nonlineaires 
 &DIME = 'VALEUR' DIME ; &MODE = 'VALEUR' MODE ; 
 &ELEM = 'VALEUR' ELEM ; MOTAX = 'MOT' AXIS ; 
 ITRAN = VRAI; IROTA = FAUX; VALPI = PI; 
 *------------------------------------------------* 
 *-------- TEST DE COMPABILITE DES DONNEES -------* 
 *------------------------------------------------* 
 'SI' ('EGA' &ELEM 'UUUU'); 
    'MESS' 'ERREUR : TYPE D ELEMENTS NON CONNU. UTILISEZ'; 
    'MESS' '         L OPERATEUR OPTI POUR LE DECLARER'; 
    'QUITTER' CH_THETA; 
 'FINSI'; 
 'SI' ('NON' ('EXIST' SUPTAB 'MAILLAGE')); 
    'MESS' 'ERREUR : ON N A PAS TROUVE DANS LA' 
    'MESS' '         TABLE L OBJET MAILLAGE'; 
    'QUITTER' CH_THETA; 
 'SINON'; 
    MAILLAGE = SUPTAB.'MAILLAGE' ; 
    NB1 = 'NBNO' ('CHAN' MAILLAGE 'POI1'); 
 'FINSI'; 
 M_FISS = 'ELEM' MAILLAGE 'APPU' 'LARG' SUPTAB.'FRONT_FISSURE'; 
 NBNO1 = 'NBNO' ('ELEM' (CHAN 'LIGNE' M_FISS) 1); 
 ILIN = 'EGA' NBNO1 2; IQUA = 'EGA' NBNO1 3; 
 IPLAN = ('EGA' &ELEM 'TRI3') 'OU' ('EGA' &ELEM 'QUA4') 'OU' 
         ('EGA' &ELEM 'TRI6') 'OU' ('EGA' &ELEM 'QUA8'); 
 ICOQU = (&DIME 'EGA' 3) 'ET' IPLAN; 
 **** 
 'SI' (ICOQU 'ET' ('NON' ('EXIST' SUPTAB 'EPAISSEUR'))); 
    'MESS' 'ERREUR : L EPAISSEUR DE LA COQUE N EST PAS DONNEE'; 
    'QUITTER' CH_THETA; 
 'FINSI'; 
 **** 
 'SI' ('NON' ('EXIST' SUPTAB 'FISSURE')); 
    'MESS' 'ERREUR : LA FISSURE DU PROBLEME N EST PAS DONNEE'; 
    'QUITTER' CH_THETA; 
 'SINON'; 
    FISSURE = SUPTAB.'FISSURE'; 
   'SI' ('NEG' ('TYPE' FISSURE) 'MAILLAGE'); 
      'MESS' 'ERREUR : LA FISSURE DOIT ETRE UN OBJET DE TYPE MAILLAGE'; 
      'QUITTER' CH_THETA; 
   'FINSI'; 
    NB2 = 'NBNO' ('CHAN' (FISSURE 'ET' MAILLAGE) 'POI1'); 
   'SI' ('NEG' NB1 NB2); 
      'MESS' 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE'; 
      'MESS' '         LE MAILLAGE ET LA FISSURE'; 
      'QUITTER' CH_THETA; 
   'FINSI'; 
    LMOTS = 'ELEM' FISSURE 'TYPE'; ILIGN = FAUX; 
   'SI' ('EGA' ('DIME' LMOTS) 1); 
      MOT1 = 'EXTR' LMOTS 1; 
      ILIGN = ('EGA' MOT1 'SEG2') 'OU' ('EGA' MOT1 'SEG3'); 
   'FINSI'; 
   'SI' (('EGA' &DIME 3) 'ET' ('NON' ICOQU)); 
     'SI' ILIGN; 
       'MESS' 'ERREUR : EN 3D AVEC ELEMENTS MASSIFS LA'; 
       'MESS' '         FISSURE DOIT ETRE UNE SURFACE'; 
       'QUITTER' CH_THETA; 
     'FINSI'; 
   'FINSI'; 
   'SI' ((&DIME 'EGA' 2) 'OU' ICOQU); 
     'SI' ('NON' ILIGN); 
       'MESS' 'ERREUR : EN 2D OU ELEMENTS EN COQUE MINCE'; 
       'MESS' '         LA FISSURE DOIT ETRE UNE LIGNE'; 
       'QUITTER' CH_THETA; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
 **** 
 'SI' ('NON' ('EXIST' SUPTAB 'FRONT_FISSURE')); 
    'MESS' 'ERREUR : LE FRONT DE LA FISSURE N EST PAS DONNE'; 
    'QUITTER' CH_THETA; 
 'FINSI'; 
 **** 
 NB2 = 'NBNO' ('CHAN' (SUPTAB.'FRONT_FISSURE' 'ET' MAILLAGE) 'POI1'); 
 'SI' ('NEG' NB1 NB2); 
    'MESS' 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE LE'; 
    'MESS' '         MAILLAGE ET LE FRONT DE LA FISSURE'; 
    'QUITTER' CH_THETA; 
 'FINSI'; 
 IFOND = 'TYPE' SUPTAB.'FRONT_FISSURE'; 
 'SI' ((&DIME 'EGA' 3) 'ET' ('NON' ICOQU)); 
   'SI' ('EGA' IFOND 'POINT   '); 
     'MESS' 'ERREUR : EN 3D AVEC ELEMENTS MASSIFS LE FRONT'; 
     'MESS' '         DE LA FISSURE DOIT ETRE UNE LIGNE'; 
     'QUITTER' CH_THETA; 
   'FINSI'; 
 'FINSI'; 
 'SI' ((&DIME 'EGA' 2) 'OU' ICOQU); 
   'SI' ('NON' ('EGA' IFOND 'POINT   ')); 
     'MESS' 'ERREUR : EN 2D OU ELEMENTS EN COQUE MINCE LE'; 
     'MESS' '         FOND DE LA FISSURE DOIT ETRE UN POINT'; 
     'QUITTER' CH_THETA; 
   'FINSI'; 
 'FINSI'; 
 NB1 = 'NBNO' ('CHAN' FISSURE 'POI1'); 
 NB2 = 'NBNO' ('CHAN' (SUPTAB.'FRONT_FISSURE' 'ET' FISSURE) 'POI1'); 
 'SI' ('NEG' NB1 NB2); 
    'MESS' 'ERREUR : IL Y A DES NOEUDS DOUBLES ENTRE LE FRONT'; 
    'MESS' '         DE LA FISSURE ET LA FISSURE ELLE MEME'; 
    'QUITTER' CH_THETA; 
 'FINSI'; 
 **** 
 'SI' ('NON' ('EXIST' SUPTAB 'COUCHE')); 
    'MESS' 'ERREUR : ON VEUT LE NOMBRE DE COUCHES D ELEMENTS'; 
    'MESS' '         AUTOUR DE LA FISSURE QUI SE DEPLACE'; 
    'MESS' '         POUR SIMULER LA PROPAGATION DE LA FISSURE'; 
    'QUITTER' CH_THETA; 
 'SINON'; 
    COUCHE = SUPTAB.'COUCHE' ; 
 'FINSI'; 
 **** 
 ICOUDE = FAUX; 
 ITUYAU = FAUX; 
 'SI' (('EXISTE' SUPTAB 'CHPOINT_TRANSFORMATION') 'OU' 
       ('EXISTE' SUPTAB 'OPERATEUR')); 
    ICOUDE = VRAI; 
   'SI' ('NON' ('EXIST' SUPTAB 'CHPOINT_TRANSFORMATION')); 
     'MESS' 'ERREUR : ON VEUT LE CHAMP/POINT QUI TRANSFORME'; 
     'MESS' '         LA COUDE EN UN TUYAUTERIE DROITE.'; 
     'QUITTER' CH_THETA; 
   'FINSI'; 
  'SI' ('NON' ('EXIST' SUPTAB 'OPERATEUR')); 
     'MESS' 'ERREUR : ON VEUT LE NOM DE L OPERATEUR A UTILISER'; 
     'MESS' '         POUR LA TRANSFORMATION DE LA COUDE. '; 
     'QUITTER' CH_THETA; 
   'SINON'; 
      OPER1 = 'MOT' SUPTAB.'OPERATEUR'; 
   'FINSI'; 
 'FINSI'; 
 **** 
 'SI' ('NON' ('EXISTE' SUPTAB 'POINT_3')); 
   'SI' (('EXISTE' SUPTAB 'POINT_1') 'OU' 
         ('EXISTE' SUPTAB 'POINT_2') 'OU' ICOUDE); 
     'SI' ('NEG' &DIME 3); 
        'MESS' 'ERREUR : DONNEES IMCOMPATIBLES. CONSULTEZ LA NOTICE'; 
        'QUITTER' CH_THETA; 
     'FINSI'; 
      ITRAN = FAUX; IROTA = VRAI; 
     'SI' (('NON' ('EXIST' SUPTAB 'POINT_1')) 'OU' 
           ('NON' ('EXIST' SUPTAB 'POINT_2'))); 
        'MESS' 'ERREUR : ON VEUT LES POINTS POUR CONSTITUER L AXE'; 
        'MESS' '         PERPENDICULAIRE A LA SECTION FISSUREE.'; 
        'QUITTER' CH_THETA; 
     'SINON'; 
         POINT_1 = SUPTAB.'POINT_1'; 
         POINT_2 = SUPTAB.'POINT_2'; 
     'FINSI'; 
   'FINSI'; 
 'FINSI'; 
 **** 
 'SI' ('EXISTE' SUPTAB 'POINT_3'); 
    'SI' (('NON' ('EXIST' SUPTAB 'POINT_1')) 'OU' 
          ('NON' ('EXIST' SUPTAB 'POINT_2'))); 
       'MESS' 'ERREUR : ON VEUT LES POINTS POUR CONSTITUER L AXE'; 
       'MESS' '         PERPENDICULAIRE A LA SECTION FISSUREE.'; 
       'QUITTER' CH_THETA; 
    'SINON'; 
      'SI' ('NEG' &DIME 3); 
         'MESS' 'ERREUR : DONNEES IMCOMPATIBLES. CONSULTEZ LA NOTICE'; 
         'QUITTER' CH_THETA; 
      'FINSI'; 
       ITUYAU = VRAI; 
       PAXEZ1 = SUPTAB.'POINT_1'; 
       PAXEZ2 = SUPTAB.'POINT_2'; 
       PAXEZ3 = SUPTAB.'POINT_3'; 
    'FINSI'; 
 'FINSI'; 
 **** 
 'SI' ('EXISTE' SUPTAB 'PCENTRE'); 
   'SI' ('NEG' &DIME 2); 
      'MESS' 'ERREUR : DONNEES IMCOMPATIBLES. CONSULTEZ LA NOTICE'; 
      'QUITTER' CH_THETA; 
   'FINSI'; 
    ITRAN = FAUX; IROTA = VRAI; 
    PCENTRE = SUPTAB.'PCENTRE'; 
 'FINSI'; 
 *------------------------------------------------* 
 *--- QUELQUES MOTS POUR SIMPLIFIER L'ECRITURE ---* 
 *------------------------------------------------* 
 E = 'MOT' 'EXCO'; C = 'MOT' 'CHAI'; S = 'MOT' 'SCAL'; 
 MU1 = 'MOT' 'UX'; MU2 = 'MOT' 'UY'; MU3 = 'MOT' 'UZ'; 
 MF1 = 'MOT' 'FX'; MF2 = 'MOT' 'FY'; MF3 = 'MOT' 'FZ'; 
 'SI' ('EGA' MOTAX &MODE) ; 
    MU1 = 'MOT' 'UR'; MU2 = 'MOT' 'UZ'; MU3 = 'MOT' 'UT'; 
    MF1 = 'MOT' 'FR'; MF2 = 'MOT' 'FZ'; 
 'FINSI'; 
 TABUTIL = TABL; 
 ****************************************** 
 'SI' ((&DIME 'EGA' 3) 'ET' ('NON' ICOQU)); 
 ****************************************** 
    TABUTIL.'DIRECTION' = TABL; 
    TMAIL = 'TABLE'; TMBOUGER = 'TABLE'; TVECTEUR = 'TABLE'; 
    TPFISS = 'TABLE'; TTETA = 'TABLE'; 
    FONDFISS = ORDO (SUPTAB.'FRONT_FISSURE') ; 
    NP = 'NBNO' FONDFISS ; 
    PINIT = FONDFISS 'POIN' 'INIT' ; 
    PFINA = FONDFISS 'POIN' 'FINA' ; 
 *--------------------------------------------------* 
 * On veut savoir si une seule ou toutes les 2 levres 
 * de la fissure ont t modelisees 
 * Si 1 levre modelisee : XMULT=2 et ICOS1=FAUX 
 * Si 2 levres modelisees : XMULT=1 et ICOS1=VRAI 
 *--------------------------------------------------* 
    PFISS = PINIT; CC = FONDFISS 'ELEM' 'APPU' 'LARG' PFISS; 
    VCUB = MAILLAGE 'ELEM' 'APPUYE' 'LARG' PFISS; 
    SURF1 = ('ENVE' VCUB) 'ELEM' 'APPUYE' 'LARG' PFISS; 
    SURF1 = SURF1 'DIFF' (SURF1 'ELEM' 'APPU' 'STRI' FISSURE); 
    PP2 = 'POINT' 2 CC; 
   'SI' ('EGA' ('NBNO' SURF1) ('NBNO' (SURF1 'ET' PP2))); 
      SURF2 = SURF1 'ELEM' 'APPU' 'LARG' PP2; 
     'SI' ('NBEL' SURF2 '>' 2); 
        SURF2 = SURF1 'ELEM' 'APPU' 'LARG' ('POINT' 1 FONDFISS); 
     'FINSI'; 
      SURF1 = SURF1 'DIFF' SURF2; 
   'FINSI'; 
    FISS1 = ('CONT' SURF1) 'ELEM' 'APPU' 'LARG' PFISS; 
    FISS1 = 'ORDO' FISS1; 
    P1 = 'POINT' FISS1 'INIT'; P2 = 'POINT' FISS1 'FINA'; 
    V1 = 'MOIN' PFISS P1; V2 = 'MOIN' PFISS P2; 
    COS1 = ('PSCA' V1 V2) / (('NORM' V1)*('NORM' V2)); 
    ICOS1 = COS1 '>' ('COS' 120.); 
   'SI' ICOS1; 
      X1 Y1 Z1 = 'COOR' P1; X2 Y2 Z2 = 'COOR' P2; 
      POINSF = ((X1 + X2)/2.) ((Y1 + Y2)/2.) ((Z1 + Z2)/2.); 
   'SINON'; 
      POINSF = P1; 
     'SI'  ('NEG' ('NBNO' FISSURE) ('NBNO' (FISSURE 'ET' POINSF))); 
         POINSF = P2; 
     'FINSI'; 
   'FINSI'; 
 * 
    XMULT = 2.; 
 *MC 06/07/98 : test sur le numro du noeud plutt que 
 *              sur la proximit de ceux-ci 
   'SI' (('NEG' ('NOEU' P1) ('NOEU' PFISS)) 'ET' 
         ('NEG' ('NOEU' P2) ('NOEU' PFISS)) 'ET' ICOS1); 
      XMULT = 1.; 
   'FINSI'; 
   
 *---------------------------------------------------------* 
 * On determine le support du mouvement de la fissure : MAIL 
 * et le maillage qui se deplace : MBOUGER 
 *---------------------------------------------------------* 
    MAILVOL = FONDFISS; MBOUGVOL = FONDFISS; 
   'REPETER' MAILV (COUCHE + 1) ; 
      MAILVOL = MAILLAGE 'ELEM' 'APPUYE' 'LARG' MAILVOL ; 
     'SI' ('EGA' &MAILV COUCHE); MBOUGVOL = MAILVOL; 'FINSI'; 
   'FIN' MAILV ; 
 * 
   'REPETER' BBCC0 2; 
      'SI' ('EGA' &BBCC0 1); SURF1 = PINIT; N1 = 2; N2 = 1; 'FINSI'; 
      'SI' ('EGA' &BBCC0 2); SURF1 = PFINA; N1 = 1; N2 = 2; 'FINSI'; 
       CC = FONDFISS 'ELEM' 'APPU' 'LARG' SURF1; 
      'REPETER' BSURF1 (COUCHE + 1); 
         VCUB = MAILLAGE 'ELEM' 'APPUYE' 'LARG' SURF1 ; 
         PP2 = 'POINT' N1 CC; 
 * MC 19/12/96 : Modif pour fissure non dbouchante 
        'SI' ('EGA' &BSURF1 1); SURF1P = PP2; 'FINSI'; 
         VCUB = 'INTE' VCUB (MAILLAGE 'ELEM' 'APPUYE' 'LARG' SURF1P); 
         SURF1 = ('ENVE' VCUB) 'ELEM' 'APPUYE' 'LARG' SURF1 ; 
         SURF1P = (('ENVE' VCUB) 'DIFF' SURF1) 
                               'ELEM' 'APPUYE' 'LARG' SURF1P; 
 * Fin de modif 
         SURF1 = SURF1 'DIFF' (SURF1 'ELEM' 'APPU' 'STRI' FISSURE); 
        'SI' ('EGA' ('NBNO' SURF1) ('NBNO' (SURF1 'ET' PP2))); 
          'SI' (&BSURF1 '>' 1); 
             SURF1 = SURF1 'DIFF' SURF3; 
          'FINSI'; 
           SURF2 = SURF1 'ELEM' 'APPU' 'LARG' PP2; 
          'SI' (('NBEL' SURF2) '>' 2); 
             SURF2 = SURF1 'ELEM' 'APPU' 'LARG' ('POINT' N2 CC); 
          'FINSI'; 
           SURF1 = SURF1 'DIFF' SURF2; 
           CC = 'DIFF' ('CONT' ('ELEM' SURF2 1)) CC; 
           CC = 'ORDO' CC; 
           CC = 'ELEM' CC 2; 
          'SI' (&BSURF1 '>' 1); SURF3 = SURF2 'ET' SURF3; 'SINON'; 
             SURF3 = SURF2 ; 
          'FINSI'; 
        'FINSI'; 
      'FIN' BSURF1; 
      'SI' ('EGA' &BBCC0 1); 
         SURINI = PINIT; 
        'REPETER' BSURI1 (COUCHE + 1); 
           SURINI = SURF1 'ELEM' 'APPU' LARG SURINI; 
          'SI' ('EGA' &BSURI1 COUCHE); SURINIT1 = SURINI; 'FINSI'; 
        'FIN' BSURI1; 
      'FINSI'; 
      'SI' ('EGA' &BBCC0 2); 
         SURFIN = PFINA ; 
        'REPETER' BSURI2 (COUCHE + 1); 
           SURFIN = SURF1 'ELEM' 'APPU' LARG SURFIN; 
          'SI' ('EGA' &BSURI2 COUCHE); SURFINA1 = SURFIN; 'FINSI'; 
        'FIN' BSURI2; 
      'FINSI'; 
   'FIN' BBCC0; 
 * 
   'SI' ('EGA' COUCHE 0); NN = 1; 'SINON'; NN = 2; 'FINSI'; 
   'REPETER' BBCC1 NN; 
      TAB1 = TABLE; I = 0; 
     'SI' (&BBCC1 'EGA' 1); 
        TAB1.1 = SURINI; TAB1.NP = SURFIN; MAIL3D = MAILVOL; 
     'FINSI'; 
     'SI' (&BBCC1 'EGA' 2); 
        TAB1.1 = SURINIT1; TAB1.NP = SURFINA1; MAIL3D = MBOUGVOL; 
     'FINSI'; 
      TRANCH1 = MAIL3D 'ELEM' 'APPU' 'LARG' TAB1.1; 
      TRANCH2 = TRANCH1; TRANCHET = TRANCH1; 
     'SI' (('NBEL' FONDFISS) '>' 1); 
       'REPETER' BOURECU (('NBEL' FONDFISS) - 1) ; 
          I = I + 1 ; 
          TRANCH2 = (MAIL3D 'ELEM' 'APPU' 'LARG' TRANCHET) 
                    'DIFF' TRANCHET; 
          TRANCHET = TRANCHET 'ET' TRANCH2 ; 
          ENVEBI = 'DIFF' ('ENVE' TRANCH2) ('ENVE' TRANCH1); 
         'SI' ILIN ; 
            TAB1.(I + 1) = 'DIFF' ENVEBI (('ENVE' TRANCH2) 
                           'ET' ('ENVE' TRANCH1)) ; 
         'SINON' ; 
            TAB1.((2 * I) + 1) = 'DIFF' ENVEBI (('ENVE' TRANCH2) 
                                 'ET' ('ENVE' TRANCH1)) ; 
            POINTRAN = TRANCH1 'CHANGE' 'POI1' ; 
            POINBORD = (TAB1.((2 * I) - 1) 'ET' 
                        TAB1.((2 * I) + 1)) 'CHANGE' 'POI1'; 
            TAB1.(2 * I) = POINTRAN 'DIFF' POINBORD; 
         'FINSI' ; 
          TRANCH1 = TRANCH2; 
       'FIN' BOURECU ; 
     'FINSI'; 
     'SI' (('NON' ILIN) 'ET' (NP '>' 2)); 
        POINTRAN = TRANCH2 'CHANGE' 'POI1'; 
        POINBORD = (TAB1.NP 'ET' TAB1.(NP - 2)) 'CHANGE' 'POI1'; 
        TAB1.(NP - 1) = POINTRAN 'DIFF' POINBORD ; 
     'FINSI'; 
     'SI' (&BBCC1 'EGA' 1); TMAIL = TAB1; 'FINSI'; 
     'SI' (&BBCC1 'EGA' 2); TMBOUGER = TAB1; 'FINSI'; 
   'FIN' BBCC1; 
 *-------------------------------------------* 
 * Recuperation des points du front de fissure 
 *-------------------------------------------* 
   FNUAGE = FONDFISS 'CHAN' 'POI1'; 
   I = 0; 
   'REPETER' BPF NP; 
      I = I + 1; 
      TPFISS.I = (('CHAN' 'POI1' TMAIL.I) 'ET' FNUAGE) 'DIFF' 
                 (('CHAN' 'POI1' TMAIL.I) 'DIFF' FNUAGE); 
      TPFISS.I = 'POIN' 1 TPFISS.I; 
     'SI' ('EGA' COUCHE 0); TMBOUGER.I = TPFISS.I; 'FINSI'; 
   'FIN' BPF; 
 *--------------------------------------* 
 * Transformation du tuyau en plaque dans 
 * le cas d une fissure non traversante 
 *--------------------------------------* 
 'SI' ITUYAU; 
    'DEPLACE' MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3; 
 'FINSI'; 
 *--------------------------------------------------* 
 * Recuperation de deux points de SURINI et de SURFIN 
 *--------------------------------------------------* 
    PI1 = ('DIFF' ('CHAN' 'POI1' ('CONT' SURINI)) 
          ('MANU' 'POI1' PINIT)) 'POIN' 1; 
 * 
    PF1 = ('DIFF' ('CHAN' 'POI1' ('CONT' SURFIN)) 
          ('MANU' 'POI1' PFINA)) 'POIN' 1; 
 *----------------------------------------------------------* 
 * Recuperation des vecteurs normaux 
 * La norme de ces vecteurs est du meme ordre de grandeur que 
 * la mesure d un segment du front. Pour qu une translation avec 
 * un de ces vecteurs corresponde a une avance infinitesimale, 
 * on divise chaque vecteur par 100 fois la mesure d un segment 
 *----------------------------------------------------------* 
    VNPF = (POINSF 'MOIN' TPFISS.1) 'PVEC' (POINSF 'MOIN' TPFISS.2); 
    VNPF = VNPF / ('NORM' VNPF) ; 
    VECT11 = (TPFISS.2 'MOINS' TPFISS.1) 'PVEC' VNPF; 
    PI3 = PINIT 'PLUS' VNPF; PF3 = PFINA 'PLUS' VNPF; 
    VPLAN1 = (PI1 'MOINS' PINIT) 'PVEC' (PINIT 'MOINS' PI3); 
   'SI' ('EGA' ('PSCA' VPLAN1 VECT11) 0. 1.E-10); 
      TVECTEUR.1 = VECT11 ; 
   'SINON'; 
      P11 = TPFISS.1 'PLUS' VECT11; 
      P12 = P11 'SYME' 'PLAN' PI1 PINIT PI3 ; 
      VECT12 = P12 'MOIN' TPFISS.1; 
      TVECTEUR.1 = VECT11 'PLUS' VECT12 ; 
   'FINSI'; 
    TVECTEUR.1 = TVECTEUR.1 / 100. ; 
    VECT21 = (TPFISS.NP 'MOINS' TPFISS.(NP - 1)) 'PVEC' VNPF ; 
    VPLAN2 = (PF1 'MOINS' PFINA) 'PVEC' (PFINA 'MOINS' PF3); 
   'SI' ('EGA' ('PSCA' VPLAN2 VECT21) 0. 1.E-10); 
      TVECTEUR.NP = VECT21 ; 
   'SINON'; 
      P21 = TPFISS.NP 'PLUS' VECT21; 
      P22 = P21 'SYME' 'PLAN' PF1 PFINA PF3 ; 
      VECT22 = P22 'MOIN' TPFISS.NP; 
      TVECTEUR.NP = VECT21 'PLUS' VECT22 ; 
   'FINSI'; 
    TVECTEUR.NP = TVECTEUR.NP / 100. ; 
    I = 1 ; 
   'SI' (NP > 2) ; 
     'REPETER' BVECT (NP - 2) ; 
        I = I + 1 ; 
        VTFF1 = TPFISS.I 'MOINS' TPFISS.(I - 1) ; 
        VNFF1 = VTFF1 'PVECT' VNPF ; 
        VTFF2 = TPFISS.(I + 1) 'MOINS' TPFISS.I ; 
        VNFF2 = VTFF2 'PVECT' VNPF ; 
        TVECTEUR.I = .5 * (VNFF1 'PLUS' VNFF2) ; 
        TVECTEUR.I = TVECTEUR.I / 100. ; 
     'FIN' BVECT ; 
   'FINSI' ; 
 *-------------------------------------- 
 * Vecteur et maillage de support global 
 * en 3D avec des lments massifs 
 *-------------------------------------- 
    PNOR1 = PROG; 
   'REPETER' BNOR1 NP; 
      PNOR1 = PNOR1 'ET' ('PROG' ('NORM' TVECTEUR.&BNOR1)); 
   'FIN' BNOR1; 
    MINOR1 = 'MINI' PNOR1; 
   'REPETER' BVGLO NP; 
      N1 = MINOR1 / ('EXTR' PNOR1 &BVGLO) ; 
      X1 = N1 * ('COOR' 1 (TVECTEUR.&BVGLO)) ; 
      Y1 = N1 * ('COOR' 2 (TVECTEUR.&BVGLO)) ; 
      Z1 = N1 * ('COOR' 3 (TVECTEUR.&BVGLO)) ; 
     'SI' (&BVGLO 'EGA' 1); 
        TVECTEUR.(NP + 1) = 'MANU' 'CHPO' (TMAIL.&BVGLO) 
                          3 MU1 X1 MU2 Y1 MU3 Z1 'NATURE' 'DIFFUS'; 
     'SINON'; 
        TVECTEUR.(NP + 1) = TVECTEUR.(NP + 1) 'ET' ('MANU' 'CHPO' 
           (TMAIL.&BVGLO) 3 MU1 X1 MU2 Y1 MU3 Z1 'NATURE' 'DIFFUS'); 
     'FINSI'; 
   'FIN' BVGLO; 
 * 
    TPFISS.(NP + 1) = SUPTAB.'FRONT_FISSURE'; 
    TMBOUGER.(NP + 1) = SUPTAB.'FRONT_FISSURE'; 
   'SI' (COUCHE '>' 0); 
     'REPETER' MBOUG COUCHE ; 
        TMBOUGER.(NP + 1) = 'ELEM' MAILLAGE 'APPUYE' 
                            'LARG' TMBOUGER.(NP + 1) ; 
     'FIN' MBOUG ; 
   'FINSI'; 
    TMAIL.(NP + 1) = 'ELEM' MAILLAGE 'APPU' 
                     'LARG' TMBOUGER.(NP + 1) ; 
 *-----------------------------------------* 
 * Transformation d'une plaque en tuyau 
 * dans le cas d une fissure non traversante 
 *-----------------------------------------* 
 'SI' ITUYAU; 
     'DEPLACE' MAILLAGE 'COOR' 'CART'; 
 'FINSI'; 
 ******** 
 'FINSI'; 
 ******** 
   
 ********************************* 
 'SI' (('EGA' &DIME 2) 'OU' ICOQU); 
 ********************************* 
 *----------------------------------------------* 
 *-- On determine la direction de propagation --* 
 *-- et le support geometrique du champ THETA --* 
 *----------------------------------------------* 
    PFISS = SUPTAB.'FRONT_FISSURE'; 
    FISS1 = FISSURE 'ELEM' 'APPU' 'LARG' PFISS; 
    FISS1 = 'ORDO' FISS1; 
    P1 = 'POINT' FISS1 'INIT'; P2 = 'POINT' FISS1 'FINA'; 
 *MC 06/07/98 : test sur le numro du noeud plutt que 
 *              sur la proximit de ceux-ci 
   'SI' (('NEG' ('NOEU' P1) ('NOEU' PFISS)) 'ET' 
         ('NEG' ('NOEU' P2) ('NOEU' PFISS))); 
      XMULT = 1.; 
      MESU1 = 'MESU' ('DROI' 1 PFISS P1); 
      MESU2 = 'MESU' ('DROI' 1 PFISS P2); 
      XX1 = (('COOR' 1 PFISS) - ('COOR' 1 P1)) / MESU1; 
      XX2 = (('COOR' 1 PFISS) - ('COOR' 1 P2)) / MESU2; 
      YY1 = (('COOR' 2 PFISS) - ('COOR' 2 P1)) / MESU1; 
      YY2 = (('COOR' 2 PFISS) - ('COOR' 2 P2)) / MESU2; 
      XX1 = (XX1 + XX2) / 2.; YY1 = (YY1 + YY2) / 2.; 
     'SI' ('EGA' &DIME 3); 
        ZZ1 = (('COOR' 3 PFISS) - ('COOR' 3 P1)) / MESU1; 
        ZZ2 = (('COOR' 3 PFISS) - ('COOR' 3 P2)) / MESU2; 
        ZZ1 = (ZZ1 + ZZ2) / 2.; 
     'FINSI'; 
   'SINON'; 
      XMULT = 2.; 
 *MC 06/07/98 : test sur le numro du noeud plutt que 
 *              sur la proximit de ceux-ci 
     'SI' ('EGA' ('NOEU' P2) ('NOEU' PFISS)); P2 = P1; 'FINSI'; 
      MESU1 = 'MESU' ('DROI' 1 PFISS P2); 
      XX1 = (('COOR' 1 PFISS) - ('COOR' 1 P2)) / MESU1; 
      YY1 = (('COOR' 2 PFISS) - ('COOR' 2 P2)) / MESU1; 
     'SI' ('EGA' &DIME 3); 
        ZZ1 = (('COOR' 3 PFISS) - ('COOR' 3 P2)) / MESU1; 
     'FINSI'; 
   'FINSI'; 
   'SI' ('EGA' &DIME 2); VECTEUR = (XX1 YY1); 'FINSI'; 
   'SI' ('EGA' &DIME 3); VECTEUR = (XX1 YY1 ZZ1); 'FINSI'; 
    NP = 0 ; 
    MBOUGER = SUPTAB.'FRONT_FISSURE'; 
   'SI' (COUCHE '>' 0); 
     'REPETER' MBOUG COUCHE ; 
        MBOUGER = 'ELEM' MAILLAGE 'APPUYE' 'LARG' MBOUGER ; 
     'FIN' MBOUG ; 
   'FINSI'; 
    MAIL = 'ELEM' MAILLAGE 'APPU' 'LARG' MBOUGER ; 
 ******* 
 'FINSI' ; 
 ******* 
   
 *--------------------------------------------* 
 * Configuration initiale. Il ne faut pas la -* 
 *  placer avec la determination de VECTEUR --* 
 *--------------------------------------------* 
 CONF0 = 'FORM'; 
 *-----------------------------------------------* 
 * Boucle sur les noeuds du front de la fissure -* 
 *-----------------------------------------------* 
 N = 0 ; 
 'REPETER' PROTETA (NP + 1); 
 N = N + 1 ; 
 'SI' (('EGA' &DIME 3) 'ET' ('NON' ICOQU)); 
    MAIL = TMAIL.N ; PFISS = TPFISS.N; 
    MBOUGER = TMBOUGER.N; VECTEUR = TVECTEUR.N; 
 'FINSI'; 
 *-------------------------------------------------* 
 *----- Valeur initiale pour le vecteur THETA -----* 
 *-------------------------------------------------* 
 TETA = 'MANU' 'CHPO' MAIL 2 MU1 0. MU2 0. 'NATURE' 'DIFFUS' ; 
 'SI' ((&DIME 'EGA' 3)) ; 
    TETA = TETA + ('MANU' 'CHPO' MAIL 1 MU3 0. 'NATURE' 'DIFFUS'); 
 'FINSI' ; 
 *-------------------------------------------------------------* 
 * Donnees pour le calcul de l accroissement d aire de fissure * 
 *-------------------------------------------------------------* 
 XAIRE = 1.; 
 'SI' ICOQU; XAIRE = SUPTAB.'EPAISSEUR'; 'FINSI'; 
 'SI' ('EGA' MOTAX &MODE); 
    XAIRE = 2. * VALPI * ('COOR' 1 PFISS); 
 'FINSI'; 
 * Si 3D, on recupere la partie du plan de fissure proche 
 * du point avance pour calculer l accroissement d aire 
 'SI' (('EGA' &DIME 3) 'ET' ('NON' ICOQU)); 
    PLFISS = 'ELEM' FISSURE APPUY LARG MBOUGER; 
    MODFIS = 'MODE' PLFISS 'MECANIQUE' 'ELASTIQUE'; 
    CHFIS1 = 'MANU' 'CHPO' FISSURE 1 'SCAL' 1.; 
    CHFIS1 = 'CHAN' 'CHAM' CHFIS1 MODFIS 'STRESSES'; 
    XAIREI = 'INTG' CHFIS1 MODFIS; 
 * L aire doit correspondre a une seule levre de fissure 
 * Si les deux levres sont modelisees, on divise l aire par 2 
   'SI' ICOS1; XAIREI = XAIREI / 2.; 'FINSI'; 
 'FINSI'; 
 *--------------------------------------------------------* 
 *---- THETA gnr par la diffrence de coordonnes -----* 
 *--------------------------------------------------------* 
 'SI' (&DIME 'EGA' 2); XX0 YY0 = 'COOR' MAIL; 'FINSI'; 
 'SI' (&DIME 'EGA' 3); XX0 YY0 ZZ0 = 'COOR' MAIL; 'FINSI'; 
 *- Translation de la fissure avec une vecteur normalise -* 
 'SI' ITRAN ; 
   'SI' ITUYAU; 
      'DEPLACE' MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3; 
   'FINSI'; 
   'DEPLACE' 'PLUS' MBOUGER VECTEUR; 
   'SI' ITUYAU; 
     'DEPLACE' MAILLAGE 'COOR' 'CART' ; 
   'FINSI'; 
   'SI' (&DIME 'EGA' 2); XX1 YY1 = 'COOR' MAIL; 'FINSI'; 
   'SI' (&DIME 'EGA' 3); 
      XX1 YY1 ZZ1 = 'COOR' MAIL; 
     'SI' ('NON' ICOQU); 
        XAIREF = 'INTG' CHFIS1 MODFIS; 
       'SI' ICOS1; XAIREF = XAIREF / 2.; 'FINSI'; 
     'FINSI'; 
   'FINSI'; 
   'SI' ITUYAU; 
      'DEPLACE' MAILLAGE 'COOR' 'CYLI' PAXEZ1 PAXEZ2 PAXEZ3; 
   'FINSI'; 
   'DEPLACE' 'MOIN' MBOUGER VECTEUR ; 
   'SI' ITUYAU; 
      'DEPLACE' MAILLAGE 'COOR' 'CART'  ; 
   'FINSI'; 
    TETAT = ('NOMC' MU1 (XX1 - XX0)) + 
            ('NOMC' MU2 (YY1 - YY0)); 
   'SI' (&DIME 'EGA' 3); 
      TETAT = TETAT + ('NOMC' MU3 (ZZ1 - ZZ0)); 
     'SI' ('NON' ICOQU); XAIRE = XAIREF - XAIREI; 'FINSI'; 
   'FINSI' ; 
    TETA = (TETAT * XMULT / XAIRE) + TETA ; 
 'FINSI' ; 
 *----- Rotation de la fissure selon le point ou l'axe donn 
 * Pour que la rotation effectuee corresponde a une avance 
 * infinitesimale, on choisit un angle de rotation de 0.01 degre 
 'SI' IROTA ; 
    ANG1 = 1.D-2 ; 
   'SI' ('EGA' &DIME 2); 
     'DEPLACE' 'TOUR' MBOUGER ANG1 PCENTRE ; 
      XX1 YY1 = 'COOR' MAIL ; 
     'DEPLACE' 'TOUR' MBOUGER (0. - ANG1) PCENTRE ; 
      TETAR = ('NOMC' MU1 (XX1 - XX0)) + 
              ('NOMC' MU2 (YY1 - YY0)) ; 
      X1 = 'EXTR' TETAR MU1 PFISS ; 
      Y1 = 'EXTR' TETAR MU2 PFISS ; 
      NOR1 = ('NORM' (X1 Y1)) + 1.D-20 ; 
      TETAR = TETAR / NOR1 ; 
   'FINSI'; 
   'SI' ('EGA' &DIME 3); 
     'SI' ('NON' ICOUDE); 
       'DEPLACE' 'TOUR' MBOUGER ANG1 POINT_1 POINT_2 ; 
        XX1 YY1 ZZ1 = 'COOR' MAIL ; 
       'SI' ('NON' ICOQU); 
          XAIREF = 'INTG' CHFIS1 MODFIS; 
         'SI' ICOS1; XAIREF = XAIREF / 2.; 'FINSI'; 
       'FINSI'; 
       'DEPLACE' 'TOUR' MBOUGER ANG1 POINT_2 POINT_1 ; 
     'SINON'; 
       'DEPLACE' OPER1 MAILLAGE SUPTAB.'CHPOINT_TRANSFORMATION' ; 
       'DEPLACE' 'TOUR' MBOUGER ANG1 POINT_1 POINT_2 ; 
       'DEPLACE' OPER1 MAILLAGE (-1.*(SUPTAB.'CHPOINT_TRANSFORMATION')); 
        XX1 YY1 ZZ1 = 'COOR' MAIL ; 
       'SI' ('NON' ICOQU); 
          XAIREF = 'INTG' CHFIS1 MODFIS; 
         'SI' ICOS1; XAIREF = XAIREF / 2.; 'FINSI'; 
       'FINSI'; 
       'DEPLACE' OPER1 MAILLAGE (SUPTAB.'CHPOINT_TRANSFORMATION'); 
       'DEPLACE' 'TOUR' MBOUGER ANG1 POINT_2 POINT_1 ; 
       'DEPLACE' OPER1 MAILLAGE (-1.*(SUPTAB.'CHPOINT_TRANSFORMATION')); 
     'FINSI'; 
      TETAR = ('NOMC' MU1 (XX1 - XX0)) + 
              ('NOMC' MU2 (YY1 - YY0)) + 
              ('NOMC' MU3 (ZZ1 - ZZ0)) ; 
     'SI' ('NON' ICOQU); 
        XAIRE = XAIREF - XAIREI; 
     'SINON'; 
        X1 = 'EXTR' TETAR MU1 PFISS ; 
        Y1 = 'EXTR' TETAR MU2 PFISS ; 
        Z1 = 'EXTR' TETAR MU3 PFISS ; 
        NOR1 = ('NORM' (X1 Y1 Z1)) + 1.D-20 ; 
        TETAR = TETAR / NOR1 ; 
     'FINSI'; 
   'FINSI' ; 
    TETA = (TETAR * XMULT / XAIRE) + TETA ; 
 'FINSI'; 
 *--------------------------------------------* 
 * Objet util a garder dans la table TABUTIL -* 
 *--------------------------------------------* 
 'SI' (('EGA' &DIME 2) 'OU' ICOQU); 
    TABUTIL.'DIRECTION' = VECTEUR; 
 'FINSI'; 
 'SI' (('EGA' &DIME 3) 'ET' ('NON' ICOQU)); 
   'SI' (N '<EG' NP); 
      TTETA.(TPFISS.N) = TETA ; 
      TABUTIL.'DIRECTION'.(TPFISS.N) = VECTEUR; 
   'SINON'; 
      TTETA.'GLOBAL' = TETA ; 
      TABUTIL.'DIRECTION'.'GLOBAL' = VECTEUR; 
   'FINSI'; 
 'FINSI'; 
 'FIN' PROTETA; 
 *------------------------------------------------------* 
 * Fin de boucle sur les noeuds de front de la fissure -* 
 *------------------------------------------------------* 
 'SI' (('EGA' &DIME 3) 'ET' ('NON' ICOQU)); 
    TETA = TTETA; 
 'FINSI'; 
 *-------------------------------------------------------------* 
 * La configuration peut etre modifiee par DEPL. La directive -* 
 * suivante nous permet de retrouver configuration initiale ---* 
 *-------------------------------------------------------------* 
 'FORM' CONF0; 
 *-------------------------------* 
 * Fin de la procedure CH_THETA -* 
 *-------------------------------* 
 * rendre compatible les chpoint 
 *mess ' type de teta '  ( 'TYPE' TETA); 
 'SI' ( 'EXIS' SUPTAB  'MODELE'); 
   MOO=SUPTAB . 'MODELE'; 
 'SINON'; 
   MOO=SUPTAB .'SOLUTION_PASAPAS' .'MODELE'; 
 'FINSI'; 
 MOO = EXTR MOO 'FORM' 'MECANIQUE' ; 
 'SI' ( 'EGA' ('TYPE' TETA) 'CHPOINT  '); 
 teta='CFND' teta MOO; 
 'SINON'; 
   'REPE' BOO (NP - 1); 
    IIP=TPFISS.&boo; 
    TETA.IIP= 'CFND' TETA.IIP  MOO; 
    'FIN' BOO; 
    TETA.'GLOBAL'= 'CFND' TETA.'GLOBAL'  MOO; 
 'FINSI'; 
   
 *------------------------------------------------------* 
 * Dans TABUTIL on ajoute les chpoint de DIRECTION     -* 
 *------------------------------------------------------* 
   
 * VECTEUR 1 
 si (EGA (TYPE TETA) 'CHPOINT  '); 
   VECTEUR1 = TETA ; 
 sino; 
   VECTEUR1 = TETA . 'GLOBAL'; 
 fins; 
 VECTEUR1= REDU VECTEUR1 (SUPTAB.'FRONT_FISSURE'); 
 * VECTEUR1 = VECTEUR1 / (NORM VECTEUR1); 
   
 * Recuperation des noms de composantes du deplacement dans le MODELE 
   NCOMPDEP = EXTR SUPTAB.'MODELE' 'DEPL'; 
   NCOMPFOR = EXTR SUPTAB.'MODELE' 'FORC'; 
   
   NVECT1 = PSCA VECTEUR1 VECTEUR1 NCOMPDEP NCOMPDEP; 
   
   VECTEUR1 = VECTEUR1 / (NVECT1**0.5); 
 TABUTIL . 'DIRECTION1' = VECTEUR1; 
   
 si(non ICOQU); 
   
 * VECTEUR 2 
   F1 = PRES 'MASS' MOO SUPTAB.'LEVRE_SUPERIEURE' 1.; 
   VECTEUR2 = REDU F1 (SUPTAB.'FRONT_FISSURE'); 
   VECTEUR2 = EXCO VECTEUR2 NCOMPFOR NCOMPDEP 'NOID'; 
 *  VECTEUR2 = VECTEUR2 / (NORM VECTEUR2); 
   
   NVECT2   = PSCA VECTEUR2 VECTEUR2 NCOMPDEP NCOMPDEP; 
   VECTEUR2 = VECTEUR2 / (NVECT2**0.5); 
   TABUTIL . 'DIRECTION2' = VECTEUR2; 
   
 * VECTEUR3 = VECTEUR1 pvec VECTEUR2 
 *   VECTEUR3 = ( ((exco VECTEUR1 'UY' 'UX') * (exco VECTEUR2 'UZ' 'UX')) 
 *           - ((exco VECTEUR1 'UZ' 'UX') * (exco VECTEUR2 'UY' 'UX')) ) 
 *        et ( ((exco VECTEUR1 'UZ' 'UY') * (exco VECTEUR2 'UX' 'UY')) 
 *           - ((exco VECTEUR1 'UX' 'UY') * (exco VECTEUR2 'UZ' 'UY')) ) 
 *        et ( ((exco VECTEUR1 'UX' 'UZ') * (exco VECTEUR2 'UY' 'UZ')) 
 *           - ((exco VECTEUR1 'UY' 'UZ') * (exco VECTEUR2 'UX' 'UZ')) ); 
   VECTEUR3 = ( * VECTEUR1 VECTEUR2 
    (mots 'UY' 'UZ' 'UX') (mots 'UZ' 'UX' 'UY') (mots 'UX' 'UY' 'UZ') ) 
            - ( * VECTEUR1 VECTEUR2 
    (mots 'UZ' 'UX' 'UY') (mots 'UY' 'UZ' 'UX') (mots 'UX' 'UY' 'UZ') ); 
   TABUTIL . 'DIRECTION3' = VECTEUR3; 
   
 fins; 
   
 'FINPROC' TETA TABUTIL; 
 * G_AUX     PROCEDUR  JB251061  20/11/04    21:17:45     10763 
 * ============================================================================= 
 *               PROCEDURE DE CONSTRUCTION DES CHAMPS AUXILIAIRES 
 *               POUR CALCULER LES FIC VIA LA PROCEDURE G_THETA 
 *               ------------------------------------------------ 
 * 
 * DESCRIPTION : CALCULE LES CHAMPS AUXILIAIRES NECESSAIRES A G_THETA POUR 
 *               DETERMINER LES FACTEURS D'INTENSITE DES CONTRAINTES VIA 
 *               L'OPTION 'DECOUPLAGE'; 
 * ============================================================================= 
 DEBP G_AUX SUPTAB*'TABLE' OBJUTI*'TABLE' BOOL*'TABLE' ; 
   
 * TABLE QUI CONTIENDRA LES CHAMPS AUXILIAIRES 
 CH_AUX = TABL ; 
   
 * OBJETS UTILES 
 ZER1 = MANU 'CHML' MOD_MEC_R 'SCAL' 0. 'TYPE' 'SCALAIRE' 'STRESSES' ; 
 DIR1 = OBJUTI.'DIRECTION1' ; 
 DIR2 = OBJUTI.'DIRECTION2' ; 
 DIR3 = OBJUTI.'DIRECTION3' ; 
 RIGTOT = OBJUTI.'RIGTOT' ; 
 MAT_INST = OBJUTI.'MAT_INST' ; 
 MODSUP = OBJUTI.'MODSUP' ; 
 MODINF = OBJUTI.'MODINF' ; 
 ELTETA = OBJUTI.'ELTETA' ; 
 M_FRONT = OBJUTI.'FRONT' ; 
 * AJOUT BP BT POUR LE CONTACT FROTTANT 
 SI BOOL.'FROT' ; 
         OBJCON = OBJUTI.'OBJCON' ; 
         MAILCON = OBJUTI.'MAILCON' ; 
 FINSI ; 
 * LISTMOT SCAL : 
 MTS1 = MOTS 'SCAL' ; 
 * LISTMOTS POUR LE DEPLACEMENT ET POUR LA FORCE : 
 * ON EXTRAIT LES GDIME PREMIERS MOTS CAR ON NE VEUT PAS DES ROTATIONS 
 * DANS LE CAS DES COQUES 
 MOD_MEC_R = OBJUTI.'MOD_MEC_R' ; 
 GDIME = OBJUTI.'DIMENSION' ; 
 UCOMP = EXTR (EXTR MOD_MEC_R 'DEPL') (LECT 1 PAS 1 GDIME) ; 
 FCOMP = EXTR (EXTR MOD_MEC_R 'FORC') (LECT 1 PAS 1 GDIME) ; 
 MU1 = EXTR UCOMP 1 ; MU2 = EXTR UCOMP 2 ; 
 MF1 = EXTR FCOMP 1 ; MF2 = EXTR FCOMP 2 ; 
 SI (EGA GDIME 3) ; 
         MF3 = EXTR FCOMP 3 ; 
 FINSI ; 
   
 ******************************************************************************* 
 ****************************** ETAPE 1 **************************************** 
 ******************************************************************************* 
   
 PM = SUPTAB.'FRONT_FISSURE' ; 
 SI ((EGA GDIME 3) ET (NON BOOL.'DANS')) ; 
         SI (NON BOOL.'COQ') ; 
                 PM = POIN PM 'INIT' ; 
         FINSI ; 
         SI (NON BOOL.'COQ') ; 
                 CL1 = BLOQ 'DEPL' M_FRONT ; 
         SINON ; 
                 CL1 = (BLOQ 'DEPL' M_FRONT) ET (BLOQ 'ROTA' M_FRONT) ; 
         FINSI ; 
 FINSI ; 
   
 SI (NON BOOL.'XFEM') ; 
 *       CAS ELEMENTS STANDARDS 
 *       CAS 2D 
         SI (EGA GDIME 2) ; 
 *               INCLINAISON DE LA FISSURE PAR RAPPORT A L'AXE GLOBAL 
                 XG0 YG0 = COOR PM ; 
                 SEG1 = ORDO (SUPTAB.'LEVRE_SUPERIEURE' ELEM 'APPU' 'LARG' PM) ; 
                 PINIFIN = (POIN SEG1 'INIT') ET (POIN SEG1 'FINA') ; 
                 P_SUP = POIN (DIFF PINIFIN ((VIDE 'MAILLAGE') ET PM)) 1 ; 
                 SEG1 = ORDO (SUPTAB.'LEVRE_INFERIEURE' ELEM 'APPU' 'LARG' PM) ; 
                 PINIFIN = (POIN SEG1 'INIT') ET (POIN SEG1 'FINA') ; 
                 P_INF = POIN (DIFF PINIFIN ((VIDE 'MAILLAGE') ET PM)) 1 ; 
                 XP1 YP1 = COOR P_SUP ; 
                 XP2 YP2 = COOR P_INF ; 
                 ALPHA1 = ATG (YG0 - ((YP1 + YP2)/2.)) (XG0 - ((XP1 + XP2)/2.)) ; 
 *               COORDONNEES DANS LE REPERE GLOBAL ET LOCAL 
                 XG1 YG1 = COOR ELTETA ; 
                 XL1 = ((XG1 - XG0)*(COS ALPHA1)) + ((YG1 - YG0)*(SIN ALPHA1)) ; 
                 YL1 = ((YG1 - YG0)*(COS ALPHA1)) - ((XG1 - XG0)*(SIN ALPHA1)) ; 
                 SI ((MESU ('DROI' 1 P_SUP P_INF)) < 1.E-10) ; 
                         L1 = SUPTAB.'LEVRE_SUPERIEURE' ELEM 'APPU' ELTETA ; 
                         C1 = MANU 'CHPO' L1 1 'SCAL' 1.E-10 ; 
                         L2 = SUPTAB.'LEVRE_INFERIEURE' ELEM 'APPU' ELTETA ; 
                         C2 = MANU 'CHPO' L2 1 'SCAL' -1.E-10 ; 
                         YL1 = YL1 + C1 + C2 ; 
                 FINSI ; 
 *               COORDONNEES CYLINDRIQUES RAY1 TETA1 (1.E-30 POUR EVITER ERREUR ATG 0 0) 
                 TETA1 = ATG YL1 (XL1 + 1.E-30) ; 
                 RAY1 = (((XL1*XL1) + (YL1*YL1))**0.5) + 1.E-10 ; 
                 M1 = ELTETA ELEM 'APPU' 'LARG' P_SUP ; 
                 M2 = ELTETA ELEM 'APPU' 'LARG' P_INF ; 
                 VA1 = XTY (MANU 'CHPO' M1 1 'SCAL' 1.) 
                                         (REDU YL1 M1) MTS1 MTS1 ; 
                 VA2 = XTY (MANU 'CHPO' M2 1 'SCAL' 1.) 
                                         (REDU YL1 M2) MTS1 MTS1 ; 
 *               ON INVERSE AFIN D'AVOIR YL1 > 0 POUR MODSUP ET < 0 POUR MODINF 
                 SI ((VA1 < 0.) ET (VA2 > 0.)) ; 
                         PPPP = P_SUP ;  P_SUP = P_INF ;   P_INF = PPPP ; 
                         MMDD = MODSUP ; MODSUP = MODINF ; MODINF = MMDD ; 
                 FINSI ; 
                 SI ((EGA XP1 XP2 1.E-10) ET (EGA YP1 YP2 1.E-10)) ; 
                         TETA_S = REDU TETA1 SUPTAB.'LEVRE_SUPERIEURE' ; 
                         TETA_F = REDU TETA1 SUPTAB.'LEVRE_INFERIEURE' ; 
                         TETA1 = TETA1 - TETA_S - TETA_F ; 
 *                       ON SE DEBROUILLE POUR AVOIR EXACTEMENT +/-180 SUR LEVRE SUP/INF 
                         SI ((VA1 > 0.) ET (VA2 < 0.)) ; 
                                 TETA1 = TETA1 + ((TETA_S*0.) + 180.) + ((TETA_F*0.) - 180.) ; 
                         SINON ; 
                                 TETA1 = TETA1 + ((TETA_F*0.) + 180.) + ((TETA_S*0.) - 180.) ; 
                         FINSI ; 
                 FINSI ; 
 *               VALEUR EN RADIAN 
                 TETA1RAD = TETA1*PI/180. ; 
                 SI BOOL.'DANS' ; 
                         M1 = EXTR MODSUP 'MAIL' ; 
                         M2 = EXTR MODINF 'MAIL' ; 
                         L1 = (CONT M1) ELEM 'APPU' (CONT M2) ; 
                         M1 = M1 ELEM 'APPU' 'STRI' ELTETA ; 
                         M2 = M2 ELEM 'APPU' 'STRI' ELTETA ; 
                         PM1 = (CHAN M1 'POI1') DIFF (CHAN L1 'POI1') ; 
                         PM2 = (CHAN M2 'POI1') DIFF (CHAN L1 'POI1') ; 
                 FINSI ; 
                 SI BOOL.'TRAC' ; 
                         TRAC RAY1 ELTETA 'TITR' 'RAY1' ; 
                         TRAC TETA1 ELTETA 'TITR' 'TETA1' (PROG -180. PAS 20. 180.) ; 
                 FINSI ; 
 *       CAS 3D 
         SINON ; 
                 MESS 'ON NE FAIT PAS ICI LE PASSAGE LOCAL GLOBAL EN 3D ...?' ; 
                 MESS 'ET ON NE CALULE PAS RAY1 TETA1 NON PLUS?' ; 
         FINSI ; 
 SINON ; 
 *       CAS XFEM 
         SI (EGA GDIME 2) ; 
 *               CAS 2D 
 *               ON RECUPERE LES LEVEL SET 
                 PSI1 = REDU SUPTAB.'PSI' ELTETA ; 
                 PHI1 = REDU SUPTAB.'PHI' ELTETA ; 
                 LV7  = (PSI1 NOMC 'UX') ET (PHI1 NOMC 'UY') ; 
                 GLV7 = CHAN (GRAD LV7 MOD_MEC_R) 'TYPE' 'SCALAIRE' ; 
 *               CE REPERE EST IL DIRECT? (SI OUI/NON, SDIR1=+/-1) 
                 GLV7PO = CHAN 'CHPO' MOD_MEC_R GLV7  'MOYE' ; 
                 XDIR1 = ((EXCO GLV7PO 'UX,X' 'SCAL') * (EXCO GLV7PO 'UY,Y')) 
                           - ((EXCO GLV7PO 'UX,Y' 'SCAL') * (EXCO GLV7PO 'UY,X')) ; 
                 XDIR1 = MAXI (RESU XDIR1) ; 
                 SDIR1 = SIGN XDIR1 ; 
 *               ANGLE ALPHA1 DE PASSAGE LOCAL -> GLOBAL 
                 NGPSI1 = ( ((EXCO GLV7 'UX,X' 'SCAL')**2) 
                                         + ((EXCO GLV7 'UX,Y' 'SCAL')**2) )**(-0.5) ; 
                 NGPHI1 = ( ((EXCO GLV7 'UY,X' 'SCAL')**2) 
                                         + ((EXCO GLV7 'UY,Y' 'SCAL')**2) )**(-0.5) ; 
                 COS1A = 0.5 * ( ( (EXCO GLV7 'UX,X' 'SCAL') * NGPSI1) 
                                 + (SDIR1 * ( (EXCO GLV7 'UY,Y' 'SCAL') * NGPHI1)) ) ; 
                 SIN1A = 0.5 * ( ( (EXCO GLV7 'UX,Y' 'SCAL') * NGPSI1) 
                                 - (SDIR1 * ( (EXCO GLV7 'UY,X' 'SCAL') * NGPHI1)) ) ; 
                 ALPHA1 = (MASQ SIN1A 'EGSUPE' 0.) * (ACOS COS1A) ; 
                 COSA2 = COS1A ** 2 ; 
                 SINA2 = SIN1A ** 2 ; 
                 SINCOSA = SIN1A * COS1A ; 
 *               REPERE LOCAL DE LA FISSURE 
                 XL1 = (NOMC PSI1 'SCAL') CHAN 'CHAM' MOD_MEC_R 'STRESSES' ; 
                 YL1 = (SDIR1 * (NOMC PHI1 'SCAL')) CHAN 'CHAM' MOD_MEC_R 'STRESSES' ; 
 *               COORDONNEES CYLINDRIQUES RAY1 TETA1 
                 TETA1 = CHAN (ATG YL1 (XL1 + 1.E-30)) 'TYPE' 'SCALAIRE' ; 
                 RAY1 = ((XL1**2) + (YL1**2))**0.5 ; 
                 RAY1 = CHAN RAY1 'TYPE' 'SCALAIRE' ; 
         SINON ; 
 *               CAS 3D 
                 MESS 'DECOUPLAGE 3D XFEM EN COURS DE DVPT...' ; 
 *               ON RECUPERE LES LEVEL SET 
                 PSI1 = REDU SUPTAB.'PSI' ELTETA ; 
                 PHI1 = REDU SUPTAB.'PHI' ELTETA ; 
                 LV7  = (PSI1 NOMC 'UX') ET (PHI1 NOMC 'UY') 
                         ET (MANU  'CHPO' ELTETA 1 'UZ  ' 0. 'NATURE' 'DIFFUS') ; 
                 GLV7 = CHAN (GRAD LV7 MOD_MEC_R) 'TYPE' 'SCALAIRE' ; 
                 SDIR1 = 1. ; 
 *               CREATION DE LA MATRICE DE ROTATION 
                 ROT1= (EXCO V1 (MOTS 'UX' 'UY' 'UZ') (MOTS 'UX,X' 'UY,X' 'UZ,X')) 
                                 ET (EXCO V2 (MOTS 'UX' 'UY' 'UZ') (MOTS 'UX,Y' 'UY,Y' 'UZ,Y')) 
                                 ET (EXCO V3 (MOTS 'UX' 'UY' 'UZ') (MOTS 'UX,Z' 'UY,Z' 'UZ,Z')) ; 
                 ROT1 = EXCO ROT1 
                                 (MOTS UX,X UX,Y UX,Z UY,X UY,Y UY,Z UZ,X UZ,Y UZ,Z) ; 
                 ROT1 = CHAN 'CHAM' ROT1 MOD_MEC_R 'STRESSES' 'GRADIENT' ; 
 *               REPERE LOCAL DE LA FISSURE 
                 XL1 = (NOMC PSI1 'SCAL') CHAN 'CHAM' MOD_MEC_R 'STRESSES' ; 
                 YL1 = (NOMC PHI1 'SCAL') CHAN 'CHAM' MOD_MEC_R 'STRESSES' ; 
 *               Coordonnees cylindriques RAY1 TETA1 
                 TETA1 = CHAN (ATG YL1 (XL1 + 1.D-30)) 'TYPE' 'SCALAIRE' ; 
                 RAY1 = ((XL1**2) + (YL1**2))**0.5 ; 
                 RAY1 = CHAN RAY1 'TYPE' 'SCALAIRE' ; 
         FINSI ; 
 FINSI ; 
   
   
   
 ******************************************************************************* 
 ****************************** ETAPE 2 **************************************** 
 ******************************************************************************* 
   
 NBMIXT = 2 ; 
 SI (EGA GDIME 3) ; 
         NBMIXT = 3 ; 
 FINSI ; 
   
 **** CONSTANTES MATERIAUX ************************** 
 CHAM1 = (EXCO 'YOUN' MAT_INST) ET (EXCO 'NU  ' MAT_INST) ; 
 SI (NON BOOL.'DANS') ; 
 *       CAS D UN MATERIAU HOMOGENE 
 *       on construit les champ auxilaires d'une solution d'un materiau 
 *       homogene => on prend les valeurs de E et nu en pointe de fissure 
         CHPO1 = CHAN 'CHPO' MOD_MEC_R CHAM1 ; 
         SI BOOL.'XFEM' ; 
                 CHPO1 = INT_COMP ELTETA CHPO1 (MANU 'POI1' PM) ; 
         FINSI ; 
         SI (EGA (TYPE PM) 'MAILLAGE') ; 
                 VYO_1 = (MAXI (RESU (EXCO CHPO1 'YOUN'))) / (NBNO PM) ; 
                 VNU_1 = (MAXI (RESU (EXCO CHPO1 'NU  '))) / (NBNO PM) ; 
         SINON ; 
                 VYO_1 = EXTR CHPO1 'YOUN' PM ; 
                 VNU_1 = EXTR CHPO1 'NU  ' PM ; 
         FINSI ; 
 *       Constante de Kolosov 
         SI (EGA GMODE 'PLANCONT') ; 
                 KAP_1 = (3. - VNU_1) / (1. + VNU_1) ; 
         SINON ; 
                 KAP_1 = (3. - (4. * VNU_1)) ; 
         FINSI ; 
 *       Module de cisaillement 
         MU_1 = VYO_1 / (2.*(1. + VNU_1)) ; 
 *       Constante C_MATE (= 1 / E^etoile) 
         SI (EGA GMODE 'PLANCONT') ; 
                 C_MATE = 1. / VYO_1 ; 
         SINON ; 
                 C_MATE = (1. - (VNU_1*VNU_1)) / VYO_1 ; 
         FINSI ; 
 SINON ; 
 *       CAS D UN BI-MATERIAU 
         CHPO1 = CHAN 'CHPO' MODSUP (REDU CHAM1 MODSUP) ; 
         VYO_1 = EXTR CHPO1 'YOUN' PM ; 
         VNU_1 = EXTR CHPO1 'NU  ' PM ; 
         CHPO1 = CHAN 'CHPO' MODINF (REDU CHAM1 MODINF) ; 
         VYO_2 = EXTR CHPO1 'YOUN' PM ; 
         VNU_2 = EXTR CHPO1 'NU  ' PM ; 
         SI BOOL.'MESS' ; 
                 MESS ' MAT_INST  MAT2' ; 
                 MESS  VYO_1 VYO_2 ; 
                 MESS  VNU_1 VNU_2 ; 
         FINSI ; 
 *       Constante de Kolosov 
         SI (EGA GMODE 'PLANCONT') ; 
                 KAP_1 = (3. - VNU_1) / (1. + VNU_1) ; 
                 KAP_2 = (3. - VNU_2) / (1. + VNU_2) ; 
         SINON ; 
                 KAP_1 = (3. - (4. * VNU_1)) ; 
                 KAP_2 = (3. - (4. * VNU_2)) ; 
         FINSI ; 
 *       Module de cisaillement 
         MU_1 = VYO_1 / (2.*(1. + VNU_1)) ; 
         MU_2 = VYO_2 / (2.*(1. + VNU_2)) ; 
 *       Constante bi-metallique EPS1 
         VA1 = (KAP_1/MU_1) + (1./MU_2) ; 
         VA2 = (KAP_2/MU_2) + (1./MU_1) ; 
         EPS1 = (1./(2.*PI)) * (LOG (VA1/VA2)) ; 
 *       Constante C_MATE (= 1 / E^etoile) 
         COSH1 = PI * EPS1 ; 
         COSH1 = ((EXP COSH1) + (EXP (COSH1*(-1.)))) / 2. ; 
         VA1 = (MU_1 + (KAP_1*MU_2)) * (MU_2 + (KAP_2*MU_1)) ; 
         VA2 = MU_1 * MU_2 * ((MU_1*(1. + KAP_2)) + (MU_2*(1. + KAP_1))) ; 
         C_MATE = (COSH1*COSH1*VA1) / (4.*VA2) ; 
         MESS  'EPS1=' EPS1 '  C_MATE=' C_MATE ; 
 FINSI ; 
 * rappel: G = C_MATE * (K1^2 + K2^2)  +  1/MU * K3^2 
 *                       M = 2*C_MATE * (K1*K1^aux + K2*K2^aux)  +  2/MU * K3*K3^aux 
   
 * on evite le cas 3d + EF standard 
 SI (NON ((EGA GDIME 3) ET (NON BOOL.'XFEM'))) ; 
   
 **** CHAMPS POUR SIMPLIFIER L ECRITURE ************ 
 *               (CHPOINT pour EF std   //   CHAMELEM si XFEM) 
         SI (NON BOOL.'DANS') ; 
 *               CAS D UN MATERIAU HOMOGENE 
                 SIN1T  = SIN TETA1 ;       COS1T  = COS TETA1 ; 
                 SIN05T = SIN (0.5*TETA1) ; COS05T = COS (0.5*TETA1) ; 
                 SI BOOL.'XFEM' ; 
                         RM05 = (2.*PI*RAY1) ** -0.5 ; 
                         COE_GU = RM05 /  (4. * MU_1) ; 
                         SIN15T = SIN (1.5*TETA1) ; COS15T = COS (1.5*TETA1) ; 
 *                                       KAP_1 = KAP_1 * UN1 ; 
                 SINON ; 
                         COE_1 = ((RAY1/(2.*PI))**0.5) / (2.*MU_1) ; 
                 FINSI ; 
         SINON ; 
 *               CAS D UN BI-MATERIAU 
                 EPSLGR = EPS1 * (LOG RAY1) ; 
                 VA1 = COS (EPSLGR*180./PI) ; 
                 VA2 = SIN (EPSLGR*180./PI) ; 
                 BTA1   = ((0.5*VA1) + (EPS1*VA2)) / (0.25 + (EPS1*EPS1)) ; 
                 BTAPM1 = ((0.5*VA2) - (EPS1*VA1)) / (0.25 + (EPS1*EPS1)) ; 
                 DTA_1 = EXP (0. - ((PI - TETA1RAD)*EPS1)) ; 
                 DTA_2 = EXP ((PI + TETA1RAD)*EPS1) ; 
                 GAM_1 = (KAP_1*DTA_1) - (DTA_1**(-1.)) ; 
                 GAM_2 = (KAP_2*DTA_2) - (DTA_2**(-1.)) ; 
                 GAMPM_1 = (KAP_1*DTA_1) + (DTA_1**(-1.)) ; 
                 GAMPM_2 = (KAP_2*DTA_2) + (DTA_2**(-1.)) ; 
                 COS05T = COS (TETA1/2.) ;  SIN05T = SIN (TETA1/2.) ; 
                 D_1 = (BTA1*GAM_1*COS05T) + (BTAPM1*GAMPM_1*SIN05T) ; 
                 D_2 = (BTA1*GAM_2*COS05T) + (BTAPM1*GAMPM_2*SIN05T) ; 
                 DPM_1 = (BTAPM1*GAM_1*COS05T) - (BTA1*GAMPM_1*SIN05T) ; 
                 DPM_2 = (BTAPM1*GAM_2*COS05T) - (BTA1*GAMPM_2*SIN05T) ; 
                 GTAR1 = EPSLGR + (0.5*TETA1RAD) ; 
                 CVA_1 = (SIN TETA1) * (SIN (GTAR1*180./PI)) ; 
                 CVA_2 = (SIN TETA1) * (COS (GTAR1*180./PI)) ; 
                 COE_1 = ((RAY1/(2.*PI))**0.5) / (4.*MU_1) ; 
                 COE_2 = ((RAY1/(2.*PI))**0.5) / (4.*MU_2) ; 
         FINSI ; 
 FINSI ; 
   
   
 ******************************************************************************* 
 ****************************** ETAPE 3 **************************************** 
 ******************************************************************************* 
   
 REPE IMOD GDIME ; 
   
 **************************************************** 
 **** CHAMPS AUXILIAIRES SI DECOUPLAGE ************** 
 * Il existe plusieurs manieres de creer les champs aux : 
 * 1. en utilisant l expression analytique de grad(U) et sigma 
 * 2. en utilisant l expression analytique de U et en calculant 
 *    sigma, Fint=Bsigma, grad(U) ... 
 * 3. en appliquant une pression/cisaillement sur les faces de la fissure 
 *    et en resolvant le pb associe 
 * On utilise la 1ere lorsqu'on peut, la 2eme SINON 
   
 **** MOTMIX et MOTMIA ************************** 
 SI (&IMOD EGA 1) ; MOTMIX = MOT 'I' ;  MOTMIA = MOT '  I' ; FINSI ; 
 SI (&IMOD EGA 2) ; MOTMIX = MOT 'II' ; MOTMIA = MOT ' II' ; FINSI ; 
 SI (&IMOD EGA 3) ; MOTMIX = MOT 'III' ;MOTMIA = MOT 'III' ; FINSI ; 
 MESS 'CHAMPS AUXILIAIRES mode' ' ' MOTMIA ; 
   
   
 **** METHODE ANALYTIQUE PURE ******************* 
   
 *CAS D UN MATERIAU HOMOGENE 2D et 3D -------------------- 
 SI (BOOL.'XFEM' ET (NON BOOL.'DANS')) ; 
         SI BOOL.'MESS' ; 
                 MESS 'MATERIAU HOMOGENE XFEM: METHODE ANALYTIQUE' ; 
         FINSI ; 
   
 *       DERIVEES REPERE CYLINDRIQUE / COORDONNEES GLOBALES 
 *       R,X = DRDX         R,Y = DRDY 
 *       T,X = (1/R)*DTDX   T,Y = (1/R)*DTDY 
         DRDX = (COS1T*(EXCO GLV7 'UX,X' 'SCAL')) 
                         + (SDIR1*SIN1T*(EXCO GLV7 'UY,X' 'SCAL')) ; 
         DRDY = (COS1T*(EXCO GLV7 'UX,Y' 'SCAL')) 
                         + (SDIR1*SIN1T*(EXCO GLV7 'UY,Y' 'SCAL')) ; 
         DTDX = (-1.*SIN1T*(EXCO GLV7 'UX,X' 'SCAL')) 
                         + (SDIR1*COS1T*(EXCO GLV7 'UY,X' 'SCAL')) ; 
         DTDY = (-1.*SIN1T*(EXCO GLV7 'UX,Y' 'SCAL')) 
                 + (SDIR1*COS1T*(EXCO GLV7 'UY,Y' 'SCAL')) ; 
         SI (EGA GDIME 3) ; 
                 DRDZ = (COS1T*(EXCO GLV7 'UX,Z' 'SCAL')) 
                         + (SDIR1*SIN1T*(EXCO GLV7 'UY,Z' 'SCAL')) ; 
                 DTDZ = (-1.*SIN1T*(EXCO GLV7 'UX,Z' 'SCAL')) 
                         + (SDIR1*COS1T*(EXCO GLV7 'UY,Z' 'SCAL')) ; 
         FINSI ; 
   
 *debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
 *ajout des solutions analytiques du saut sur les levres de la fissure 
 *projection de psi1 sur la fissure et calcul de psi,x 
         SI BOOL.'FROT' ; 
   
 *               PSI en CHAML aux PG sur la fissure utilise pour calcul du gradient 
 *               on selectionne la partie de psi2 non nulle (= dans le champ theta) 
                 SI (EGA GDIME 2) ; 
 *                       contour du domaine theta 
                         CON1  = 'CONTOUR' ELTETA ; 
 *                       maillage support pour l'integration 
                         MAI1 = 'INCLUSION' MAICON CON1 'STRI' ; 
 *                       OBJCON2 = MODE mai1 'MECANIQUE' 'ZCO2' ; 
                         OBJCON2 = REDU  OBJCON mai1 ; 
                 SINON ; 
 *                       maillage support pour l'integration 
                         MAI1 = 'INCLUSION' ('EXTRAIRE' OBJCON 'MAIL') ELTETA 'VOLU' 'STRI' ; 
 *                       OBJCON2 = 'MODELISER' mai1 'MECANIQUE' 'ZCO3' ; 
                         OBJCON2 = REDU  OBJCON mai1 ; 
                 FINSI ; 
                 PSI1E = CHAN 'CHAM' PSI1 MOD_MEC_R 'NOEUDS' ; 
                 PSI2 = PROI OBJCON2 PSI1E 'STRESSES' ; 
 *               PSI en CHPOINT sur la fissure utilise pour calcul du repere local 
                 PSI3 = PROI MAICON PSI1E ; 
                 TESPSI = PSI2 'MASQUE' 'INFERIEUR'(-1E-15) ; 
 *               PSI2B = 'CHANGER' 'CHAM' (TESPSI * (-1.*PSI2) ('MOTS' 'PSI') ('MOTS' 
 *                               ('MOTS' 'PSI')) OBJCON 'STRESSES' ; 
                 PSI2B = TESPSI * (-1.*PSI2) ('MOTS' 'PSI') ('MOTS' 'PSI') ('MOTS' 'PSI') ; 
 *               'MESSAGE' '  PSI2B =  ' ; 'LISTE'  PSI2B ; 
 *               terme sqrt(r/2pI) et sa derivee,r 
                 RM05B = ((PSI2B/(2.*PI)) **0.5) ; 
                 RM05BR = 0.5*((2.*PI*PSI2B)**-0.5) ; 
 *               Change le nom pour pouvoir calculer grad avec ZCO 
                 LV72 = (PSI3 NOMC 'AX') 
                                 ET (MANU 'CHPO' ('EXTRAIRE' OBJCON2 'MAIL') 
                                         1 'AY  ' 0. 'NATURE' 'DIFFUS') 
                                 ET (MANU  'CHPO' ('EXTRAIRE' OBJCON2 'MAIL') 
                                         1 'AZ  ' 0. 'NATURE' 'DIFFUS') ; 
                 GLV72 = 'CHANGER' (GRAD LV72 OBJCON2) 'TYPE' 'SCALAIRE' ; 
 *               'MESSAGE' ' GLV72 =' ;'LISTE'  GLV72 ; 
                 SI (GDIME 'EGA' 2) ; 
 *                       Angle ALPHA1 de passage local -> global 
                         NGPSI2 = ( ((EXCO GLV72 'AX,X' 'SCAL')**2) 
                                                 + ((EXCO GLV72 'AX,Y' 'SCAL')**2) )**(0.5) ; 
                         COS1AB = ( (EXCO GLV72 'AX,Y' 'SCAL') / NGPSI2) ; 
                         SIN1AB = ( (EXCO GLV72 'AX,X' 'SCAL') / NGPSI2) ; 
                 SINON ; 
 *                       Angle ALPHA1 de passage local -> global 
                         NGPSI2 = ( ((EXCO GLV72 'AX,X' 'SCAL')**2) 
                                                 + ((EXCO GLV72 'AX,Y' 'SCAL')**2) 
                                                 + ((EXCO GLV72 'AX,Z' 'SCAL')**2) )**(0.5) ; 
 *                       CHAM premiere tangente = grad de psi 
                         V12X = (NOMC 'UX' ((EXCO GLV72 'AX,X' 'SCAL') / NGPSI2)) ; 
                         V12Y = (NOMC 'UY' ((EXCO GLV72 'AX,Y' 'SCAL') / NGPSI2)) ; 
                         V12Z = (NOMC 'UZ' ((EXCO GLV72 'AX,Z' 'SCAL') / NGPSI2)) ; 
                         V12 = V12X 'ET' V12Y 'ET' V12Z ; 
 *                       CHAM des normales 
                         V22 =  VSUR OBJCON2 'NORM' ; 
                         V22X = EXCO 'VX' V22 ; 
                         V22Y = EXCO 'VY' V22 ; 
                         V22Z = EXCO 'VZ' V22 ; 
 *                       CHAM de la derniere tangente produit vect des 2 autres 
                         V32X1 = NOMC 'UX' (V12Y * V22Z ('MOTS' 'UY') ('MOTS' 'VZ') 
                                                 ('MOTS' 'UX')) ; 
                         V32X2 =  NOMC 'UX'(V12Z * V22Y ('MOTS' 'UZ') ('MOTS' 'VY') 
                                                 ('MOTS' 'UX')) ; 
                         V32X = V32X1 '-' V32X2 ; 
                         V32Y1 = NOMC 'UY' (V12Z * V22X ('MOTS' 'UZ') ('MOTS' 'VX') 
                                                 ('MOTS' 'UY')) ; 
                         V32Y2 =  NOMC 'UY'(V12X * V22Z ('MOTS' 'UX') ('MOTS' 'VZ') 
                                                 ('MOTS' 'UY')) ; 
                         V32Y = V32Y1 '-' V32Y2 ; 
                         V32Z1 = NOMC 'UZ' (V12X * V22Y ('MOTS' 'UX') ('MOTS' 'VY') 
                                                 ('MOTS' 'UZ')) ; 
                         V32Z2 =  NOMC 'UZ'(V12Y * V22X ('MOTS' 'UY') ('MOTS' 'VX') 
                                                 ('MOTS' 'UZ')) ; 
                         V32Z = V32Z1 '-' V32Z2 ; 
                         V32 = V32X 'ET' V32Y 'ET' V32Z ; 
                         ROT2 = (EXCO V12 (MOTS 'UX' 'UY' 'UZ') (MOTS 'AX,X' 'AY,X' 'AZ,X')) 
                                         ET (EXCO V22 (MOTS 'VX' 'VY' 'VZ') (MOTS 'AX,Y' 'AY,Y' 'AZ,Y')) 
                                         ET (EXCO V32 (MOTS 'UX' 'UY' 'UZ') 
                                                 (MOTS 'AX,Z' 'AY,Z' 'AZ,Z')) ; 
                 FINSI ; 
   
 *               r,x (r = -PSI sur la fissure) 
                 DRDX2 = (EXCO GLV72 'AX,X' 'SCAL') ; 
                 DRDY2 = (EXCO GLV72 'AX,Y' 'SCAL') ; 
                 SI (EGA GDIME 3) ; 
                         DRDZ2 = (EXCO GLV72 'AX,Z' 'SCAL') ; 
                 FINSI ; 
   
         FINSI ; 
 *       fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
 *       CHAMP AUX. MODE 1 
         SI (&IMOD EGA 1) ; 
 *               derivees elementaires / repere local 
 *               Ui,R = (1/4µ)*RM05*UiR              i=1,2 
 *               Ui,T = (1/4µ)*RM05*UiT              i=1,2 
                 U1R = ((KAP_1 - 0.5) * COS05T) - (0.5 * COS15T) ; 
                 U1T = ((0.5 - KAP_1) * SIN05T) + (1.5 * SIN15T) ; 
                 U2R = ((KAP_1 + 0.5) * SIN05T) - (0.5 * SIN15T) ; 
                 U2T = ((KAP_1 + 0.5) * COS05T) - (1.5 * COS15T) ; 
 *               contraintes dans le repere local 
 *               SIGij        ij={11,22,33,12} 
                 SIG11 = RM05 * ( COS05T * (1.D0 - (SIN05T*SIN15T)) ) ; 
                 SIG22 = RM05 * ( COS05T * (1.D0 + (SIN05T*SIN15T)) ) ; 
                 SIG33 = ZER1 ; 
                 SIG12 = RM05 * ( COS05T * (SIN05T * COS15T) ) ; 
 *               gradient de deplacement dans le repere local 
 *               COE_GU = (1/4µ)*RM05 
 *               U1,X  U1,Y  U2,X  U2,Y 
                 GU1X = COE_GU * ( ( U1R * DRDX )  + ( U1T * DTDX ) ) ; 
                 GU1Y = COE_GU * ( ( U1R * DRDY )  + ( U1T * DTDY ) ) ; 
                 GU2X = COE_GU * ( ( U2R * DRDX )  + ( U2T * DTDX ) ) ; 
                 GU2Y = COE_GU * ( ( U2R * DRDY )  + ( U2T * DTDY ) ) ; 
 *               debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
 *               saut en ouverture 
                 SI BOOL.'FROT' ; 
                         W2 = 8.*RM05B *C_MATE ; 
                         W2R =  (8*C_MATE * RM05BR) ; 
                         W2R = NOMC W2R 'SCAL' ; 
 *                       GRADIENT SAUT OUVERTURE MIS A 0 CAR ON NE VEUT PAS MODIFIER KI EN PRESE 
                         W2X = 0.*W2R*DRDX2 ; 
                         W2Y = 0.*W2R*DRDY2 ; 
                         W1X = 0.*W2X ; W1Y = W1X ; 
                         W3X = 0.*W2X ; W3Y = W3X ; 
                 FINSI ; 
 *               fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
                 SI (EGA GDIME 3) ; 
                         GU1Z = COE_GU * ( ( U1R * DRDZ )  + ( U1T * DTDZ ) ) ; 
                         GU2Z = COE_GU * ( ( U2R * DRDZ )  + ( U2T * DTDZ ) ) ; 
                         SIG13 = ZER1 ; SIG23 = ZER1 ; 
                         GU3X = ZER1 ;   GU3Y = ZER1 ;    GU3Z = ZER1 ; 
                         SI BOOL.'FROT' ; 
                                 W2Z = 0.*W2R*DRDZ2 ; 
                                 W1Z = W1X ;W3Z = W3X ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
   
 *       CHAMP AUX. MODE 2 
         SI (&IMOD EGA 2) ; 
 *               derivees elementaires / repere local 
 *               Ui,R = (1/4µ)*RM05*UiR              i=1,2 
 *               Ui,T = (1/4µ)*RM05*UiT              i=1,2 
                 U1R = ((KAP_1 + 1.5) * SIN05T) + (0.5 * SIN15T) ; 
                 U1T = ((KAP_1 + 1.5) * COS05T) + (1.5 * COS15T) ; 
                 U2R = ((1.5 - KAP_1) * COS05T) - (0.5 * COS15T) ; 
                 U2T = ((KAP_1 - 1.5) * SIN05T) + (1.5 * SIN15T) ; 
 *               contraintes dans le repere local 
 *               SIGij        ij={11,22,33,12} 
                 SIG11 = -1.*RM05 * ( SIN05T * (2.D0 + (COS05T*COS15T)) ) ; 
                 SIG22 =     RM05 * ( SIN05T * (COS05T*COS15T) ) ; 
                 SIG33 = ZER1 ; 
                 SIG12 = RM05 * ( COS05T * (1.D0 - (SIN05T * SIN15T)) ) ; 
 *               gradient de deplacement dans le repere local 
 *               COE_GU = (1/4µ)*RM05 
 *               U1,X  U1,Y  U2,X  U2,Y 
                 GU1X = COE_GU * ( ( U1R * DRDX )  + ( U1T * DTDX ) ) ; 
                 GU1Y = COE_GU * ( ( U1R * DRDY )  + ( U1T * DTDY ) ) ; 
                 GU2X = COE_GU * ( ( U2R * DRDX )  + ( U2T * DTDX ) ) ; 
                 GU2Y = COE_GU * ( ( U2R * DRDY )  + ( U2T * DTDY ) ) ; 
   
   
 *               debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
 *               saut cisaillement 
                 SI BOOL.'FROT' ; 
                         W1 = 8.*RM05B *C_MATE ; 
 *                       W1,R 
 *                       W1R = ('CHANGER' 'CHAM' (8*C_MATE * RM05BR) OBJCON'STRESSES') ; 
 *                       ON DIVISE PAR 2 CAR ON SAUT DEFINI COMME PLUS - MOYENNE ET PAS (LEVRE + 
                         W1R = (8.*C_MATE * RM05BR) / 2. ; 
                         W1R = NOMC W1R 'SCAL' ; 
 *                       GRADIENT SAUT CISAILLEMENT = W1,R R,X 
                         W1X = W1R*DRDX2 ; 
                         W1Y = W1R*DRDY2 ; 
                         W2X = 0.*W1X ; W2Y = 0.*W2X ; 
                         W3X = 0.*W1X ; W3Y = 0.*W3X ; 
                 FINSI ; 
 *               fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
                 SI (EGA GDIME 3) ; 
                         GU1Z = COE_GU * ( ( U1R * DRDZ )  + ( U1T * DTDZ ) ) ; 
                         GU2Z = COE_GU * ( ( U2R * DRDZ )  + ( U2T * DTDZ ) ) ; 
                         SIG13 = ZER1 ; SIG23 = ZER1 ; 
                         GU3X = ZER1 ;   GU3Y = ZER1 ;    GU3Z = ZER1 ; 
                         SI BOOL.'FROT' ; 
                                 W1Z = W1R*DRDZ2 ; 
                                 W2Z = 0.*W2X ;W3Z = 0.*W3X ; 
                         FINSI ; 
                 FINSI ; 
         FINSI ; 
   
 *       CHAMP AUX. MODE 3  (automatiquement on a : EGA GDIME 3) 
         SI (&IMOD EGA 3) ; 
 *               derivees elementaires / repere local 
 *               Ui,R = (1/4µ)*RM05*UiR              i=3 
 *               Ui,T = (1/4µ)*RM05*UiT              i=3 
                 U3R = SIN05T ; 
                 U3T = COS05T ; 
 *               contraintes dans le repere local 
 *               SIGij        ij={11,22,33,12} 
                 SIG11 = ZER1 ; 
                 SIG22 = ZER1 ; 
                 SIG33 = ZER1 ; 
                 SIG12 = ZER1 ; 
                 SIG13 = -1.*RM05 * SIN05T ; 
                 SIG23 =     RM05 * COS05T ; 
 *               gradient de deplacement dans le repere local 
 *               COE_GU = (1/4µ)*RM05 
 *               U1,X  U1,Y  U2,X  U2,Y 
                 GU1X = ZER1 ; GU1Y = ZER1 ; GU1Z = ZER1 ; 
                 GU2X = ZER1 ; GU2Y = ZER1 ; GU2Z = ZER1 ; 
                 GU3X = COE_GU * ( ( U3R * DRDX )  + ( U3T * DTDX ) ) ; 
                 GU3Y = COE_GU * ( ( U3R * DRDY )  + ( U3T * DTDY ) ) ; 
                 GU3Z = COE_GU * ( ( U3R * DRDZ )  + ( U3T * DTDZ ) ) ; 
   
 *               debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
 *               saut cisaillement antiplan 
                 SI BOOL.'FROT' ; 
                         W3 = 8.*RM05B *C_MATE/ (1. - VNU_1) ; 
 *                       w3,r 
 *                       W3R = ('CHANGER' 'CHAM' (8*C_MATE * RM05BR/(1. - VNU_1)) 
 *                       OBJCON 'STRESSES') ; 
 *                       On divise par 2 car on saut defini comme plus - moyenne et pas (levre + 
                         W3R =  (8*C_MATE * RM05BR/(1. - VNU_1)) / 2. ; 
                         W3R = NOMC W3R 'SCAL' ; 
 *                       gradient saut cisaillement antiplan = W3,r r,X 
                         W3X = W3R*DRDX2 ; 
                         W3Y = W3R*DRDY2 ; 
                         W3Z = W3R*DRDZ2 ; 
                         W1X = 0.*W3X ; W1Y = 0.*W1X ; W1Z = 0.*W1X ; 
                         W2X = 0.*W3X ; W2Y = 0.*W2X ; W2Z = 0.*W2X ; 
                 FINSI ; 
 *               fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
         FINSI ; 
   
 *       PASSAGE DANS LE REPERE GLOBAL 
         SI (EGA GDIME 2) ; 
 *               ... des contraintes 
 *               SIGIJ = [P] * SIGij * [P]**-1   local: ij={1,2..}  global: IJ={X,Y..} 
                 SIGXX= (COSA2*SIG11) - (2.*SINCOSA*SIG12) + (SINA2*SIG22) ; 
                 SIGYY= (SINA2*SIG11) + (2.*SINCOSA*SIG12) + (COSA2*SIG22) ; 
                 SIGZZ= SIG33 ; 
                 SIGXY= (SINCOSA*SIG11) + ((COSA2-SINA2)*SIG12) - (SINCOSA*SIG22) ; 
                 SIGAUX = (NOMC 'SMXX' SIGXX) ET  (NOMC 'SMYY' SIGYY) 
                                         ET (NOMC 'SMZZ' SIGZZ) ET  (NOMC 'SMXY' SIGXY) ; 
                 SIGAUX = CHAN SIGAUX 'TYPE' 'CONTRAINTES' ; 
 *               TRAC SIGAUX MOD_MEC_R 'TITR' ' SIGAUX' ; 
 *               ... des gradient de deplacement 
 *               UI,J = [P] * Ui,j       local: ij={1,2..}  global: IJ={X,Y..} 
                 GRUXX  = (GU1X*COS1A) - (GU2X*SIN1A) ; 
                 GRUXY  = (GU1Y*COS1A) - (GU2Y*SIN1A) ; 
                 GRUYX  = (GU1X*SIN1A) + (GU2X*COS1A) ; 
                 GRUYY  = (GU1Y*SIN1A) + (GU2Y*COS1A) ; 
                 GRUAUX = (NOMC 'UX,X' GRUXX) ET (NOMC 'UX,Y' GRUXY) 
                                         ET (NOMC 'UX,Z' ZER1) 
                                         ET (NOMC 'UY,X' GRUYX) ET (NOMC 'UY,Y' GRUYY) 
                                         ET (NOMC 'UY,Z' ZER1) 
                                         ET (NOMC 'UZ,X' ZER1) ET (NOMC 'UZ,Y' ZER1) 
                                         ET (NOMC 'UZ,Z' ZER1)       ; 
                 GRUAUX = CHAN GRUAUX 'TYPE' 'GRADIENT' ; 
 *               TRAC GRUAUX MOD_MEC_R 'TITR' ' GRUAUX' ; 
 *               debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
                 SI BOOL.'FROT' ; 
 *                       ... des gradient de deplacement sur la fissure 
 *                       UI,J = [P] * Ui,j       local: ij={1,2..}  global: IJ={X,Y..} 
                         GRWXX  = (W1X*COS1AB) - (W2X*SIN1AB) ; 
                         GRWXY  = (W1Y*COS1AB) - (W2Y*SIN1AB) ; 
                         GRWYX  = (W1X*SIN1AB) + (W2X*COS1AB) ; 
                         GRWYY  = (W1Y*SIN1AB) + (W2Y*COS1AB) ; 
                         GRWAUX = (NOMC 'AX,X' GRWXX) ET (NOMC 'AX,Y' GRWXY) 
                                                 ET (NOMC 'AX,Z' ZER1) 
                                                 ET (NOMC 'AY,X' GRWYX) ET (NOMC 'AY,Y' GRWYY) 
                                                 ET (NOMC 'AY,Z' ZER1) 
                                                 ET (NOMC 'AZ,X' ZER1) ET (NOMC 'AZ,Y' ZER1) 
                                                 ET (NOMC 'AZ,Z' ZER1)       ; 
                         GRWAUX = CHAN GRWAUX 'TYPE' 'GRADIENT' ; 
                 FINSI ; 
 *               fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
         SINON ; 
                 SIGAUX = (NOMC 'SMXX' SIG11) ET  (NOMC 'SMYY' SIG22) 
                                         ET (NOMC 'SMZZ' SIG33) ET  (NOMC 'SMXY' SIG12) 
                                         ET (NOMC 'SMXZ' SIG13) ET  (NOMC 'SMYZ' SIG23) ; 
                 SIGAUX = CHAN SIGAUX 'TYPE' 'CONTRAINTES' ; 
 *               SUPTAB . (chai 'SIGAUX_LOCAL' IM) = SIGAUX ; 
                 SIGAUX = RTEN SIGAUX MOD_MEC_R ROT1 'RART' ; 
 *               SUPTAB . (chai 'SIGAUX_GLOBAL' IM) = SIGAUX ; 
                 GUIJ = (NOMC GU1X 'U1,X') ET (NOMC GU1Y 'U1,Y') ET (NOMC GU1Z 'U1,Z') 
                                 ET (NOMC GU2X 'U2,X') ET (NOMC GU2Y 'U2,Y') ET (NOMC GU2Z 'U2,Z') 
                                 ET (NOMC GU3X 'U3,X') ET (NOMC GU3Y 'U3,Y') ET (NOMC GU3Z 'U3,Z') ; 
   
                 GRUXX  = PSCA ROT1 GUIJ 
                                         (MOTS 'UX,X' 'UX,Y' 'UX,Z') (MOTS 'U1,X' 'U2,X' 'U3,X') ; 
                 GRUYX  = PSCA ROT1 GUIJ 
                                         (MOTS 'UY,X' 'UY,Y' 'UY,Z') (MOTS 'U1,X' 'U2,X' 'U3,X') ; 
                 GRUZX  = PSCA ROT1 GUIJ 
                                         (MOTS 'UZ,X' 'UZ,Y' 'UZ,Z') (MOTS 'U1,X' 'U2,X' 'U3,X') ; 
                 GRUXY  = PSCA ROT1 GUIJ 
                                         (MOTS 'UX,X' 'UX,Y' 'UX,Z') (MOTS 'U1,Y' 'U2,Y' 'U3,Y') ; 
                 GRUYY  = PSCA ROT1 GUIJ 
                                         (MOTS 'UY,X' 'UY,Y' 'UY,Z') (MOTS 'U1,Y' 'U2,Y' 'U3,Y') ; 
                 GRUZY  = PSCA ROT1 GUIJ 
                                         (MOTS 'UZ,X' 'UZ,Y' 'UZ,Z') (MOTS 'U1,Y' 'U2,Y' 'U3,Y') ; 
                 GRUXZ  = PSCA ROT1 GUIJ 
                                         (MOTS 'UX,X' 'UX,Y' 'UX,Z') (MOTS 'U1,Z' 'U2,Z' 'U3,Z') ; 
                 GRUYZ  = PSCA ROT1 GUIJ 
                                         (MOTS 'UY,X' 'UY,Y' 'UY,Z') (MOTS 'U1,Z' 'U2,Z' 'U3,Z') ; 
                 GRUZZ  = PSCA ROT1 GUIJ 
                                         (MOTS 'UZ,X' 'UZ,Y' 'UZ,Z') (MOTS 'U1,Z' 'U2,Z' 'U3,Z') ; 
   
                 GRUAUX = (NOMC 'UX,X' GRUXX) ET (NOMC 'UX,Y' GRUXY) 
                                         ET (NOMC 'UX,Z' GRUXZ) 
                                         ET (NOMC 'UY,X' GRUYX) ET (NOMC 'UY,Y' GRUYY) 
                                         ET (NOMC 'UY,Z' GRUYZ) 
                                         ET (NOMC 'UZ,X' GRUZX) ET (NOMC 'UZ,Y' GRUZY) 
                                         ET (NOMC 'UZ,Z' GRUZZ)       ; 
                 GRUAUX = CHAN GRUAUX 'TYPE' 'GRADIENT' ; 
 *               debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
                 SI BOOL.'FROT' ; 
                         GWIJ = (NOMC W1X 'A1,X') ET (NOMC W1Y 'A1,Y') ET (NOMC W1Z 'A1,Z') 
                                         ET (NOMC W2X 'A2,X') ET (NOMC W2Y 'A2,Y') ET (NOMC W2Z 'A2,Z') 
                                         ET (NOMC W3X 'A3,X') ET (NOMC W3Y 'A3,Y') ET (NOMC W3Z 'A3,Z') ; 
                         GRWXX  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AX,X' 'AX,Y' 'AX,Z') (MOTS 'A1,X' 'A2,X' 'A3,X') ; 
                         GRWYX  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AY,X' 'AY,Y' 'AY,Z') (MOTS 'A1,X' 'A2,X' 'A3,X') ; 
                         GRWZX  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AZ,X' 'AZ,Y' 'AZ,Z') (MOTS 'A1,X' 'A2,X' 'A3,X') ; 
                         GRWXY  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AX,X' 'AX,Y' 'AX,Z') (MOTS 'A1,Y' 'A2,Y' 'A3,Y') ; 
                         GRWYY  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AY,X' 'AY,Y' 'AY,Z') (MOTS 'A1,Y' 'A2,Y' 'A3,Y') ; 
                         GRWZY  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AZ,X' 'AZ,Y' 'AZ,Z') (MOTS 'A1,Y' 'A2,Y' 'A3,Y') ; 
                         GRWXZ  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AX,X' 'AX,Y' 'AX,Z') (MOTS 'A1,Z' 'A2,Z' 'A3,Z') ; 
                         GRWYZ  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AY,X' 'AY,Y' 'AY,Z') (MOTS 'A1,Z' 'A2,Z' 'A3,Z') ; 
                         GRWZZ  = PSCA ROT2 GWIJ 
                                                 (MOTS 'AZ,X' 'AZ,Y' 'AZ,Z') (MOTS 'A1,Z' 'A2,Z' 'A3,Z') ; 
                         GRWAUX = (NOMC 'AX,X' GRWXX) ET (NOMC 'AX,Y' GRWXY) 
                                                 ET (NOMC 'AX,Z' GRWXZ) 
                                                 ET (NOMC 'AY,X' GRWYX) ET (NOMC 'AY,Y' GRWYY) 
                                                 ET (NOMC 'AY,Z' GRWYZ) 
                                                 ET (NOMC 'AZ,X' GRWZX) ET (NOMC 'AZ,Y' GRWZY) 
                                                 ET (NOMC 'AZ,Z' GRWZZ)       ; 
                         GRWAUX = CHAN GRWAUX 'TYPE' 'GRADIENT' ; 
                 FINSI ; 
 *               fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
         FINSI ; 
 *       champs auxiliaires 
         A_DEPI = DEP000 ; 
         A_DEPGR= GRUAUX ; 
         A_SIGF = SIGAUX ; 
         A_PREI = FOR000 ; 
         SI BOOL.'FROT' ; B_DEPGR = GRWAUX ; FINSI ; 
 FINSI ; 
   
   
 **** METHODE U-ANALYTIQUE ************************** 
   
 SI ((NON BOOL.'XFEM') ET (EGA GDIME 2) ET (NON BOOL.'DANS')) ; 
 *       CAS D UN MATERIAU HOMOGENE 2D -------------------- 
         SI(BOOL.'MESS') ; 
                 MESS 'MATERIAU HOMOGENE 2D: METHODE U-ANALYTIQUE' ; 
         FINSI ; 
 *       champ aux. mode 1 
         SI (&IMOD EGA 1) ; 
                 UX_1 = COE_1 * COS05T * (KAP_1 - COS1T) ; 
                 UY_1 = COE_1 * SIN05T * (KAP_1 - COS1T) ; 
         FINSI ; 
 *       champ aux. mode 2 
         SI (&IMOD EGA 2) ; 
                 UX_1 = COE_1 * SIN05T * (KAP_1 + 2. + COS1T) ; 
                 UY_1 = (-1.)*COE_1 * COS05T * (KAP_1 - 2. + COS1T) ; 
         FINSI ; 
 *       deplacement dans le repere local 
         UL1 = CHAN 'ATTRIBUT' UX_1 'NATURE' 'DIFFUS' ; 
         UL2 = CHAN 'ATTRIBUT' UY_1 'NATURE' 'DIFFUS' ; 
 *       retour du repere local vers le global 
         UG1 = (UL1*(COS ALPHA1)) - (UL2*(SIN ALPHA1)) ; 
         UG2 = (UL1*(SIN ALPHA1)) + (UL2*(COS ALPHA1)) ; 
         UG1 = CHAN 'ATTRIBUT' UG1 'NATURE' 'DIFFUS' ; 
         UG2 = CHAN 'ATTRIBUT' UG2 'NATURE' 'DIFFUS' ; 
 *       champs auxiliaires 
         A_DEPI = ((NOMC UG1 MU1) ET (NOMC UG2 MU2)) + DEP000 ; 
         A_SIGF = SIGM 'LINE' MAT_INST MOD_MEC_R A_DEPI ; 
         A_PREI = BSIG A_SIGF MOD_MEC_R ; 
 FINSI ; 
   
 SI ((EGA GDIME 2) ET (BOOL.'DANS')) ; 
 *       CAS D UN BI-MATERIAU 2D -------------------- 
         SI(BOOL.'MESS') ; 
                 MESS 'BI-MATERIAU 2D: METHODE ANALYTIQUE' ; 
         FINSI ; 
 *       champ aux. mode 1 
         SI (&IMOD EGA 1) ; 
                 UX_1 = COE_1*(D_1 + (2.*DTA_1*CVA_1)) ; 
                 UX_2 = COE_2*(D_2 + (2.*DTA_2*CVA_1)) ; 
                 UY_1 = (-1.)*COE_1*(DPM_1 + (2.*DTA_1*CVA_2)) ; 
                 UY_2 = (-1.)*COE_2*(DPM_2 + (2.*DTA_2*CVA_2)) ; 
         FINSI ; 
 *       champ aux. mode 2 
         SI (&IMOD EGA 2) ; 
                 UX_1 = (-1.)*COE_1*(DPM_1 - (2.*DTA_1*CVA_2)) ; 
                 UX_2 = (-1.)*COE_2*(DPM_2 - (2.*DTA_2*CVA_2)) ; 
                 UY_1 = (-1.)*COE_1*(D_1 - (2.*DTA_1*CVA_1)) ; 
                 UY_2 = (-1.)*COE_2*(D_2 - (2.*DTA_2*CVA_1)) ; 
         FINSI ; 
 *       deplacement dans le repere local : on moyenne sur l interface 
         UX_1 = CHAN 'ATTRIBUT' UX_1 'NATURE' 'DIFFUS' ; 
         UX_2 = CHAN 'ATTRIBUT' UX_2 'NATURE' 'DIFFUS' ; 
         UY_1 = CHAN 'ATTRIBUT' UY_1 'NATURE' 'DIFFUS' ; 
         UY_2 = CHAN 'ATTRIBUT' UY_2 'NATURE' 'DIFFUS' ; 
         UL1 = UX_1 ET UX_2 ; 
         UL2 = UY_1 ET UY_2 ; 
 *       retour du repere local vers le global 
         UG1 = (UL1*(COS ALPHA1)) - (UL2*(SIN ALPHA1)) ; 
         UG2 = (UL1*(SIN ALPHA1)) + (UL2*(COS ALPHA1)) ; 
         UG1 = CHAN 'ATTRIBUT' UG1 'NATURE' 'DIFFUS' ; 
         UG2 = CHAN 'ATTRIBUT' UG2 'NATURE' 'DIFFUS' ; 
 *       champs auxiliaires 
         A_DEPI = ((NOMC UG1 MU1) ET (NOMC UG2 MU2)) + DEP000 ; 
         A_SIGF = SIGM 'LINE' MAT_INST MOD_MEC_R A_DEPI ; 
         A_PREI = BSIG A_SIGF MOD_MEC_R ; 
 FINSI ; 
   
   
 **** METHODE MECANIQUE ************************** 
 *** (EFFORTS APPLIQUES AUX LEVRES DE LA FISSURE) 
 * BP : cette methode est tres couteuse car appel a resou pour chaque 
 * noeud du front de fissure -> passer a une methode analytique + tard 
   
 SI ((NON BOOL.'XFEM') ET (EGA GDIME 3) ET (NON BOOL.'DANS')) ; 
 *CAS D UN MATERIAU HOMOGENE 3D  -------------------- 
         MESS 'MATERIAU HOMOGENE 3D: METHODE MECANIQUE' ; 
         LSUP = SUPTAB.'LEVRE_SUPERIEURE' ; 
         LINF = SUPTAB.'LEVRE_INFERIEURE' ; 
         VCISA = RESU DIR3 ; 
         VCISA = (MAXI (EXCO VCISA 'UX')) (MAXI (EXCO VCISA 'UY')) 
                                 (MAXI (EXCO VCISA 'UZ')) ; 
         VTETA = RESU DIR1 ; 
         VTETA = (MAXI (EXCO VTETA 'UX')) (MAXI (EXCO VTETA 'UY')) 
                                 (MAXI (EXCO VTETA 'UZ')) ; 
         VNORM = RESU DIR2 ; 
         VNORM = (MAXI (EXCO VNORM 'UX')) (MAXI (EXCO VNORM 'UY')) 
                                 (MAXI (EXCO VNORM 'UZ')) ; 
         SI (EGA GDIME 3) ; 
                 LSUP = LSUP DIFF (LSUP ELEM 'APPU' 'STRI' ELTETA) ; 
                 LINF = LINF DIFF (LINF ELEM 'APPU' 'STRI' ELTETA) ; 
         FINSI ; 
 *       bp:  pas bien compris sur quelle partie de LSUP on applique les efforts ? 
         SI BOOL.'PASAPAS' ; 
                 F11=PRES 'MASS' (SUPTAB.'SOLUTION_PASAPAS'.'MODELE') LSUP 1 ; 
                 F21=PRES 'MASS' (SUPTAB.'SOLUTION_PASAPAS'.'MODELE') LINF 1 ; 
         SINON ; 
                 F11 = PRES 'MASS' (SUPTAB.'MODELE') LSUP 1 ; 
                 F21 = PRES 'MASS' (SUPTAB.'MODELE') LINF 1 ; 
         FINSI ; 
 *       champ de pression aux. mode 1 
         SI (&IMOD EGA 1) ; 
                 A_PREI = F11 + F21 ; 
         FINSI ; 
 *       champ de pression aux. mode 2 
         SI (&IMOD EGA 2) ; 
                 V1 = EXCO (F11 + F21) MF1 'SCAL' ; 
                 V2 = EXCO (F11 + F21) MF2 'SCAL' ; 
                 V3 = EXCO (F11 + F21) MF3 'SCAL' ; 
                 N1 = ((V1 * V1) + (V2 * V2) + (V3 * V3)) ** 0.5 ; 
 *               adaptation car DIR1 est desormais un CHPOINT 
                 V1 = COOR 1 VTETA ; 
                 V2 = COOR 2 VTETA ; 
                 V3 = COOR 3 VTETA ; 
                 A_PREI = (MANU 'CHPO' LSUP 3 MF1 V1 MF2 V2 MF3 V3) - 
                                         (MANU 'CHPO' LINF 3 MF1 V1 MF2 V2 MF3 V3) ; 
 *               adaptation car DIR1 est desormais un CHPOINT 
 *               A_PREI = EXCO DIR1 UCOMP FCOMP ; 
 *               A_PREI = (REDU A_PREI LSUP) - (REDU A_PREI LINF) ; 
                 A_PREI = A_PREI * N1 ; 
         FINSI ; 
 *       champ de pression aux. mode 3 
         SI (&IMOD EGA 3) ; 
                 V1 = EXCO (F11 + F21) MF1 'SCAL' ; 
                 V2 = EXCO (F11 + F21) MF2 'SCAL' ; 
                 V3 = EXCO (F11 + F21) MF3 'SCAL' ; 
                 N1 = ((V1 * V1) + (V2 * V2) + (V3 * V3)) ** 0.5 ; 
 *               adaptation car DIR3 est desormais un CHPOINT 
                 V1 = COOR 1 VCISA ; 
                 V2 = COOR 2 VCISA ; 
                 V3 = COOR 3 VCISA ; 
                 A_PREI = (MANU 'CHPO' LSUP 3 MF1 V1 MF2 V2 MF3 V3) - 
                                         (MANU 'CHPO' LINF 3 MF1 V1 MF2 V2 MF3 V3) ; 
 *               adaptation car DIR3 est desormais un CHPOINT 
                 A_PREI = A_PREI * N1 ; 
         FINSI ; 
 *       le deplacement et les contraintes sont deduites de la pression 
 *       trac (vect A_PREI 'FORC' 'ROUG') elteta ; 
         A_DEPI = RESO (RIGTOT ET CL1) A_PREI ; 
         A_SIGF = SIGM 'LINE' MAT_INST MOD_MEC_R A_DEPI ; 
 FINSI ; 
   
 SI ((EGA GDIME 3) ET (BOOL.'DANS')) ; 
 *       CAS D UN BI-MATERIAU 3D  -------------------- 
         MESS 'ERREUR : ON NE PEUT ENCORE DECOUPLER LES MODES' ; 
         MESS '         DANS LE CAS DES MATERIAUX COMPOSITES' ; 
         MESS '         EN 3D' ; 
         ERRE 21 ; QUIT G_AUX ; 
 FINSI ; 
   
 * STOCKAGE DES CHAMPS AUX 
 TAB1 = TABL ; 
 TAB1.'MOTMIX' = MOTMIX ; 
 TAB1.'MOTMIA' = MOTMIA ; 
 TAB1.'A_PREI' = A_PREI ; 
 TAB1.'A_DEPI' = A_DEPI ; 
 TAB1.'A_SIGF' = A_SIGF ; 
 TAB1.'A_DEPGR' = A_DEPGR ; 
 CH_AUX.&IMOD = TAB1 ; 
   
 * OBJETS UTILES A GARDER 
 OBJUTI.'C_MATE' = C_MATE ; 
 SI BOOL.'FROT' ; 
         OBJUTI.'OBJCON2' = OBJCON2 ; 
         OBJUTI .'B_DEPGR' = B_DEPGR ; 
 FINSI ; 
   
 FIN IMOD ; 
   
 FINP CH_AUX ; 
 * G_CALCUL  PROCEDUR  PASCAL    20/11/13    21:15:04     10778 
 DEBPROC G_CALCUL SUPTAB*'TABLE' OBJUTI*'TABLE' BOOL*'TABLE' ; 
 *|=====================================================================| 
 *|                                                                     | 
 *|    OBJECTIF :                                                       | 
 *|    ==========                                                       | 
 *|                                                                     | 
 *| Cette procedure est appelee par G_THETA.                            | 
 *|                                                                     | 
 *|                                                                     | 
 *|    ENTREE :                                                         | 
 *|    ========                                                         | 
 *|                                                                     | 
 *| SUPTAB = objet de type TABLE utilise par la procedure G_THETA       | 
 *| OBJUTI = objet de type TABLE contenant des objets utiles au calcul  | 
 *| BOOL   = objet de type TABLE contenant les booleens nécessaires     | 
 *|                                                                     | 
 *|                                                                     | 
 *|                                                                     | 
 *|                                                                     | 
 *|=====================================================================| 
   
   
   
 *|=====================================================================| 
 *|=======  I. INITIALISATIONS  ========================================| 
   
   
 ************************************************** 
 ************* INFORMATIONS GENERALES ************* 
 ************************************************** 
 GDIME = OBJUTI.'DIMENSION' ; 
 GMODE = OBJUTI.'MODE' ; 
   
   
 ************************************************** 
 *** INFORMATIONS PROVENANT DE LA TABLE OBJUTI **** 
 ************************************************** 
 TABMOD = OBJUTI.'TABMOD' ; 
 LINTER = OBJUTI.'LINTER' ; 
 ITYPEF   = OBJUTI.'ITYPEF' ; 
 ELTETA = OBJUTI.'ELTETA' ; 
 RIGTOT = OBJUTI.'RIGTOT' ; 
 MOD_MEC_R = OBJUTI.'MOD_MEC_R' ; 
 MAILMOD = EXTR MOD_MEC_R 'MAILLAGE' ; 
 MODPLA = OBJUTI.'MODPLA' ; 
 DEP000 = OBJUTI.'DEP000' ; 
 CMD000 = CHAN 'NOEUD' MOD_MEC_R (ZERO MOD_MEC_R 'DEPLACEM') ; 
 CMD001 = OBJUTI.'CMD001' ; 
 GRA000 = OBJUTI.'GRA000' ; 
 * 
 SI BOOL.'PERSO1' ; 
   ESTIM = OBJUTI . 'ESTIMATION' ; 
 FINSI ; 
 IABC = OBJUTI.'IABC' ; 
 &BOUCEXT = OBJUTI.'&BOUCEXT' ; 
 &BOUCMIX = OBJUTI.'&BOUCMIX' ; 
 INST = OBJUTI.'INST' ; 
 C_MATE = OBJUTI.'C_MATE' ; 
 MAT_INST = OBJUTI.'MAT_INST' ; 
 ENERM = OBJUTI.'ENERM' ; 
 WVMIS = OBJUTI.'WVMIS' ; 
 TEPINT = OBJUTI.'TEPINT' ; 
 PREINT = OBJUTI.'PREINT' ; 
 * EN VISCOPLASTICITE 
 SI (BOOL.'C*' OU BOOL.'C*H') ; 
         FACT1 = OBJUTI.'FACT1' ; 
 FINSI ; 
 * (fdp) pour la pression sur la fissure 
 SI (EXIS OBJUTI 'MODE_PRESSION_FISSURE') ; 
         MODPF = OBJUTI.'MODE_PRESSION_FISSURE' ; 
         PNF = OBJUTI.'PRESSION_FISSURE' ; 
 FINSI ; 
 DEPINT = OBJUTI.'DEPINT' ; 
 SIGF = OBJUTI.'SIGF' ; 
 SIG1 = OBJUTI.'SIG1' ; 
 VARF = OBJUTI.'VARF' ; 
 *pour la dynamique 
 VITF = OBJUTI.'VITF' ; 
 ACCF = OBJUTI.'ACCF' ; 
 *pour le decouplage 
 MOTMIX = OBJUTI.'MOTMIX' ; 
 MOTMIA = OBJUTI.'MOTMIA' ; 
 A_PREI = OBJUTI.'A_PREI' ; 
 A_DEPI = OBJUTI.'A_DEPI' ; 
 A_DEPGR = OBJUTI.'A_DEPGR' ; 
 A_SIGF = OBJUTI.'A_SIGF' ; 
 *debut du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
 SI (BOOL.'FROT') ; 
         OBJCON = OBJUTI.'OBJCON' ; 
         OBJCON2 = OBJUTI.'OBJCON2' ; 
         WDEP = OBJUTI.'WDEP' ; 
         SIGCON = OBJUTI.'SIGCON' ; 
         B_DEPGR = OBJUTI.'B_DEPGR' ; 
 FINSI ; 
 *fin du cas contact frottant BOOL.'FROT' (btrolle 19/02/2013) 
   
 ************************************************** 
 ***  QUELQUES MOTS POUR SIMPLIFIER L'ECRITURE  *** 
 ************************************************** 
 NEXTR = GDIME ; 
 SI BOOL.'COQ' ; 
         NEXTR = 6 ; 
 FINSI ; 
 MUI = EXTR (EXTR MOD_MEC_R 'DEPL') (LECT 1 PAS 1 NEXTR) ; 
 MFI = EXTR (EXTR MOD_MEC_R 'FORC') (LECT 1 PAS 1 NEXTR) ; 
 MGI = EXTR MOD_MEC_R 'GRAD' ; 
 MU1 = EXTR MUI 1 ; MU2 = EXTR MUI 2 ; MU3  = MOT 'UZ' ; 
 MF1 = EXTR MFI 1 ; MF2 = EXTR MFI 2 ; MF3  = MOT 'FZ' ; 
 MFA1= MOT  'FAX' ; MFA2 = MOT 'FAY' ; MFA3 = MOT 'FAZ' ; 
 GR1 GR2 GR3 = (EXTR MGI 1) (EXTR MGI 2) (EXTR MGI 3) ; 
 GR4 GR5 GR6 = (EXTR MGI 4) (EXTR MGI 5) (EXTR MGI 6) ; 
 GR7 GR8 GR9 = (EXTR MGI 7) (EXTR MGI 8) (EXTR MGI 9) ; 
 SM1 = MOT  'SMXX' ; SM2  = MOT 'SMYY' ; SM3  = MOT 'SMZZ' ; 
 SM4 = MOT  'SMXY' ; SM5  = MOT 'SMXZ' ; SM6  = MOT 'SMYZ' ; 
 EP1 = MOT  'EPXX' ; EP2  = MOT 'EPYY' ; EP3  = MOT 'EPZZ' ; 
 EP4 = MOT  'GAXY' ; EP5  = MOT 'GAXZ' ; EP6  = MOT 'GAYZ' ; 
 SI (EGA GMODE 'AXIS') ; 
    MU3 = MOT 'UT' ; 
    SM1 = MOT 'SMRR' ; SM2 = MOT 'SMZZ' ; SM3 = MOT 'SMTT' ; 
    SM4 = MOT 'SMRZ' ; 
    EP1 = MOT 'EPRR' ; EP2 = MOT 'EPZZ' ; EP3 = MOT 'EPTT' ; 
    EP4 = MOT 'GARZ' ; 
 FINSI ; 
 *BP: PETIT AJOUT DE NOM DE COMPOSANTE DE CHPOINT 
 SI (BOOL.'J' OU BOOL.'J_DYNA') ; MOCOMP = 'J' ;    FINSI ; 
 SI (BOOL.'C*' OU BOOL.'C*H') ; MOCOMP = 'C*' ;   FINSI ; 
 SI BOOL.'DJ/DA' ; MOCOMP = 'DJDA' ; FINSI ; 
 SI BOOL.'DECOUPLAGE' ; 
         MOCOMP = CHAI 'K' &BOUCMIX ; 
 FINSI ; 
 ************************************ 
 *** RIGTOT + BLOCAGES MECANIQUES *** 
 ************************************ 
 SI  BOOL.'DJ/DA' ; 
   SI BOOL.'PASAPAS' ; 
      RIGTOT = RIGTOT ET 
              (SUPTAB.'SOLUTION_PASAPAS'.'BLOCAGES_MECANIQUES') ; 
 *rem bp: on suppose ceux ci identique a ceux de wtab... 
   SINON ; 
      RIGTOT = RIGTOT ET SUPTAB.'BLOCAGES_MECANIQUES' ; 
   FINSI ; 
 FINSI ; 
   
 ************************************ 
 ********* Valeurs initiales ******** 
 ************************************ 
 S10  = 0. ; S20  = 0. ; S30  = 0. ; S40  = 0. ; S41 = 0. ; S50  = 0. ; 
 S60  = 0. ; S70  = 0. ; S80  = 0. ; S90  = 0. ; S100 = 0. ; 
 S110 = 0. ; S120 = 0. ; S130 = 0. ; S140 = 0. ; S141 = 0. ; 
 S150 = 0. ; S160 = 0. ; S170 = 0. ; S180 = 0. ; 
 S190 = 0. ; S200 = 0. ; S210 = 0. ; S220 = 0. ; 
   
 ************************************ 
 ********** MATERIAU MAT2 *********** 
 ************************************ 
 SI (BOOL.'COQ' ET BOOL.'EL_QUA') ; 
    MAT2 = MAT_INST ; 
 SINON ; 
    MAT2 = TEXT '        ' ; 
 FINSI ; 
   
   
   
 *|=====================================================================| 
 *|=======  II. CRITERES DE DECHARGES  =================================| 
   
   
 ************************************************************ 
 ****** CRITERE GLOBAL 1 DE DECHARGE DES CONTRAINTES ******** 
 ************************************************************ 
 *** 
 *** EVALUATION EN ELASTO-PLASTICITE OU THERMO-ELASTO-PLASTICITE 
 *** PAR COMPARAISON AVEC UN CALCUL EN ELASTICITE NON-LINEAIRE 
 *** EN PRENANT POUR REFERENCE LES CONTRAINTES DE VON-MISES DU 
 *** CALCUL RENDU PAR PASAPAS ET LES CONTRAINTES EQUIVALENTES LUES 
 *** SUR LES COURBES DE TRACTION 
 *** 
 OUICRIT = FAUX ; 
 SI (EXIS SUPTAB 'CALCUL_CRITERE') ; 
   OUICRIT = SUPTAB.'CALCUL_CRITERE' ; 
 FINSI ; 
 SI (BOOL.'MESS' ET OUICRIT) ; 
   MESS 'on va calculer les CRITERES DE DECHARGES, modpla=' ; 
 *   list modpla ; 
 FINSI ; 
   
 SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET OUICRIT) ; 
   
   XCRIT = 1. ; 
   
   REPE BCMOD0 (DIME TABMOD) ; 
     EXISCRIT = FAUX ; 
     MODI  = TABMOD.&BCMOD0 ; 
     MATI  = REDU MAT_INST MODI ; 
     EPSE1 = EXCO VARF 'EPSE' ; 
     EPSE1 = EPSE1 CHAN TYPE 'SCALAIRE' ; 
     EPSET = REDU EPSE1 MODI ; 
     MSQ   = MASQ 'SUPERIEUR' EPSET 1.E-6 ; 
   
 *VMIS1 = contraintes de Von-Mises en elastoplastique 
     VMIS1 = CHAN ('VMIS' MODI (REDU SIGF MODI) MATI) 
             TYPE 'SCALAIRE' ; 
   
     SI ('EXIS' MODPLA &BCMOD0) ; 
       YOU = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN') ; 
       YOU = YOU CHAN TYPE 'SCALAIRE' ; 
       SI (EGA MODPLA.&BCMOD0 1) ; 
 *modele est plastique isotrope. on utilise la 
 *courbe de traction TABTRA.&BCMOD0 
         EXISCRIT = VRAI ; 
         MATA = VARI 'NUAG' MODI ('MATE' MODI 
                'ECRO' TABTRA.&BCMOD0) TEPINT ; 
         EPELAST = EXCO (VMIS1*(YOU**(-1))) 'SCAL' 'EPSE' ; 
         EPSTOT = EPELAST + EPSET ; 
 *VMIS2 = contraintes deduites des deformations 
 *equivalentes par la courbe de traction 
         VMIS2 = VARI 'NUAG' MODI (EXCO 'ECRO' MATA 'SIGM') 
                   EPSTOT 'STRESSES' 'SCALAIRE' ; 
       FINSI ; 
   
       SI (EGA MODPLA.&BCMOD0 2) ; 
 *modele est plastique cinematique, cas ou 
 *SIGY et H sont des evolutions 
         EXISCRIT = VRAI ; 
         VMIS22 = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL') ; 
         HSCAL = EXCO MATI 'H' 'SCAL' ; 
         HSCAL = HSCAL CHAN TYPE 'SCALAIRE' ; 
         VMIS2 = VMIS22 + ((CHAN 'STRESSES' MODI HSCAL) * EPSET) ; 
       FINSI ; 
   
       SI (EGA MODPLA.&BCMOD0 3) ; 
 *modele est plastique parfait 
         EXISCRIT = VRAI ; 
         VMIS2 = CHAN 'STRESSES' MODI ((EXCO MATI 'SIGY' 'SCAL') 
                 CHAN TYPE 'SCALAIRE' ) ; 
       FINSI ; 
   
     SINON ; 
 *** modele elastoplastique et modele plastique cinematique 
 ***  avec caracteristiques independantes de la temperature 
   
       SI (EXIS MATI 'ECRO') ; 
 *extraction de la courbe de traction du modele MODI 
         EXISCRIT = VRAI ; 
         TRACTI = EXTR MATI 'ECRO' 1 1 1 ; 
         PEPSO  = EXTR TRACTI 'ABSC' ; 
         PSIGM  = EXTR TRACTI 'ORDO' ; 
         TRACTI = 'EVOL' 'MANU' 'EPSE' PEPSO 'SIGM' PSIGM ; 
         YOU    = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN') ; 
         YOU    = YOU CHAN TYPE 'SCALAIRE' ; 
         EPELAST= EXCO (VMIS1*(YOU**(-1))) 'SCAL' 'EPSE' ; 
         EPSTOT = EPELAST + EPSET ; 
 *VMIS2 = contraintes deduites des deformations 
 *equivalentes par la courbe de traction 
         VMIS2 = 'VARI' MODI EPSTOT TRACTI 'STRESSES' ; 
 *?       VMIS2  = VMIS2 CHAN TYPE 'SCALAIRE' ; 
       FINSI ; 
   
       SI ((EXIS MATI 'SIGY') ET (EXIS MATI 'H')) ; 
 *modele est plastique cinematique traite ici separement du cas 
 *ou SIGY et H sont des evolutions c'est inutile car MAT_INST est 
 *deja instantie en temperature mais il faudra regler le pb de 
 *MODPLA dans son ensemble avec ZONE et une identification 
 *automatique de chacun des sous-modes 
         EXISCRIT = VRAI ; 
         VMIS22 = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL') ; 
         VMIS22 = VMIS22 CHAN TYPE 'SACALAIRE' ; 
         HSCAL  = EXCO MATI 'H' 'SCAL' ; 
         HSCAL  = HSCAL CHAN TYPE 'SCALAIRE' ; 
         VMIS2  = VMIS22 + ((CHAN 'STRESSES' MODI HSCAL) * EPSET) ; 
       FINSI ; 
       SI ((EXIS MATI 'SIGY') ET (NON (EXIS MATI 'H'))) ; 
 *modele est plastique parfait 
         EXISCRIT = VRAI ; 
         VMIS2  = CHAN 'STRESSES' MODI (EXCO MATI 'SIGY' 'SCAL') ; 
         VMIS2  = VMIS2 CHAN TYPE 'SCALAIRE' ; 
       FINSI ; 
   
     FINSI ; 
   
     SI EXISCRIT ; 
       VMIS1P = VMIS1 * MSQ ; 
       VMIS1S = INTG MODI VMIS1P ; 
       VMIS2P = VMIS2 * MSQ ; 
       VMIS2S = INTG MODI VMIS2P ; 
       SI ('NEG' VMIS1S 0.) ; 
         XCRIT = XCRIT + ((VMIS2S/VMIS1S) - 1.) ; 
       FINSI ; 
     FINSI ; 
   
   FIN BCMOD0 ; 
   
   SUPTAB.'CRIT_DECHA_GLOBAL1'.IABC = XCRIT ; 
   
 FINSI ; 
   
   
 ********************************************************* 
 ****** CRITERE LOCAL 1 DE DECHARGE DES CONTRAINTES ****** 
 ********************************************************* 
 *** 
 *** 
 *** 
 *** 
 *** 
   
 SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (IABC  > 0) ET OUICRIT) ; 
   SI BOOL.'MESS' ; 
     MESS 'CRITERE LOCAL 1' ; 
   FINSI ; 
   EXISCRIT = FAUX ; 
   VMITOTF = ZERO MOD_MEC_R STRESSES ; 
   VMITOT1 = ZERO MOD_MEC_R STRESSES ; 
 *initialisation 
   
   REPE BCMOD0 (DIME TABMOD) ; 
   
     MODI  = TABMOD.&BCMOD0 ; 
     MATI  = REDU MAT_INST MODI ; 
     EPSE1 = EXCO VARF 'EPSE' ; 
     EPSE1 =  EPSE1 CHAN TYPE 'SCALAIRE' ; 
     EPSET = REDU EPSE1 MODI ; 
     MSQ   = 'MASQ' 'SUPERIEUR' EPSET 1.E-6 ; 
   
     SI ('EXIS' MODPLA &BCMOD0) ; 
       INST1  = SUPTAB.'SOLUTION_PASAPAS'.'TEMPS'.(IABC-1) ; 
       TEPIN1 = TIRE CHAR1 INST1 'T' ; 
       TEPIN1 = REDU TEPIN1 ELTETA ; 
 *TEPIN1 : temperature absolue au pas precedent 
   
 *modele plastique isotrope 
       SI (EGA MODPLA.&BCMOD0 1) ; 
         MATA = 'VARI' 'NUAG' MODI ('MATE' MODI 
                       'ECRO' TABTRA.&BCMOD0) TEPINT ; 
         VMISF = CHAN ('VMIS' MODI SIGF MATA) TYPE 'SCALAIRE' ; 
 *VMISF : contrainte de Von Mises au pas courant 
         MATA1 = 'VARI' 'NUAG' MODI ('MATE' MODI 
                       'ECRO' TABTRA.&BCMOD0) TEPIN1 ; 
         VMIS1 = CHAN ('VMIS' MODI SIG1 MATA1) TYPE 'SCALAIRE' ; 
 *VMIS1 : contrainte de Von Mises au pas precedent 
       FINSI ; 
   
 *modele plastique cinematique ou plastique parfait 
       SI  ((EGA MODPLA.&BCMOD0 2) OU (EGA MODPLA.&BCMOD0 3)) ; 
         VMISF = CHAN ('VMIS' MODI SIGF MATI) TYPE 'SCALAIRE' ; 
         VMIS1 = CHAN ('VMIS' MODI SIG1 MATI) TYPE 'SCALAIRE' ; 
       FINSI ; 
   
 *pour ces 3 modeles 
       SI   ((EGA MODPLA.&BCMOD0 1) OU 
             (EGA MODPLA.&BCMOD0 2) OU 
             (EGA MODPLA.&BCMOD0 3)) ; 
         EXISCRIT = VRAI ; 
         VMISFP = VMISF * MSQ ; 
         VMIS1P = VMIS1 * MSQ ; 
 *VMISFP : contrainte de Von Mises aux points d'integration plastifies 
 **      au pas courant 
 *VMIS1P : contrainte de Von Mises aux points d'integration plastifies 
 **      au pas precedent 
 *on considere la plastification lorsque EPSET > 1E-6 
         VMISF1P = VMISFP - VMIS1P ; 
 *VMISFP : difference entre la contrainte equivalente au temps de 
 *calcul t et celle au temps precedent (t-1) 
         VMITOTF = VMITOTF + VMISFP ; 
         VMITOT1 = VMITOT1 + VMISF1P ; 
       FINSI ; 
   
     SINON ; 
   
       SI ('EXIS' MATI 'ECRO') ; 
 *modele elastoplastique avec 
 **caracteristiques independantes de la temperature 
         VMISF = CHAN ('VMIS' MODI (REDU SIGF MODI) MATI) 
                      TYPE 'SCALAIRE' ; 
         VMIS1 = CHAN ('VMIS' MODI (REDU SIG1 MODI) MATI) 
                      TYPE 'SCALAIRE' ; 
       FINSI ; 
       SI (EXIS MATI 'SIGY') ; 
 *modele plastique cinematique et plastique parfait avec 
 **caracteristiques independantes de la temperature 
         VMISF = CHAN ('VMIS' MODI SIGF MATI) 
                      TYPE 'SCALAIRE' ; 
         VMIS1 = CHAN ('VMIS' MODI SIG1 MATI) 
                      TYPE 'SCALAIRE' ; 
       FINSI ; 
   
       SI (('EXIS' MATI 'ECRO') OU (EXIS MATI 'SIGY')) ; 
         EXISCRIT = VRAI ; 
         VMISFP   = VMISF * MSQ ; 
         VMIS1P   = VMIS1 * MSQ ; 
         VMISF1P  = VMISFP - VMIS1P ; 
         VMITOTF  = VMITOTF + VMISFP ; 
         VMITOT1  = VMITOT1 + VMISF1P ; 
       FINSI ; 
     FINSI ; 
   
   FIN BCMOD0 ; 
   
   SI EXISCRIT ; 
 *      MSQO = (CHAN 'CHPO' MOD_MEC_R (VMITOT1*((VMITOTF)**(-1)))) 
 *             'MASQ' 'INFERIEUR' 0. ; 
 *      SUPTAB.'CRIT_DECHA_LOCAL1'.IABC = 
 *         (CHAN 'CHPO' MOD_MEC_R ((VMITOT1*((VMITOTF)**(-1)))) * MSQO) ; 
 * #MC 04/11/98 : pour le MASQ, un produit suffit (pas de risque de /0) 
     MSQO = (CHAN 'CHPO' MOD_MEC_R (VMITOT1*VMITOTF)) 
            'MASQ' 'INFERIEUR' 0. ; 
 * #MC 04/11/98 : ou il y a des 0, on met 1.E-10 
     SUPTAB.'CRIT_DECHA_LOCAL1'.IABC = 
        (CHAN 'CHPO' MOD_MEC_R ((VMITOT1*(( 
        VMITOTF+(1.E-10*(VMITOTF 'MASQ' 'EGAL' 0.)) 
        )**(-1)))) * MSQO) ; 
 *lorsque la valeur du critere est positive, c'est-a-dire qu'il n'y a 
 **pas de decharge, celle-ci est ramenee a zero 
   FINSI ; 
   
 FINSI ; 
   
   
 ************************************************************ 
 ****** CRITERE GLOBAL 2 DE DECHARGE DES CONTRAINTES ******** 
 ************************************************************ 
 *** 
 *** 
 *** 
   
 SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (NON BOOL.'REPRI') ET OUICRIT) ; 
   
   SI BOOL.'MESS' ; 
     MESS 'CRITERE GLOBAL 2' ; 
   FINSI ; 
   
   SI ('EXIS' SUPTAB.'SOLUTION_PASAPAS' 'DEFORMATIONS_INELASTIQUES') ; 
     SI BOOL.'PERSO1' ; 
       EPPLASF = ESTIM . 'DEFORMATIONS_INELASTIQUES' ; 
     SINON ; 
       EPPLASF = SUPTAB . 'SOLUTION_PASAPAS' 
                        . 'DEFORMATIONS_INELASTIQUES' . IABC ; 
     FINSI ; 
   
     XCRIT = 1. ; 
     PRO1  = 0. ; 
     PRO2  = 0. ; 
     CRITLOCA = MANU 'CHML' MOD_MEC_R 'SCAL' 1. 'STRESSES' ; 
     NUMERA   = ZERO MOD_MEC_R 'STRESSES' ; 
     DENOMI   = ZERO MOD_MEC_R 'STRESSES' ; 
 *initialisation 
 *glob2 n'est pas calcule si reprise car on ne connait pas i-1 
   
     VMISF = CHAN ('VMIS' MOD_MEC_R SIGF MAT_INST) TYPE 'SCALAIRE' ; 
 *VMISF : contrainte de Von Mises au pas courant 
     SI ('EXIS' SUPTAB VMISMAX) ; 
       MQSIG = 'MASQ' 'SUPERIEUR' 0. ((SUPTAB.VMISMAX) - VMISF) ; 
       VMISF = VMISF + (MQSIG * ((SUPTAB.VMISMAX) - VMISF)) ; 
     FINSI ; 
     SUPTAB.VMISMAX = VMISF ; 
   
     REPE BCMOD0 (DIME TABMOD) ; 
       EXISCRIT = FAUX ; 
       MODI   = TABMOD.&BCMOD0 ; 
       MATI   = REDU MAT_INST MODI ; 
       MAILI  = EXTR MODI 'MAIL' ; 
       EPSEI  = REDU (EXCO VARF 'EPSE') MODI ; 
       EPSEI  = EPSEI CHAN TYPE 'SCALAIRE' ; 
 *       EPPLASI = (SUPTAB.'SOLUTION_PASAPAS'. 
 *                'DEFORMATIONS_INELASTIQUES'.IABC) REDU MODI ; 
       EPPLASI= REDU EPPLASF MODI ; 
       VMISFI = REDU VMISF   MODI ; 
       SIGFI  = REDU SIGF    MODI ; 
       YOU = CHAN 'STRESSES' MODI (EXCO MATI 'YOUN') ; 
       YOU = YOU  CHAN TYPE 'SCALAIRE' ; 
       SI ('EXIS' MODPLA &BCMOD0) ; 
         SI ((EGA MODPLA.&BCMOD0 1) OU 
             (EGA MODPLA.&BCMOD0 2) OU 
             (EGA MODPLA.&BCMOD0 3)) ; 
 *modele plastique isotrope 
 *modele plastique cinematique 
 *modele plastique parfait 
           lm_dein = EXTR epplasi 'COMP' ; 
           lm_defo = EXTR modi 'DEFO' ; 
           ep_u    = nomc lm_dein lm_defo epplasi ; 
           ep_u    = changer ep_u type deformations ; 
 *         PRO1    = PRO1 + (INTG MODI (ENER MODI SIGFI EPPLASI)) ; 
           PRO1    = PRO1 + (INTG MODI (ENER MODI SIGFI ep_u)) ; 
           PRO2    = PRO2 + (INTG MODI (VMISFI * EPSEI)) ; 
           SI (PRO2 'NEG' 0.D0) ; 
             XCRIT = XCRIT + (1. - (PRO1/PRO2)) ; 
           FINS ; 
         FINSI ; 
       SINON ; 
   
         SI (('EXIS' MATI 'ECRO') OU (EXIS MATI 'SIGY')) ; 
 *modele elastoplastique et 
 *modele plastique cinematique et plastique parfait 
 ** avec caracteristiques independantes de la temperature 
           lm_dein = EXTR epplasi 'COMP' ; 
           lm_defo = EXTR modi 'DEFO' ; 
           ep_u    = 'NOMC' lm_dein lm_defo epplasi ; 
           ep_u    = ep_u changer type deformations ; 
 *         PRO1    = PRO1 + (INTG MODI (ENER MODI  SIGFI EPPLASI)) ; 
           PRO1    = PRO1 + (INTG MODI (ENER MODI  SIGFI ep_u)) ; 
           PRO2    = PRO2 + (INTG MODI (VMISFI * EPSEI)) ; 
 *         NUMERA  = NUMERA + (ENER MODI  SIGFI EPPLASI) ; 
           NUMERA  = NUMERA + (ENER MODI  SIGFI ep_u) ; 
           DENOMI  = DENOMI + (VMISFI * EPSEI) ; 
 *         petit traitement pour eviter de diviser par zero 
           MIN0 = MINI 'ABS' DENOMI ; 
           MIN1 = MINI DENOMI ; 
           MAX1 = MAXI DENOMI ; 
           AMP = MAX1 - MIN1 ; 
           SI (AMP < 1.E-15) ; 
             AMP = 1.E-15 ; 
           FINSI ; 
           SI (MIN0 < (1.E-15 * AMP)) ; 
             DENOMI = DENOMI + (1.E-15 * AMP) ; 
           FINSI ; 
           CRITLOCA = CRITLOCA + (1. - (NUMERA / DENOMI)) ; 
         FINSI ; 
       FINSI ; 
     FIN BCMOD0 ; 
   
 * Le maxi sert a corriger le probleme castem sur les EPSE 
 * (ENER MODI  SIGFI EPPLASI) n est pas toujours egal a 
 * (VMISFI * EPSEI) lorsque le chargement est proportionnel 
 * A supprimer quand le pb sera resolu 
     SUPTAB.'CRIT_DECHA_GLOBAL2'  .IABC='MAXI'(prog 0.9999999999 XCRIT) ; 
     SUPTAB.'CRIT_DECHA_GLOBAL2_L'.IABC= CRITLOCA ; 
   
 *mess 'PRO1' , PRO1 , 'PRO2' , PRO2 ,  'XCRIT' , XCRIT ; 
   
   FINSI ; 
 FINSI ; 
   
   
 ********************************************************* 
 ****** CRITERE LOCAL 2 DE DECHARGE DES CONTRAINTES ****** 
 ********************************************************* 
 *** 
 *** 
 *** 
 *** 
   
 SI ((EGA ITYPEF 99) ET BOOL.'PASAPAS' ET (IABC  > 0) ET OUICRIT) ; 
 si(BOOL.'MESS') ;   mess 'CRITERE local 2' ; fins ; 
   
 *initialisation 
         EXISCRIT = FAUX ; 
         CRIT0 = 'ZERO' MOD_MEC_R STRESSES ; 
   
   REPE BCMOD0 (DIME TABMOD) ; 
      MODI = TABMOD.&BCMOD0 ; 
      MATI = REDU MAT_INST MODI ; 
      EPSE1 = EXCO VARF 'EPSE' ; 
      EPSE1 = EPSE1 CHAN TYPE 'SCALAIRE' ; 
      EPSET = REDU EPSE1 MODI ; 
   
     SI (('EXIS' MODPLA &BCMOD0) OU ('EXIS' MATI 'ECRO') 
       OU ('EXIS' MATI 'SIGY')) ; 
            MAT_z = 'MANU' 'CHML' MODI 'YOUN' 1. 'NU' 0. 'EPAI' 1. 
                           TYPE 'CARACTERISTIQUES' 'RIGIDITE' ; 
            EXISCRIT = VRAI ; 
            DSIG = ELAS MODI (SIGF - SIG1) MAT_z ; 
            INV1 = ENER MODI (REDU SIGF MODI) (REDU DSIG MODI) ; 
            SIGFTRA = ENER MODI (REDU SIGF MODI) 
                     (REDU (ELAS MODI SIGF MAT_z) MODI) ; 
            DSIGTRA = ENER MODI (REDU DSIG MODI) 
                  (ELAS MODI DSIG MAT_z) ; 
            NOR1 = SIGFTRA**(1./2) ; 
            DNOR = DSIGTRA**(1./2) ; 
            DENO = NOR1 * DNOR ; 
            CRIT0 = CRIT0 + (INV1 * (DENO**(-1))) ; 
   
     FINSI ; 
   
   FIN BCMOD0 ; 
   
   SI EXISCRIT ; 
        SUPTAB.'CRIT_DECHA_LOCAL2'.IABC = CHAN 'CHPO' MOD_MEC_R CRIT0 ; 
   FINSI ; 
   
   
 FINSI ; 
   
   
   
 *|=====================================================================| 
 *|=======  III. TRAITEMENT DES CHAMPS MECANIQUES  =====================| 
 si(BOOL.'MESS') ;   mess 'TRAITEMENT DES CHAMPS MECANIQUES' ; fins ; 
   
 **************************************************** 
 * ON CHANGE LA TEMPERATURE EN MCHAML AU NOEUD =TEPINT 
 **************************************************** 
   SI (EGA (TYPE TEPINT) 'CHPOINT ') ; 
      TEPINT = REDU TEPINT ELTETA ; 
      TEPINT = CHAN 'CHAM' TEPINT MOD_MEC_R 'NOEUD' 'TEMPERATURES' ; 
 *   FINSI ; 
 *   SI (EGA (TYPE TEPINT) 'MCHAML  ') ; 
   SINON ; 
     SI (EGA (TYPE TEPINT) 'MCHAML  ') ; 
       TEPINT = REDU TEPINT MOD_MEC_R ; 
       TEPINT = CHAN 'NOEUD' MOD_MEC_R TEPINT ; 
     FINSI ; 
   FINSI ; 
 SI (BOOL.'THER' ET (NON BOOL.'COQ')); 
         EPT1 = EPTH MOD_MEC_R MAT_INST TEPINT ; 
         EPT1 VAR2 VAR3 = INVA MOD_MEC_R EPT1 ; 
         EPT1 = CHAN 'CHAM' (EPT1/3.) MOD_MEC_R 'NOEUD' ; 
         EPT1 = EPT1 - OBJUTI.'EPTREF' ; 
 FINSI ; 
   
 *************************************************** 
 ***** GRADIENT DU DEPLACEMENT DEPINT =GRADEP ****** 
 *************************************************** 
 GRADEP = GRAD MOD_MEC_R MAT_INST DEPINT ; 
 GRADEF = TEXT '        ' ; 
 SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
    GRADEF = 'GRAF' MOD_MEC_R MAT_INST DEPINT ; 
 FINSI ; 
   
 *************************************************** 
 ***** CAS DU CONTACT FROTTANT : ON CALCULE WSAUTGR = GRADIENT DU SAUT ****** 
 *************************************************** 
 SI BOOL.'FROT' ; 
 * WDEP = deplacement de la fissure de composante UX ... AX ... 
 * [grad(w)] = grad [w] car linearite (le saut [w] est donne par AX ...) 
 * on utilise un modele liee a la geo de la fissure (cohesif ou contact) 
     WSAUTGR = GRAD OBJCON WDEP ; 
 * SIGCON = sigma*n de composantes SMX... homogene a une contrainte 
 * supporte sur la levre superieure 
     SI (NEG (TYPE SIGCON) 'MCHAML  ') ; 
       SIGCON = REDU SIGCON (extr OBJCON2 'MAILLAGE') ; 
       SIGCON = CHAN 'CHAM' SIGCON OBJCON2 'STRESSES' 'CONTRAINTES' ; 
     FINS ; 
 *   Vsigcon = 'VECTEUR' sigcon objcon (1E-8) ('MOTS' 'SMX' 'SMY' 'SMZ') ; 
 *    'TRACER' vsigcon ('EXTRAIRE' objcon 'MAIL') ; 
     SIGXN = (CHAN (exco SIGCON 'SMX' 'SCAL') TYPE 'SCALAIRE') ; 
     SIGYN = (CHAN (exco SIGCON 'SMY' 'SCAL') TYPE 'SCALAIRE') ; 
     si (ega GDIME 3) ; 
       SIGZN = (CHAN (exco SIGCON 'SMZ' 'SCAL') TYPE 'SCALAIRE') ; 
     fins ; 
 FINSI ; 
   
 *************************************************** 
 ***** GRADIENT DE LA VITESSE VITF   =GRAVIT  ****** 
 *************************************************** 
 SI  BOOL.'J_DYNA' ; 
     GRAVIT = GRAD MOD_MEC_R MAT_INST VITF ; 
     VITF = CHAN 'CHAM'  MOD_MEC_R VITF 'STRESSES' ; 
     ACCF = CHAN 'CHAM'  MOD_MEC_R ACCF 'STRESSES' ; 
 FINSI ; 
   
 *************************************************** 
 ** GRADIENT TEMPERATURE Grad T pour tous elements =TEPEGR 
 ** et Grad Grad T pour les elements massifs seuls (si DJ/DA) =DEPDTGR 
 *************************************************** 
 SI BOOL.'THER' ; 
   SI (NON BOOL.'COQ') ; 
      TEPEGR = GRAD MOD_MEC_R MAT_INST (((EXCO 'T' TEPINT MU1) 
           CHAN TYPE 'SCALAIRE') + CMD000) ; 
                 GR_EPTH = GRAD MOD_MEC_R MAT_INST ((NOMC MU1 EPT1) + CMD000) ; 
     SI  BOOL.'DJ/DA' ; 
        DEPDT = ((EXCO GR1 TEPEGR MU1) + (EXCO GR2 TEPEGR MU2)) 
             CHAN TYPE 'SCALAIRE' ; 
       SI (GDIME EGA 3) ; 
        DEPDT=DEPDT + ((EXCO GR3 TEPEGR MU3) CHAN TYPE 'SCALAIRE') ; 
       FINSI ; 
        DEPDTGR = GRAD MOD_MEC_R MAT_INST (CHAN TYPE 
                  (CHAN 'NOEUD' MOD_MEC_R DEPDT) 'DEPLACEMENTS') ; 
 *       DEPDTGR = GRAD MOD_MEC_R MAT_INST (CHAN 'CHPO' MOD_MEC_R DEPDT) ; 
     FINSI ; 
   SINON ; 
      TEPEGR = GRAD MOD_MEC_R MAT_INST ((((EXCO 'TINF' TEPINT MU1) 
              CHAN TYPE 'SCALAIRE') ET 
              ((EXCO 'T   ' TEPINT MU2)CHAN TYPE 'SCALAIRE') ET 
              ((EXCO 'TSUP' TEPINT MU3)CHAN TYPE 'SCALAIRE')) 
                   + CMD000) ; 
   FINSI ; 
 FINSI ; 
   
 *************************************************** 
 **GRADIENT DE PRESSIONS Grad P (si DJ/DA) =PRESGR 
 *************************************************** 
 SI  BOOL.'DJ/DA' ; 
   SI ('>' (XTX PREINT) 1.E-10) ; 
     M1 = EXTR MOD_MEC_R 'FORC' ; 
     M2 = EXTR MOD_MEC_R 'DEPL' ; 
     REPE B1 (DIME M1) ; 
        F1 = DEP000 + (EXCO (EXTR M1 &B1) PREINT (EXTR M2 &B1)) ; 
     FIN B1 ; 
     PRESGR = GRAD MOD_MEC_R MAT_INST F1 ; 
   FINSI ; 
 FINSI ; 
   
 *************************************************** 
 * PROFIL DE L'ENERGIE DANS L'EPAISSEUR DE LA COQUE 
 *************************************************** 
 SI BOOL.'COQ' ; 
   PEX1 = PROG ; PEN1 = PROG ; 
   REPE NBJ7 (DIME OBJUTI.'MODCOU') ; 
     MCOU1 = OBJUTI.'MODCOU'.&NBJ7 ; 
     EX1 = EXTR (REDU MCOU1 MAT_INST) 'EXCE' 1 1 1 ; 
     E1 = EXTR (REDU MCOU1 MAT_INST) 'EPAI' 1 1 1 ; 
     SI ('<' (E1 / EPAITO) 1.E-4) ; 
        ENR1 = EXTR (REDU MCOU1 ENERM) 'SCAL' 1 1 1 ; 
        PEX1 = PEX1 ET ('PROG' EX1) ; 
        PEN1 = PEN1 ET ('PROG' ENR1) ; 
     FINSI ; 
   FIN NBJ7 ; 
   M1 = MOT ' DANS L EPAISSEUR DE LA COQUE A T =' ; 
   TITR ('CHAI' 'INTEGRALE ' OBJUTI.'MOTTI' M1 INST) ; 
   EVENR = 'EVOL' 'MANU' 'COOR.Z LOCAL' PEX1 OBJUTI.'MOTTI' PEN1 ; 
   SOM1 = ('INTG' EVENR) ; 
   SI (EGA SOM1 0.) ; 
      SOM1 = SOM1 + 1.E-10 ; 
   FINSI ; 
   EVENR = EVENR * EPAITO / SOM1 ; 
   NN = DIME (EXTR EVENR 'ORDO' 1) ; 
   V_SUPE = EXTR NN (EXTR EVENR 'ORDO' 1) ; 
   V_MOYE = EXTR ((NN - 1) / 2) (EXTR EVENR 'ORDO' 1) ; 
   V_INFE = EXTR 1 (EXTR EVENR 'ORDO' 1) ; 
 FINSI ; 
   
 **************************************************** 
 *  RECUPERATION DU NOMBRE DE POINT A AVANCER  =NBOU 
 **************************************************** 
 SI ((EGA GDIME 2) OU BOOL.'COQ') ; 
    NBOU = 1 ; 
 FINSI ; 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
    TTETA*'TABLE' = SUPTAB.'CHAMP_THETA' ; 
   SI  BOOL.'DJ/DA' ; 
      TPI*'TABLE' = SUPTAB.'CHAMP_PI' ; 
   FINSI ; 
    INT = INDE TTETA ; 
   SI (EXIS SUPTAB 'NOEUDS_AVANCES') ; 
     SI (EGA (TYPE (SUPTAB.'NOEUDS_AVANCES')) 'MAILLAGE') ; 
        PMA = CHAN 'POI1' (SUPTAB.'NOEUDS_AVANCES') ; 
        NBOU = ('NBNO' PMA) + 1 ; 
     SINON ; 
         A = SUPTAB.'NOEUDS_AVANCES' ; NBOU = 2 ; 
     FINSI ; 
   SINON ; 
      NBOU = DIME TTETA ; 
   FINSI ; 
 FINSI ; 
   
 ******************************************************** 
 * DENSITE DE MATERIAU EN CAS DE CALCUL DE J DYNAMIQUE ** 
 ******************************************************** 
 SI  BOOL.'J_DYNA' ; 
    RHO1 = REDU (EXCO MAT_INST 'RHO' 'SCAL') MOD_MEC_R ; 
    RHO1 = (CHAN MOD_MEC_R 'STRESSES' RHO1) CHAN TYPE 'SCALAIRE' ; 
 FINSI ; 
   
   
   
 *|=====================================================================| 
 *|======= BOUCLE SUR LES NOEUDS A AVANCER VIRTUELLEMENT =============> 
 REPE BCNOEU NBOU ; 
 ************************************************** 
 * RECUP DU CHAMP TETA ASSOCIE AU NOEUD PM DE NUMERO NUNOE 
 * ET DU CHAMP PI (SI DJ/DA) 
 ************************************************** 
 SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
   SI (&BCNOEU EGA NBOU) ; 
      PM = MOT 'GLOBAL' ; 
      NUNOE = 'CHAI' ' ' PM ' ' ; 
   SINON ; 
      PM = INT.&BCNOEU ; 
     SI (EXIS SUPTAB 'NOEUDS_AVANCES') ; 
       SI (EGA (TYPE (SUPTAB.'NOEUDS_AVANCES')) 'MAILLAGE') ; 
          PM = POIN PMA &BCNOEU ; 
       SINON ; 
          PM = SUPTAB.'NOEUDS_AVANCES' ; 
       FINSI ; 
     FINSI ; 
     si(ega (type PM) 'POINT') ; 
       NUNOE = NOEU PM ; 
     sino ; 
       NUNOE = &BCNOEU ; 
     fins ; 
   FINSI ; 
   TETA = TTETA.PM ; 
   SI  BOOL.'DJ/DA' ; PI = TPI.PM ; FINSI ; 
 FINSI ; 
 SI ((EGA GDIME 2) OU BOOL.'COQ') ; 
   PM = SUPTAB.'FRONT_FISSURE' ; 
   TETA = SUPTAB.'CHAMP_THETA' ; 
   SI  BOOL.'DJ/DA' ; 
      PI = SUPTAB.'CHAMP_PI' ; 
   FINSI ; 
 FINSI ; 
   
 * si(&BOUCMIX ega 1) ; 
 *   vq7 = VECT TETA 'DEPL' 'BLEU' ; 
 *   MESHFR1=SUPTAB.'FRONT_FISSURE' ;MESHFR11 = chan MESHFR1 'POI1' ; 
 * *   trac vq7 (MAILMOD et MESHFR1 et MESHFR11) 'TITR' 'CHAMP_THETA' ; 
 *  trac vq7 ((aret MAILMOD) et MESHFR1 et MESHFR11) 'TITR' 'CHAMP_THETA' ; 
 * fins ; 
   
   
 ************************************************** 
 * GRADIENT, DIVERGENCE DU CHAMP TETA =TETAGR, DIVTETA 
 * CHAMELEM TETA =(TETX,TETY,TETZ) 
 ************************************************** 
 TETA = TETA + DEP000 ; 
 TETAGR = GRAD MOD_MEC_R MAT_INST TETA ; 
 DIVTETA = (EXCO GR1 TETAGR 'SCAL') + 
           (EXCO GR5 TETAGR 'SCAL') + 
           (EXCO GR9 TETAGR 'SCAL') ; 
 DIVTETA= DIVTETA CHAN TYPE 'SCALAIRE' ; 
 *btrolle 2013 : ajout de TETAX, TETAY et TETAZ 
 TETAX= CHAN 'CHAM' MOD_MEC_R (EXCO MU1 TETA 'SCAL') 'SCALAIRE' ; 
 TETAY= CHAN 'CHAM' MOD_MEC_R (EXCO MU2 TETA 'SCAL') 'SCALAIRE' ; 
 TETX = CHAN 'CHAM' MOD_MEC_R (EXCO MU1 TETA 'SCAL') 'STRESSES' ; 
 TETY = CHAN 'CHAM' MOD_MEC_R (EXCO MU2 TETA 'SCAL') 'STRESSES' ; 
 TETX = TETX CHAN TYPE'SCALAIRE' ; 
 TETY = TETY CHAN TYPE'SCALAIRE' ; 
 THET_GR = ZERO MOD_MEC_R 'GRADIENT' ; 
 THET_GR = THET_GR + (NOMC GR1 TETX) + (NOMC GR2 TETY) ; 
 SI (GDIME EGA 3) ; 
    TETAZ= CHAN 'CHAM' MOD_MEC_R (EXCO MU3 TETA 'SCAL') 'SCALAIRE' ; 
    TETZ = CHAN 'CHAM' MOD_MEC_R (EXCO MU3 TETA 'SCAL') 'STRESSES' ; 
    TETZ = TETZ CHAN TYPE'SCALAIRE' ; 
    THET_GR = THET_GR + (NOMC GR3 TETZ) ; 
 FINSI ; 
   
   
 ************************************************** 
 * GRADIENT, DIVERGENCE DU CHAMP PI =PIGR, DIVPI 
 * CHAMELEM PI =(PIX,PIY,PIZ) 
 * ... 
 ************************************************** 
 SI  BOOL.'DJ/DA' ; 
    NORM1 = ((EXCO MU1 PI 'SCAL')**2) + ((EXCO MU2 PI 'SCAL')**2) ; 
   SI (EGA GDIME 3) ; 
      NORM1 = NORM1 + ((EXCO MU3 PI 'SCAL')**2) ; 
   FINSI ; 
    PI = PI + DEP000 ; 
    PI = PI / ('MAXI' (NORM1**0.5)) ; 
    PIGR = GRAD MOD_MEC_R MAT_INST PI ; 
    DIVPI = (EXCO GR1 PIGR 'SCAL') + 
            (EXCO GR5 PIGR 'SCAL') + 
            (EXCO GR9 PIGR 'SCAL') ; 
    DIVPI = DIVPI CHAN TYPE 'SCALAIRE' ; 
    PITAGR = (MOD_MEC_R PIGR * TETAGR) ; 
    DIVPITA = (EXCO GR1 PITAGR 'SCAL') + 
              (EXCO GR5 PITAGR 'SCAL') + 
              (EXCO GR9 PITAGR 'SCAL') ; 
    DIVPITA = DIVPITA CHAN TYPE 'SCALAIRE' ; 
    ADJ = (DIVPITA - (DIVPI * DIVTETA)) ; 
    PIX = CHAN 'CHAM' MOD_MEC_R (EXCO MU1 PI 'SCAL') 'STRESSES' ; 
    PIY = CHAN 'CHAM' MOD_MEC_R (EXCO MU2 PI 'SCAL') 'STRESSES' ; 
    PIX= PIX CHAN TYPE'SCALAIRE' ; 
    PIY= PIY CHAN TYPE'SCALAIRE' ; 
   SI (GDIME EGA 3) ; 
      PIZ = CHAN 'CHAM' MOD_MEC_R (EXCO MU3 PI 'SCAL') 'STRESSES' ; 
      PIZ= PIZ CHAN TYPE'SCALAIRE' ; 
   FINSI ; 
 FINSI ; 
   
 ******************************************************** 
 *********** SI LE MATERIAU N'EST PAS CONSTANT ********** 
 * YOU1 = YOUGR * TETA = (grad E) * TETA 
 * SIGPRIM = (grad D)*TETA*(EPSI elas)   ou grad D =D(grad E,nu) =DMAT 
 * ALF1 = ALFGR*TETA = (grad Alpha)*TETA 
 * DMAT = D(1,nu,ALF1) 
 ******************************************************** 
 SI BOOL.'GRADPROP' ; 
 *** Le coefficient de Poisson est constant *** 
 *    NU1 = REDU (EXCO MAT_INST 'NU' 'SCAL') MOD_MEC_R ; 
 *    NU1 = EXCO NU1 'SCAL' 'NU' ; 
    NU1 = REDU (EXCO MAT_INST 'NU') MOD_MEC_R ; 
    NU1 = NU1 CHAN TYPE 'SCALAIRE' ; 
 ****** Gradient de Module d'young ****** 
   SI BOOL.'GRADYOUN' ; 
      YOU1 = REDU (EXCO MAT_INST 'YOUN' 'SCAL') MOD_MEC_R ; 
      YOU1 = YOU1   CHAN TYPE 'SCALAIRE' ; 
      YOUGR = GRA000 ; I = 0 ; 
     REPE NBJ2 (DIME TABMOD) ; 
        I = I + 1 ; 
        YO1 = CHAN 'STRESSES' TABMOD.I 
             (REDU ((EXCO MAT_INST 'YOUN' MU1) 
     CHAN TYPE 'SCALAIRE') TABMOD.I) ; 
        YOUGR = YOUGR + (GRAD TABMOD.I MAT_INST (YO1 + 
                (REDU CMD001 TABMOD.I))) ; 
 *       YO1 = CHAN 'CHPO' TABMOD.I 
 *            (REDU (EXCO MAT_INST 'YOUN' 'SCAL') TABMOD.I) ; 
 *       YOUGR = YOUGR + (GRAD TABMOD.I MAT_INST (('NOMC' MU1 YO1) 
 *               + (REDU DEP000 (EXTR YO1 'MAIL')))) ; 
     FIN NBJ2 ; 
      YOU1 = (((EXCO GR1 YOUGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R TETX) + 
             (((EXCO GR2 YOUGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R TETY) ; 
     SI (GDIME EGA 3) ; 
       YOU1= YOU1 + (((EXCO GR3 YOUGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            *MOD_MEC_R TETZ) ; 
     FINSI ; 
      YOU1 = (EXCO YOU1 'SCAL' 'YOUN') CHAN TYPE 'SCALAIRE' ; 
      DMAT = 'MATE' MOD_MEC_R 'YOUN' YOU1 'NU' NU1 ; 
      SIGPRIM = ('HOOK' MOD_MEC_R DMAT)*MOD_MEC_R 
                (ELAS MOD_MEC_R SIGF MAT_INST) ; 
   FINSI ; 
 ****** Gradient de Coefficient de Dilatation ****** 
   SI (BOOL.'THER' ET BOOL.'GRADALPH') ; 
      ALF1 = REDU (EXCO MAT_INST 'ALPH' 'SCAL') MOD_MEC_R ; 
      ALF1 = ALF1 CHAN TYPE 'SCALAIRE' ; 
      ALFGR = GRA000 ; I = 0 ; 
     REPE NBJ3 (DIME TABMOD) ; 
        I = I + 1 ; 
        AL1 = CHAN 'STRESSES' TABMOD.I 
             (REDU (EXCO MAT_INST 'ALPH' MU1) TABMOD.I) ; 
        AL1 = AL1 CHAN TYPE 'SCALAIRE' ; 
        ALFGR = ALFGR + (GRAD TABMOD.I MAT_INST (AL1 + 
                (REDU CMD001 TABMOD.I))) ; 
 *!       AL1 = CHAN 'CHPO' TABMOD.I 
 *!             (REDU (EXCO MAT_INST 'ALPH' 'SCAL') TABMOD.I) ; 
 *!       ALFGR = ALFGR + (GRAD TABMOD.I MAT_INST (('NOMC' MU1 AL1) 
 *!               + (REDU DEP000 (EXTR AL1 'MAIL')))) ; 
     FIN NBJ3 ; 
      ALF1 = (((EXCO GR1 ALFGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R TETX) + 
             (((EXCO GR2 ALFGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R TETY) ; 
   
     SI (GDIME EGA 3) ; 
        ALF1=ALF1 + (((EXCO GR3 ALFGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R TETZ) ; 
     FINSI ; 
      ALF1 = EXCO ALF1 'SCAL' 'ALPH' ; 
      ALF1 = ALF1 CHAN TYPE 'SCALAIRE' ; 
      DMAT = 'MATE' MOD_MEC_R 'YOUN' 1. 'NU' NU1 'ALPH' ALF1 ; 
   FINSI ; 
 FINSI ; 
   
 *********************************************** 
 * TEMU  = (Grad T)*THETA 
 * TEMU1 = (Grad T)*PI 
 * TEMU2 = (Grad (Grad T))*PI*THETA 
 * EPSTU = D^-1 sigma^th 
 *         avec sigma^th = (-3lambda-2mu)*alpha*(grad T)*TETA*I 
 * GR_EPTH_THET = (grad epsilon_th)*THETA 
 *********************************************** 
 SI BOOL.'THER' ; 
   SI (NON BOOL.'COQ') ; 
                 TEMU = PSCA TEPEGR THET_GR MGI MGI ; 
      TEMU = CHAN TYPE (EXCO 'SCAL' TEMU 'T') 'TEMPERATURES' ; 
                 GR_EPTH_THET = PSCA GR_EPTH THET_GR MGI MGI ; 
                 GR_EPTH_THET = NOMC 'T' GR_EPTH_THET ; 
                 GR_EPTH_THET = CHAN 'TYPE' GR_EPTH_THET 'TEMPERATURES' ; 
                 MAT0 = MATE MOD_MEC_R 'YOUN' 1. 'NU' 0. 'ALPH' 1. 'TALP' 0. 'TREF' 0. ; 
                 GR_EPTH_THET = EPTH MOD_MEC_R MAT0 GR_EPTH_THET ; 
   SINON ; 
      T1 = (((EXCO GR1 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R TETX) + 
           (((EXCO GR2 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              *MOD_MEC_R TETY) + 
           (((EXCO GR3 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R TETZ) ; 
      T2 = (((EXCO GR4 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
             * MOD_MEC_R TETX) + 
           (((EXCO GR5 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R TETY) + 
           (((EXCO GR6 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R TETZ) ; 
      T3 = (((EXCO GR7 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R TETX) + 
           (((EXCO GR8 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
             * MOD_MEC_R TETY) + 
           (((EXCO GR9 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R TETZ) ; 
      TEMU = CHAN TYPE ((EXCO 'SCAL' T1 'TINF') ET 
              (EXCO 'SCAL' T2 'T   ') ET 
              (EXCO 'SCAL' T3 'TSUP')) 'TEMPERATURES'; 
   FINSI ; 
    EPSTU = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU) MAT_INST ; 
 * 
   SI  BOOL.'DJ/DA' ; 
      TEMU1 = (((EXCO GR1 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIX) + 
              (((EXCO GR2 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIY) ; 
     SI (GDIME EGA 3) ; 
       TEMU1=TEMU1+(((EXCO GR3 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
             * MOD_MEC_R PIZ) ; 
     FINSI ; 
     SI BOOL.'COQ' ; 
        TEMU1 = CHAN TYPE ((EXCO 'SCAL' TEMU1 'T') ET 
                 (EXCO 'SCAL' TEMU1 'TINF') ET 
                 (EXCO 'SCAL' TEMU1 'TSUP')) 'TEMPERATURES' ; 
     SINON ; 
        TEMU1 = CHAN TYPE (EXCO 'SCAL' TEMU1 'T') 'TEMPERATURES' ; 
     FINSI ; 
      EPSTU1 = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU1) MAT_INST ; 
 * 
      TXXPIX = ((EXCO GR1 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIX ; 
      TYXPIY = ((EXCO GR2 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIY ; 
      TXYPIX = ((EXCO GR4 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIX ; 
      TYYPIY = ((EXCO GR5 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
           * MOD_MEC_R PIY ; 
      TEMU2 = (TETX*MOD_MEC_R (TXXPIX + TYXPIY)) + 
              (TETY*MOD_MEC_R (TXYPIX + TYYPIY)) ; 
     SI (GDIME EGA 3) ; 
       TEMU1=TEMU1+(((EXCO GR3 TEPEGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIZ) ; 
        TZXPIZ=((EXCO GR3 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIZ ; 
        TZYPIZ=((EXCO GR6 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R PIZ ; 
        TXZPIX=((EXCO GR7 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIX ; 
        TYZPIY=((EXCO GR8 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIY ; 
        TZZPIY=((EXCO GR9 DEPDTGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIZ ; 
        TEMU2= (TETX*MOD_MEC_R (TXXPIX + TYXPIY + TZXPIZ)) + 
                (TETY*MOD_MEC_R (TXYPIX + TYYPIY + TZYPIZ)) + 
                (TETZ*MOD_MEC_R (TXZPIX + TYZPIY + TZZPIZ)) ; 
     FINSI ; 
     SI BOOL.'COQ' ; 
        TEMU2 = CHAN TYPE ((EXCO 'SCAL' TEMU2 'T') ET 
                 (EXCO 'SCAL' TEMU2 'TINF') ET 
                 (EXCO 'SCAL' TEMU2 'TSUP')) 'TEMPERATURES' ; 
     SINON ; 
        TEMU2 = CHAN TYPE (EXCO 'SCAL' TEMU2 'T') 'TEMPERATURES' ; 
     FINSI ; 
      EPSTU2 = ELAS MOD_MEC_R (THET MOD_MEC_R MAT_INST TEMU2) MAT_INST ; 
   FINSI ; 
 FINSI ; 
   
 * modif sm 
 *********************************************** 
 * CUMDEFI = SIG_{IJ} * (deps_{ij} / dx_{,k}) * thet_{k} 
 *********************************************** 
 CUMDEFI = ZERO MOD_MEC_R 'STRESSES' ; 
 SI BOOL.'DEF_IMP' ; 
   SI (NON BOOL.'COQ') ; 
     LMOEP = EXTR MOD_MEC_R 'DEFO' ; 
     LMOSI = EXTR MOD_MEC_R 'CONT' ; 
     LMOGR = EXTR MOD_MEC_R 'GRAD' ; 
     NIDEF = DIME LMOSI ; 
     REPETER BDEFI NIDEF ; 
       MOEP = EXTR LMOEP &BDEFI ; 
       MOSI = EXTR LMOSI &BDEFI ; 
       EIJ  = EXCO OBJUTI.'DEFI' MOEP  MU1 ; 
       SMIJ = EXCO SIGF   MOSI 'SCAL' ; 
       GREIJ = GRAD MOD_MEC_R MAT_INST 
         ((CHAN (CHAN 'NOEUD' MOD_MEC_R EIJ) 'TYPE' 'SCALAIRE') + CMD000) ; 
       DEIJX = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                 (EXCO GREIJ (EXTR LMOGR 1) 'SCAL')) TYPE 'SCALAIRE') 
             * (CHAN SMIJ TYPE 'SCALAIRE') 
             * TETX ; 
       DEIJY = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                 (EXCO GREIJ (EXTR LMOGR 2) 'SCAL')) TYPE 'SCALAIRE') 
             * (CHAN SMIJ TYPE 'SCALAIRE') 
             * TETY ; 
       CUMDEFI = CUMDEFI + DEIJX + DEIJY ; 
       SI (GDIME EGA 3) ; 
         DEIJZ = (CHAN (CHAN 'STRESSES' MOD_MEC_R 
                   (EXCO GREIJ (EXTR LMOGR 3) 'SCAL')) TYPE 'SCALAIRE') 
               * (CHAN SMIJ TYPE 'SCALAIRE') 
               * TETZ ; 
         CUMDEFI = CUMDEFI + DEIJZ ; 
       FINSI ; 
     FIN BDEFI ; 
   FINSI ; 
 FINSI ; 
   
 *********************************************** 
 * PEMU1 = (Grad P)*TETA 
 * PEMU2 = (Grad P)*(Grad PI)*TETA 
 *********************************************** 
 SI  BOOL.'DJ/DA' ; 
 SI ('>' (XTX PREINT) 1.E-10) ; 
    F1 = (((EXCO GR1 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIX) + 
         (((EXCO GR2 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R PIY) ; 
    F2 = (((EXCO GR4 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIX) + 
         (((EXCO GR5 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R PIY) ; 
    PEMU = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                                 (EXCO 'SCAL' F2 MF2)) ; 
   SI (EGA GDIME 3) ; 
      F1=F1+ (((EXCO GR3 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIZ) ; 
      F2=F2+ (((EXCO GR6 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIZ) ; 
      F3 = (((EXCO GR7 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIX) + 
           (((EXCO GR8 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R PIY) + 
           (((EXCO GR9 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                  * MOD_MEC_R PIZ) ; 
      PEMU = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
             (EXCO 'SCAL' F2 MF2) ET (EXCO 'SCAL' F3 MF3)) ; 
   FINSI ; 
 * 
    F1 = (((EXCO GR1 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              * MOD_MEC_R TETX) + 
         (((EXCO GR2 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R TETY) ; 
    F2 = (((EXCO GR4 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R TETX) + 
         (((EXCO GR5 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
            * MOD_MEC_R TETY) ; 
    PEMU1 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
                                  (EXCO 'SCAL' F2 MF2)) ; 
   SI (EGA GDIME 3) ; 
      F1=F1+ (((EXCO GR3 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                     * MOD_MEC_R TETZ) ; 
      F2=F2+ (((EXCO GR6 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                 * MOD_MEC_R TETZ) ; 
      F3=(((EXCO GR7 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R TETX) + 
           (((EXCO GR8 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R TETY) + 
           (((EXCO GR9 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R TETZ) ; 
      PEMU1 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F1 MF1) ET 
              (EXCO 'SCAL' F2 MF2) ET (EXCO 'SCAL' F3 MF3)) ; 
   FINSI ; 
 * 
    F1= (((EXCO GR1 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                 * MOD_MEC_R TETX) + 
         (((EXCO GR2 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               * MOD_MEC_R TETY) ; 
    F2= (((EXCO GR4 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R TETX) + 
         (((EXCO GR5 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                  * MOD_MEC_R TETY) ; 
   SI (EGA GDIME 3) ; 
      F1=F1 + (((EXCO GR3 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                *MOD_MEC_R TETZ) ; 
      F2=F2 + (((EXCO GR6 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R TETZ) ; 
      F3 = (((EXCO GR7 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R TETX) + 
           (((EXCO GR8 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                 *MOD_MEC_R TETY) + 
           (((EXCO GR9 PIGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                *MOD_MEC_R TETZ) ; 
   FINSI ; 
    F4 = (((EXCO GR1 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                *MOD_MEC_R F1) + 
         (((EXCO GR2 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
              *MOD_MEC_R F2) ; 
    F5 = (((EXCO GR4 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                *MOD_MEC_R F1) + 
         (((EXCO GR5 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
               *MOD_MEC_R F2) ; 
    PEMU2 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F4 MF1) ET 
                                  (EXCO 'SCAL' F5 MF2)) ; 
   SI (EGA GDIME 3) ; 
      F4 = F4 + (((EXCO GR3 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                  * MOD_MEC_R F3) ; 
      F5 = F5 + (((EXCO GR6 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R F3) ; 
      F6 = (((EXCO GR7 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                  * MOD_MEC_R F1) + 
           (((EXCO GR8 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                * MOD_MEC_R F2) + 
           (((EXCO GR9 PRESGR 'SCAL')CHAN TYPE 'SCALAIRE') 
                  * MOD_MEC_R F3) ; 
      PEMU2 = CHAN 'CHPO' MOD_MEC_R ((EXCO 'SCAL' F4 MF1) ET 
              (EXCO 'SCAL' F5 MF2) ET (EXCO 'SCAL' F6 MF3)) ; 
   FINSI ; 
 FINSI ; 
 FINSI ; 
   
 *********************************************** 
 * DANS LE CAS DE CALCUL DE DJ/DA 
 * U^aux=A_DEPI  et  SIGMA^aux=A_SIGF 
 *********************************************** 
 SI  BOOL.'DJ/DA' ; 
    GRAD11 = (MOD_MEC_R GRADEP * PIGR) ; 
    EPXX1 = (EXCO GR1 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE' ; 
    EPYY1 = (EXCO GR5 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE' ; 
    EPZZ1 = (EXCO GR9 GRAD11 'SCAL') CHAN TYPE 'SCALAIRE' ; 
    GAXY1 = ((EXCO GR2 GRAD11 'SCAL') + (EXCO GR4 GRAD11 'SCAL')) 
                CHAN TYPE 'SCALAIRE' ; 
    GAXZ1 = ((EXCO GR3 GRAD11 'SCAL') + (EXCO GR7 GRAD11 'SCAL')) 
              CHAN TYPE 'SCALAIRE' ; 
    GAYZ1 = ((EXCO GR6 GRAD11 'SCAL') + (EXCO GR8 GRAD11 'SCAL')) 
             CHAN TYPE 'SCALAIRE' ; 
   SI (GDIME EGA 3) ; 
      EPSIA1 = 'MANU' 'CHML' MOD_MEC_R EP1 EPXX1 EP2 
                EPYY1 EP3 EPZZ1 EP4 GAXY1 EP5 GAXZ1 EP6 
                GAYZ1 TYPE 'DEFORMATIONS' 'STRESSES' ; 
   SINON ; 
      EPSIA1 = 'MANU' 'CHML' MOD_MEC_R EP1 EPXX1 EP2 
                EPYY1 EP3 EPZZ1 EP4 GAXY1 
               TYPE 'DEFORMATIONS' 'STRESSES' ; 
   FINSI ; 
   SI BOOL.'THER' ; EPSIA1 = EPSIA1 + EPSTU1 ; FINSI ; 
    F11 = BSIG MOD_MEC_R (((HOOK MOD_MEC_R MAT_INST)*MOD_MEC_R EPSIA1) 
        - (MOD_MEC_R SIGF*DIVPI)) + (FOFI MOD_MEC_R SIGF PIGR) ; 
   SI ((XTX PREINT) > 1.E-10) ; 
      F11 = F11 + PEMU + (PREINT*(CHAN 'CHPO' MOD_MEC_R DIVPI)) ; 
   FINSI ; 
    A_PREI = OBJUTI.'FOR000' ; 
    A_DEPI = REDU (RESO F11 RIGTOT) ELTETA ; 
    A_SIGF = MOD_MEC_R (HOOK MOD_MEC_R MAT_INST)* 
                    ((EPSI MOD_MEC_R A_DEPI) - EPSIA1) ; 
 FINSI ; 
   
 *************************************************** 
 * GRADIENT DU DEPLACEMENT AUX A_DEPI =A_DEPGR 
 * SI DJ/DA ou SI DECOUPLAGE  (sauf si A_DEPGR existe deja) 
 *************************************************** 
 SI ( BOOL.'DJ/DA'  OU  BOOL.'DECOUPLAGE' ) ; 
    si (NEG (TYPE A_DEPGR) 'MCHAML') ; 
      A_DEPGR = GRAD MOD_MEC_R MAT_INST A_DEPI ; 
    fins ; 
    A_DEPGF = TEXT '        ' ; 
    SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
      A_DEPGF = 'GRAF' MOD_MEC_R MAT_INST A_DEPI ; 
    FINSI ; 
 FINSI ; 
   
 *********************************************** 
 * DEP0 = (grad U)*THETA 
 *********************************************** 
 LO1 = ((BOOL.'J') OU  BOOL.'C*'  OU  BOOL.'C*H' 
         OU  BOOL.'DJ/DA'  OU  BOOL.'J_DYNA' ) 
         ET ('>' (XTX PREINT) 1.E-10) ; 
 LO2 = FAUX ; 
 SI  BOOL.'DECOUPLAGE' ; 
    LO2 = '>' (XTX A_PREI) 1.E-10 ; 
 FINSI ; 
 SI (LO1 OU LO2) ; 
    GRADCH = CHAN 'CHPO' MOD_MEC_R GRADEP ; 
 *  mess 'gcalcul : CHAN CHPO grad(U)' ; 
 *bp : on se ramene a un chpoint pour faire XTY avec preint ensuite 
 *     on moyenne avce CHAN CHPO, pourrait on l'eviter? 
    DEPLX = ((EXCO GR1 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
            ((EXCO GR2 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) ; 
    DEPLY = ((EXCO GR4 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
            ((EXCO GR5 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) ; 
    DEP0 = ('NOMC' DEPLX MU1) + ('NOMC' DEPLY MU2) ; 
   SI (GDIME EGA 3) ; 
      DEPLX = DEPLX + 
              ((EXCO GR3 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEPLY = DEPLY + 
              ((EXCO GR6 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEPLZ = ((EXCO GR7 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
              ((EXCO GR8 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) + 
              ((EXCO GR9 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEP0 = ('NOMC' DEPLX MU1) + ('NOMC' DEPLY MU2) + 
             ('NOMC' DEPLZ MU3) ; 
   FINSI ; 
   SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
      GRAFCH = CHAN 'CHPO' MOD_MEC_R GRADEF ; 
      BXX = EXCO 'BX,X' GRAFCH 'SCAL' ; 
      BXY = EXCO 'BX,Y' GRAFCH 'SCAL' ; 
      BYX = EXCO 'BY,X' GRAFCH 'SCAL' ; 
      BYY = EXCO 'BY,Y' GRAFCH 'SCAL' ; 
      DEPFX = 'NOMC' 'RX' ( (BXX*(EXCO 'UX' TETA 'SCAL'))+ 
                            (BXY*(EXCO 'UY' TETA 'SCAL')) ) ; 
      DEPFY = 'NOMC' 'RY' ( (BYX*(EXCO 'UX' TETA 'SCAL'))+ 
                            (BYY*(EXCO 'UY' TETA 'SCAL')) ) ; 
      DEP0 = DEP0 + DEPFX + DEPFY ; 
   FINSI ; 
 FINSI ; 
   
   
 *************************************************************** 
 * S'il y a une pression sur la fissure, on calcule 
 * GRUTE = (grad U)*THETA sur les elements du modele de pression 
 * et dans la zone d'etude (ou le champ TETA est definit) 
 *************************************************************** 
 SI (EXIS OBJUTI 'MODE_PRESSION_FISSURE') ; 
 * on recupere le front de fissure que l'on passe en maillage de POI1 
   FF = SUPTAB.'FRONT_FISSURE' ; 
   SI (EGA (TYPE FF) 'POINT') ; 
     FF1 = MANU 'POI1' FF ; 
   FINSI ; 
   SI (EGA (TYPE FF) 'MAILLAGE') ; 
     FF1 = CHAN 'POI1' FF ; 
   FINSI ; 
 * on isole les elements de la fissure ou la pression s'applique et ou le 
 * champ teta est definit 
   FISSP = EXTR (OBJUTI . 'MODE_PRESSION_FISSURE') 'MAIL' ; 
   PFISSP = CHAN 'POI1' FISSP ; 
   FISSP = FISSP ELEM 'APPU' 'STRI' MAILMOD ; 
   MODPFT = VIDE 'MMODEL' ; 
   GRADEPF = VIDE 'MCHAML' ; 
 * on interpole le gradient de deplacement (GRADEP) sur les elements du 
 * modele de pression touchant la levre inferieure 
   SI (EXIS SUPTAB 'LEVRE_INFERIEURE') ; 
     FISI = INTE FISSP (SUPTAB . 'LEVRE_INFERIEURE') ; 
     MODPFI = REDU MODPF FISI ; 
     MP1 = DIFF (CHAN 'POI1' FISI) FF1 ; 
     EL1 = MAILMOD ELEM 'APPU' 'LARG' MP1 ; 
     MOD_MEC_R1 = REDU MOD_MEC_R EL1 ; 
     GRADEP1 = REDU GRADEP MOD_MEC_R1 ; 
     GRADEP1 = CHAN 'CHAM' GRADEP1 MOD_MEC_R1 'NOEUD' ; 
     GRUI = PROI GRADEP1 MODPFI 'STRESSES' ; 
     MODPFT = MODPFT ET MODPFI ; 
     GRADEPF = GRADEPF ET GRUI ; 
   FINSI ; 
 * on interpole le gradient de deplacement (GRADEP) sur les elements du 
 * modele de pression touchant la levre superieure 
   SI (EXIS SUPTAB 'LEVRE_SUPERIEURE') ; 
     FISS = INTE FISSP (SUPTAB . 'LEVRE_SUPERIEURE') ; 
     MODPFS = REDU MODPF FISS ; 
     MP1 = DIFF (CHAN 'POI1' FISS) FF1 ; 
     EL1 = MAILMOD ELEM 'APPU' 'LARG' MP1 ; 
     MOD_MEC_R1 = REDU MOD_MEC_R EL1 ; 
     GRADEP1 = REDU GRADEP MOD_MEC_R1 ; 
     GRADEP1 = CHAN 'CHAM' GRADEP1 MOD_MEC_R1 'NOEUD' ; 
     GRUS = PROI GRADEP1 MODPFS 'STRESSES' ; 
     MODPFT = MODPFT ET MODPFS ; 
     GRADEPF = GRADEPF ET GRUS ; 
   FINSI ; 
   GRADEPF = REDU GRADEPF MODPFT ; 
 * on interpole le champ theta (TETA) sur les elements du modele de 
 * pression ==> TETAF 
   TETAF = REDU TETA FISSP ; 
   TETAF = CHAN 'CHAM' MODPFT TETAF 'STRESSES' ; 
 * on fait ensuite le produit (GRADEPF * TETAF) ==> GRUTE 
   LCT = EXTR TETAF   'COMP' ; 
   LCG = EXTR GRADEPF 'COMP' ; 
   SI (EGA GDIME 2) ; 
     LCG12 = EXTR LCG (LECT 1 2) ; 
     LCG45 = EXTR LCG (LECT 4 5) ; 
     GRUTE1 = PSCA GRADEPF TETAF LCG12 LCT ; 
     GRUTE2 = PSCA GRADEPF TETAF LCG45 LCT ; 
     GRUTE  = (NOMC (EXTR LCT 1) GRUTE1) ET 
              (NOMC (EXTR LCT 2) GRUTE2) ; 
   FINSI ; 
   SI (EGA GDIME 3) ; 
     LCG123 = EXTR LCG (LECT 1 2 3) ; 
     LCG456 = EXTR LCG (LECT 4 5 6) ; 
     LCG789 = EXTR LCG (LECT 7 8 9) ; 
     GRUTE1 = PSCA GRADEPF TETAF LCG123 LCT ; 
     GRUTE2 = PSCA GRADEPF TETAF LCG456 LCT ; 
     GRUTE3 = PSCA GRADEPF TETAF LCG789 LCT ; 
     GRUTE  = (NOMC (EXTR LCT 1) GRUTE1) ET 
              (NOMC (EXTR LCT 2) GRUTE2) ET 
              (NOMC (EXTR LCT 3) GRUTE3) ; 
   FINSI ; 
   GRUTE = CHAN 'TYPE' GRUTE 'FORCES' ; 
 FINSI ; 
   
   
 *********************************************** 
 * DEP1 = (grad A_DEPI)*THETA 
 *********************************************** 
 LO1 =  BOOL.'DJ/DA'  ET ('>' (XTX PREINT) 1.E-10) ; 
 LO2 = FAUX ; 
 SI  BOOL.'DECOUPLAGE' ; 
    LO2 = ('>' (XTX A_PREI) 1.E-10) OU ('>' (XTX PREINT) 1.E-10) ; 
 FINSI ; 
 SI (LO1 OU LO2) ; 
 *  mess 'gcalcul : CHAN CHPO grad(U^aux)' ; 
    GRADCH = CHAN 'CHPO' MOD_MEC_R A_DEPGR ; 
 *bp : on se ramene a un chpoint pour faire XTY avec preint ensuite 
 *     on moyenne avec CHAN CHPO, pourrait on l'eviter? 
    DEPLX = ((EXCO GR1 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
            ((EXCO GR2 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) ; 
    DEPLY = ((EXCO GR4 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
            ((EXCO GR5 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) ; 
    DEP1 = ('NOMC' DEPLX MU1) + ('NOMC' DEPLY MU2) ; 
   SI (GDIME EGA 3) ; 
      DEPLX = DEPLX + 
              ((EXCO GR3 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEPLY = DEPLY + 
              ((EXCO GR6 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEPLZ = ((EXCO GR7 GRADCH 'SCAL')*(EXCO MU1 TETA 'SCAL')) + 
              ((EXCO GR8 GRADCH 'SCAL')*(EXCO MU2 TETA 'SCAL')) + 
              ((EXCO GR9 GRADCH 'SCAL')*(EXCO MU3 TETA 'SCAL')) ; 
      DEP1 = ('NOMC' DEPLX MU1) + ('NOMC' DEPLY MU2) + 
             ('NOMC' DEPLZ MU3) ; 
   FINSI ; 
   SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
      GRAFCH = CHAN 'CHPO' MOD_MEC_R GRADEF ; 
      BXX = EXCO 'BX,X' GRAFCH 'SCAL' ; 
      BXY = EXCO 'BX,Y' GRAFCH 'SCAL' ; 
      BYX = EXCO 'BY,X' GRAFCH 'SCAL' ; 
      BYY = EXCO 'BY,Y' GRAFCH 'SCAL' ; 
      DEPFX = 'NOMC' 'RX' ( (BXX*(EXCO 'UX' TETA 'SCAL'))+ 
                            (BXY*(EXCO 'UY' TETA 'SCAL')) ) ; 
      DEPFY = 'NOMC' 'RY' ( (BYX*(EXCO 'UX' TETA 'SCAL'))+ 
                            (BYY*(EXCO 'UY' TETA 'SCAL')) ) ; 
      DEP1 = DEP1 + DEPFX + DEPFY ; 
   FINSI ; 
 FINSI ; 
 *********************************************** 
 * Termes supplemenetaire en Dynamique 
 * VCARE = V*V 
 * GRUTV = (grad U)*THETA*V      (Attigui) 
 * GRVTV = V^T * (grad V)*THETA  (BP) 
 * GRWTU = W^T * (grad U)*THETA  (BP) 
 *********************************************** 
 SI  BOOL.'J_DYNA' ; 
   VCARE =( ((EXCO MU1 VITF 'SCAL')**2) + ((EXCO MU2 VITF 'SCAL')**2) ) 
             CHAN TYPE 'SCALAIRE' ; 
   DEPFX = (((EXCO GR1 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
           (((EXCO GR2 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETY) ; 
   DEPFY = (((EXCO GR4 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
           (((EXCO GR5 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE') *TETY) ; 
   VITFX = (((EXCO GR1 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
           (((EXCO GR2 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETY) ; 
   VITFY = (((EXCO GR4 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETX) + 
           (((EXCO GR5 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE') *TETY) ; 
   SI (EGA GDIME 3) ; 
     VCARE=VCARE +(((EXCO MU3 VITF 'SCAL')**2)CHAN TYPE 'SCALAIRE') ; 
     DEPFX=DEPFX +(((EXCO GR3 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     DEPFY=DEPFY +(((EXCO GR6 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     DEPFZ = (((EXCO GR7 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETX) + 
             (((EXCO GR8 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETY) + 
             (((EXCO GR9 GRADEP 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     VITFX=VITFX +(((EXCO GR3 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     VITFY=VITFY +(((EXCO GR6 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     VITFZ = (((EXCO GR7 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETX) + 
             (((EXCO GR8 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETY) + 
             (((EXCO GR9 GRAVIT 'SCAL')CHAN TYPE 'SCALAIRE')*TETZ) ; 
     GRUTV = ((EXCO MU1 VITF 'SCAL')*DEPFX) + 
             ((EXCO MU2 VITF 'SCAL')*DEPFY) + 
             ((EXCO MU3 VITF 'SCAL')*DEPFZ) ; 
     GRWTU = ((EXCO MU1 ACCF 'SCAL')*DEPFX) + 
             ((EXCO MU2 ACCF 'SCAL')*DEPFY) + 
             ((EXCO MU3 ACCF 'SCAL')*DEPFZ) ; 
     GRVTV = ((EXCO MU1 VITF 'SCAL')*VITFX) + 
             ((EXCO MU2 VITF 'SCAL')*VITFY) + 
             ((EXCO MU3 VITF 'SCAL')*VITFZ) ; 
   SINON ; 
      GRUTV = ((EXCO MU1 VITF 'SCAL')*DEPFX) + 
              ((EXCO MU2 VITF 'SCAL')*DEPFY) ; 
     GRWTU = ((EXCO MU1 ACCF 'SCAL')*DEPFX) + 
             ((EXCO MU2 ACCF 'SCAL')*DEPFY) ; 
     GRVTV = ((EXCO MU1 VITF 'SCAL')*VITFX) + 
             ((EXCO MU2 VITF 'SCAL')*VITFY) ; 
   FINSI ; 
 FINSI ; 
 *|=====================================================================| 
 *|=======  IV. CALCUL DE J,C*,C*(h) ou J_DYNA  ========================| 
   
 *********************************************** 
 * S10 = w*(div THETA) 
 * S20 = sigma*(grad U)*(grad THETA) 
 * S40 = Tr(sigma)*Alpha*(Grad T)*THETA 
 * S50 = F*(grad U)*THETA 
 * S60 = 0.5*(grad D)*THETA*(EPSI elas)*(EPSI elas) 
 * S70 = Tr(sigma)*T*(Grad Alpha)*THETA 
 * S100 = (W(b) - W(a))*TETA(x) 
 * S110 = SIGF*n*[ (dU/dX)(b) - (dU/dX)(a) ]*TETA(x) 
 * S120 = wvmis*(Grad T)*THETA 
 *     ou wvmis = SOME d(Von_mises)/d(Temperature) d(EPSE) 
 *********************************************** 
 * Termes supplementaires pour le J dynamique (Formulation de Attigui) 
 * S130 = 0.5*RHO*(V^2)*(div THETA) 
 * S140 = [Delta (RHO*V*(grad U)*THETA)]/(Delta Temps) 
 * Termes supplementaires pour le J dynamique (Formulation de BP) 
 * S130 = -0.5*RHO*(V^2)*(div THETA) 
 * S140 =  RHO*W*(grad U)*THETA 
 * S141 = -RHO*V*(grad V)*THETA 
 *********************************************** 
 * Termes supplementaires pour le J en grands-deplacements 
 * S150 = sigma*((grad U)t)*(grad U)*(grad THETA) 
 *********************************************** 
 *********************************************** 
 * Termes supplementaires pour un chaergement en deformation imposee (modif sm) 
 * S160 = sigma*(deps/dx)*(THETA) 
 *      = SIG_{IJ} * (deps^{imp}_{ij} / dx_{,k}) * thet_{k} 
 *********************************************** 
 * Termes supplementaires pour le contact frottant (modif BP,BT) 
 * S111 = SIGF*n*[ (dU/dX)(b) - (dU/dX)(a) ]*TETA(x) 
 *********************************************** 
   
   
 SI ((BOOL.'J') OU  BOOL.'C*' OU BOOL.'C*H' OU  BOOL.'J_DYNA' ) ; 
         GMCANI = 0. ; 
         GTERMI = 0. ; 
         GPRESS = 0. ; 
   
         S10 = INTG MOD_MEC_R (ENERM*MOD_MEC_R DIVTETA) MAT2 ; 
         GMCANI = GMCANI - S10 ; 
         SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
                 S20 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (GRADEP*MOD_MEC_R TETAGR) (GRADEF*MOD_MEC_R TETAGR)) ; 
         SINON ; 
                 S20 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (GRADEP*MOD_MEC_R TETAGR)) MAT2 ; 
         FINSI ; 
         GMCANI = GMCANI + S20 ; 
         SI BOOL.'GRANDS_DEP' ; 
                 SI (BOOL.'COQ' ET BOOL.'EL_LIN') ; 
                         S150 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                                         (((TAGR GRADEP)*MOD_MEC_R GRADEP)*MOD_MEC_R TETAGR) 
                                         (((TAGR GRADEF)*MOD_MEC_R GRADEF)*MOD_MEC_R TETAGR)) ; 
                 SINON ; 
                         S150 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
                                         (((TAGR GRADEP)*MOD_MEC_R GRADEP)*MOD_MEC_R TETAGR)) MAT2 ; 
                 FINSI ; 
                 GMCANI = GMCANI + S150 ; 
         FINSI ; 
         SI (BOOL.'GRADPROP' ET BOOL.'GRADYOUN') ; 
                 S60 = INTG MOD_MEC_R (0.5*(ENER MOD_MEC_R 
                                 SIGPRIM (ELAS MOD_MEC_R SIGF MAT_INST))) MAT2 ; 
                 GMCANI = GMCANI - S60 ; 
         FINSI ; 
         SI (((DIME LINTER) > 0) ET (NON BOOL.'PARAL')) ; 
                 I = 0 ; IND1 = INDE LINTER ; 
                 REPE NBJ4 (DIME IND1) ; 
                         I = I + 1 ; 
                         LE1 = IND1.&NBJ4 ; 
                         L1 = LINTER.LE1 ; 
                         M1 = TABMOD.(EXTR LE1 1) ; 
                         M2 = TABMOD.(EXTR LE1 2) ; 
                         OBJINT = MODE L1 'MECANIQUE' 'ELASTIQUE' ; 
                         TETXL = REDU L1 (EXCO MU1 TETA 'SCAL') ; 
                         TETXLC = CHAN 'CHAM' OBJINT TETXL 'STRESSES' ; 
 *** 
                         ENEMA = REDU L1 (CHAN 'CHPO' M1 (REDU M1 ENERM)) ; 
                         ENEMB = REDU L1 (CHAN 'CHPO' M2 (REDU M2 ENERM)) ; 
                         ENRMAL = CHAN 'CHAM' OBJINT ENEMA 'STRESSES' ; 
                         ENRMBL = CHAN 'CHAM' OBJINT ENEMB 'STRESSES' ; 
                         S100 = S100 + (INTG OBJINT 
                                         ((ENRMBL - ENRMAL) * OBJINT TETXLC) MAT2) ; 
 *** 
                         GRADA = REDU L1 (CHAN 'CHPO' M1 (REDU M1 GRADEP)) ; 
                         GRADB = REDU L1 (CHAN 'CHPO' M2 (REDU M2 GRADEP)) ; 
                         UXXAL =CHAN 'CHAM' OBJINT (EXCO GR1 GRADA 'SCAL') 'STRESSES' ; 
                         UXXBL =CHAN 'CHAM' OBJINT (EXCO GR1 GRADB 'SCAL') 'STRESSES' ; 
                         UYXAL =CHAN 'CHAM' OBJINT (EXCO GR4 GRADA 'SCAL') 'STRESSES' ; 
                         UYXBL =CHAN 'CHAM' OBJINT (EXCO GR4 GRADB 'SCAL') 'STRESSES' ; 
                         SIGML =REDU L1 (CHAN 'CHPO' MOD_MEC_R SIGF) ; 
                         SIXXL =CHAN 'CHAM' OBJINT (EXCO SM1 SIGML 'SCAL') 'STRESSES' ; 
                         SIXYL =CHAN 'CHAM' OBJINT (EXCO SM4 SIGML 'SCAL') 'STRESSES' ; 
                         AAAA1 = (SIXXL * OBJINT (UXXBL - UXXAL)) + 
                                         (SIXYL * OBJINT (UYXBL - UYXAL)) ; 
                         S110 = S110 + (INTG OBJINT (AAAA1*OBJINT TETXLC) MAT2) ; 
                 FIN NBJ4 ; 
                 GMCANI = GMCANI - S100 + S110 ; 
         FINSI ; 
 * Termes supplementaire en Dynamique ********** 
         SI  BOOL.'J_DYNA' ; 
                 S130 = INTG MOD_MEC_R (0.5*(RHO1 * VCARE * DIVTETA)) MAT2 ; 
                 S140 = INTG MOD_MEC_R (RHO1 * GRWTU) MAT2 ; 
                 S141 = INTG MOD_MEC_R (RHO1 * GRVTV) MAT2 ; 
                 GMCANI = GMCANI - S130 + S140 - S141 ; 
         FINSI ; 
 * Termes supplementaire pour le contact frottant (btrolle 19/02/2013) 
         SI (BOOL.'FROT') ; 
 * teta 
                 TETXC = PROI OBJCON2 TETAX 'STRESSES' ; 
                 TETYC = PROI OBJCON2 TETAY 'STRESSES' ; 
                 SI (EGA GDIME 3) ; 
                         TETZC = PROI OBJCON2 TETAZ 'STRESSES' ; 
                 FINSI ; 
 * [grad(w)] = grad [w] = WSAUTGR 
 * sigma*n 
                 AAAAX = (SIGXN * (CHAN (exco WSAUTGR AX,X 'SCAL') TYPE 'SCALAIRE')) 
                                 + (SIGYN * (CHAN (exco WSAUTGR AY,X 'SCAL') TYPE 'SCALAIRE')) ; 
                 AAAAY = (SIGXN * (CHAN (exco WSAUTGR AX,Y 'SCAL') TYPE 'SCALAIRE')) 
                                 + (SIGYN * (CHAN (exco WSAUTGR AY,Y 'SCAL') TYPE 'SCALAIRE')) ; 
                 SI (EGA GDIME 3) ; 
                         AAAAX = AAAAX 
                                         + (SIGZN *  (CHAN(exco WSAUTGR AZ,X) TYPE 'SCALAIRE')) ; 
                         AAAAY = AAAAY 
                                         + (SIGZN *  (CHAN(exco WSAUTGR AZ,Y) TYPE 'SCALAIRE')) ; 
                         AAAAZ = (SIGXN *  (CHAN(exco WSAUTGR AX,Z) TYPE 'SCALAIRE')) 
                                         + (SIGYN *  (CHAN(exco WSAUTGR AY,Z) TYPE 'SCALAIRE')) 
                                         + (SIGZN *  (CHAN(EXCO WSAUTGR AZ,Z) TYPE 'SCALAIRE')) ; 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) + (AAAAY * OBJCON2 TETYC) 
                                                 + (AAAAZ * OBJCON2 TETZC) ; 
                 SINON ; 
                         AAAA111 = (AAAAX * OBJCON2 TETXC) + (AAAAY * OBJCON2 TETYC) ; 
                 FINSI ; 
 *    AAAA111 = 'MANUEL' CHML objcon 'SCAL' 1 TYPE 'SCALAIRE' 'STRESSES' ; 
                 S111 = INTG OBJCON2 AAAA111 ; mess 'S111=' S111 ; 
                 GMCANI = GMCANI - S111 ; 
         SINON ; 
                 S111 = 0.0 ; 
         FINSI ; 
 * fin du cas contact frottant (btrolle 19/02/2013) 
   
         S50 = 0. ; 
         SI ((XTX PREINT) > 1.E-10) ; 
                 S50 = XTY PREINT DEP0 MFI MUI ; 
         FINSI ; 
         SI (EXIS OBJUTI 'MODE_PRESSION_FISSURE') ; 
                 PNF = REDU PNF MODPFT ; 
                 LC1 = EXTR PNF   'COMP' ; 
                 LC2 = EXTR GRUTE 'COMP' ; 
                 PGRU = MANU 'CHML' MODPFT 'SCAL' 0. 'STRESSES' ; 
                 REPE B1 (DIME LC1) ; 
                         PGRU = PGRU + ((EXCO (EXTR LC1 &B1) PNF   'SCAL') * 
                                         (EXCO (EXTR LC2 &B1) GRUTE 'SCAL')) ; 
                 FIN B1 ; 
                 S50 = S50 + (INTG MODPFT PGRU) ; 
         FINSI ; 
         GPRESS = GPRESS - S50 ; 
 * Termes supplementaire pour un chargement en deformation imposee (SM) ********* 
         S160 = 0. ; 
         SI (BOOL.'J' ET BOOL.'DEF_IMP') ; 
                 S160 = INTG MOD_MEC_R CUMDEFI MAT2 ; 
                 GPRESS = GPRESS + S160 ; 
         FINSI ; 
   
         SI BOOL.'THER' ; 
                 SI BOOL.'COQ' ; 
                         S40 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF EPSTU) MAT2 ; 
                         GTERMI = GTERMI + S40 ; 
                         SI BOOL.'GRADALPH' ; 
                                 S70 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF (ELAS 
                                                 MOD_MEC_R (THET MOD_MEC_R TEPINT DMAT) DMAT)) MAT2 ; 
                                 GTERMI = GTERMI + S70 ; 
                         FINSI   ; 
                 SINON ; 
                         S41 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF GR_EPTH_THET) MAT2 ; 
                         GTERMI = GTERMI + S41 ; 
                 FINSI ; 
                 SI ((DIME MODPLA) > 0) ; 
                         TEMU = CHAN TYPE (EXCO 'T' TEMU 'SCAL') 'SCALAIRE' ; 
                         S120 = INTG MOD_MEC_R (WVMIS * TEMU) MAT2 ; 
                         GTERMI = GTERMI - S120  ; 
                 FINSI ; 
         FINSI ; 
   
 * somme des termes *************************** 
         GTOTA = (GMCANI + GTERMI + GPRESS)*FACT1 ; 
 FINSI ; 
   
   
   
 *|=====================================================================| 
 *|=======  V. CALCUL DE DJ/DA  ========================================| 
   
 *********************************************** 
 * S10 = -SIGF*(Grad U)*(Grad PI)*(Grad TETA) 
 * S20 = -SIGF*(Grad U)*(Grad TETA)*(Grad PI) 
 * S30 = SIGF*(Grad U)*(Grad TETA)*(Div PI) 
 * S40 = SIGF*(Grad U)*(Grad PI)*(Div TETA) 
 * S50 = ENEGIE*(ADJ TETA*PI) 
 * S60 = ALPH*SIGF*(Grad (Grad T))*PI*TETA 
 * S70 = ALPH*SIGF*((Grad T)*PI)*(Div TETA) 
 * S80 = ALPH*SIGF*((Grad T)*TETA)*(Div PI) 
 * S90 = SIG1*(Grad U)*(Grad TETA) 
 * S100= SIGF*(Grad U1)*(Grad TETA) 
 * S110= -SIGF*(Grad U1)*(Div TETA) 
 * S120= ALPH*SIG1*((Grad T)*TETA) 
 * S130= -PRESSION*(grad A_DEPI)*THETA 
 * S140= -(Grad PRESSION)*(Grad PI)*TETA*U 
 * S150= (Grad PRESSION)*TETA*U*(Div PI) 
 * S160= -(Grad PRESSION)*PI*(Grad U)*TETA 
 *********************************************** 
 SI  BOOL.'DJ/DA' ; 
    S10 = 0. - (INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
               (MOD_MEC_R GRADEP * (MOD_MEC_R PIGR * TETAGR)))) ; 
    S20 = 0. - (INTG MOD_MEC_R (WORK MOD_MEC_R SIGF 
               (MOD_MEC_R GRADEP * (MOD_MEC_R TETAGR * PIGR)))) ; 
    S30 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R 
           SIGF (MOD_MEC_R GRADEP * TETAGR)) * DIVPI) ; 
    S40 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R 
           SIGF (MOD_MEC_R GRADEP * PIGR)) * DIVTETA) ; 
    S50 = INTG MOD_MEC_R (ENERM * ADJ) ; 
   SI BOOL.'THER' ; 
      S60 = INTG MOD_MEC_R (ENER MOD_MEC_R SIGF EPSTU2) ; 
      S70 = INTG MOD_MEC_R ((ENER MOD_MEC_R SIGF EPSTU1)*DIVTETA) ; 
      S80 = INTG MOD_MEC_R ((ENER MOD_MEC_R SIGF EPSTU)*DIVPI) ; 
      S120 = INTG MOD_MEC_R (ENER MOD_MEC_R A_SIGF EPSTU) ; 
   FINSI ; 
   SI ('>' (XTX PREINT) 1.E-10) ; 
      S130 = XTY PREINT DEP1 MFI MUI ; 
      S140 = XTY PEMU2 (CHAN 'CHPO' MOD_MEC_R DEPINT) MFI MUI ; 
      S150 = XTY (PEMU1*(CHAN 'CHPO' MOD_MEC_R DIVPI)) 
                   (CHAN 'CHPO' MOD_MEC_R DEPINT) MFI MUI ; 
      S160 = XTY PEMU DEP0 MFI MUI ; 
   FINSI ; 
    S90 = INTG MOD_MEC_R (WORK MOD_MEC_R A_SIGF (MOD_MEC_R GRADEP * TETAGR)) ; 
    S100 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (MOD_MEC_R A_DEPGR * TETAGR)) ; 
    S110 = 0. - (INTG MOD_MEC_R (MOD_MEC_R (WORK 
                  MOD_MEC_R SIGF A_DEPGR) * DIVTETA)) ; 
    GMCANI = S10 + S20 + S30 + S40 + S50 + S90 + S100 + S110 ; 
    GTERMI = S60 + S70 + S80 + S120 ; 
    GPRESS = S150 - S130 - S140 - S160 ; 
    GTOTA = GMCANI + GTERMI + GPRESS ; 
 FINSI ; 
   
   
   
 *|=====================================================================| 
 *|=======  VI. CALCUL DES FACTEURS D INTENSITE DES CONTRAINTES  =======| 
   
 *********************************************** 
 * En pratique on les deduit de l integrale d interaction 
 * M(u,u^aux) = 2/E^* (K1*K1^aux + K2*K2^aux) 
 * On calcule donc : 
 *  J1 = 1/E^* K1^2 = M(u,u^aux_1)**2 / 4*J(u^aux_1,u^aux_1) 
 *  J2 = 1/E^* K2^2 = M(u,u^aux_2)**2 / 4*J(u^aux_2,u^aux_2) 
 *********************************************** 
 * l'integrale J(u^aux, u^aux) est la somme de : 
 * S10 = 0.5*Tr(A_sigf*(grad A_depi))*(div THETA) 
 * S20 = Tr[A_sigf*(grad A_depi)*(grad THETA)] * 
 * S50 = A_prei*(grad A_depi)*THETA 
 *********************************************** 
 * l'integrale M(u, u^aux) et la somme de : 
 * S60 = Tr[A_sigf*(Grad U)*(Grad THETA)] 
 * S70 = Tr[SIGF*(Grad A_depi)*(Grad THETA)] 
 * S80 = Tr[SIGF*(Grad A_depi)*(Div THETA)] 
 * S90 = PREINT*(grad A_depi)*THETA 
 * S100= A_prei*(grad U)*THETA 
 * S110= ALPH*A_sigf*((Grad T)*TETA) 
 *********************************************** 
 * Termes supplementaires pour le contact frottant (modif BP,BT) 
 * S111 = SIGF*n*[ (dU^aux/dX)(b) - (dU^aux/dX)(a) ]*TETA(x) 
 *********************************************** 
   
   
 SI  BOOL.'DECOUPLAGE' ; 
 *    si(BOOL.'XFEM') ; 
 * *  REM: pour les elements XFEM on a contruit les champs aux. tq 
 * *      (K_I^aux, K_II^aux)  =  (1,0)  et (0,1) 
 * *      => inutile de calculer J(u^aux,u^aux) (= C_MATE) 
 *bp 07/07/2011 : cela est faux dans le cas d'une fissure courbee 
 *      COE_M2K = 2. * C_MATE ; 
 *    sino ; 
      S10 = 0.5*( INTG MOD_MEC_R 
            (MOD_MEC_R (WORK MOD_MEC_R A_SIGF A_DEPGR) * DIVTETA) ) ; 
      S20 = INTG MOD_MEC_R 
            (WORK MOD_MEC_R A_SIGF (A_DEPGR*MOD_MEC_R TETAGR) ) MAT2 ; 
      SI ('>' (XTX A_PREI) 1.E-10) ; 
         S50 = XTY A_PREI DEP1 MFI MUI ; 
      FINSI ; 
      JETOILE = 'ABS' (S20 - S10 - S50) ; 
      COE_M2K = 2. * ((C_MATE*JETOILE)**0.5) ; 
 *    fins ; 
 *  integrale M(u, u^aux) 
    S60 = INTG MOD_MEC_R (WORK MOD_MEC_R A_SIGF (MOD_MEC_R GRADEP * TETAGR)) ; 
    S70 = INTG MOD_MEC_R (WORK MOD_MEC_R SIGF (MOD_MEC_R A_DEPGR * TETAGR)) ; 
    S80 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R SIGF A_DEPGR) * DIVTETA) ; 
 *rem: on pourrait calculer M avec les 2 lignes ci dessous: 
 *    S81 = INTG MOD_MEC_R (MOD_MEC_R (WORK MOD_MEC_R A_SIGF GRADEP) * DIVTETA) ; 
 *    S80 = 0.5*(S80+S81) ; 
 * Termes supplementaire pour le contact frottant (btrolle 19/02/2013) 
 * on calcule WSAUTGR^aux = GRADIENT DU SAUT^aux 
 SI (BOOL.'FROT' 'ET' BOOL.'XFEM') ; 
 * WDEP = deplacement de la fissure de composante UX ... AX ... 
 * [grad(w)] = grad [w] car linearite (le saut [w] est donne par AX ...) 
 * on utilise un modele liee a la geo de la fissure (cohesif ou contact) 
 * mess 'I avec contact frottant' ; 
 * SIGCON = sigma*n de composantes SMX... homogene a une contrainte 
 * supporte sur la levre superieure 
    SI (NEG (TYPE SIGCON) 'MCHAML  ') ; 
      SIGCON = REDU SIGCON (extr OBJCON2 'MAILLAGE') ; 
      SIGCON = CHAN 'CHAM' SIGCON OBJCON2 'STRESSES' 'CONTRAINTES' ; 
    FINS ; 
    SIGXN = (CHAN (exco SIGCON 'SMX' 'SCAL') TYPE 'SCALAIRE') ; 
    SIGYN = (CHAN (exco SIGCON 'SMY' 'SCAL') TYPE 'SCALAIRE') ; 
    si (ega GDIME 3) ; 
      SIGZN = (CHAN (exco SIGCON 'SMZ' 'SCAL') TYPE 'SCALAIRE') ; 
    fins ; 
 * teta 
     TETXC = PROI OBJCON2 TETAX 'STRESSES' ; 
     TETYC = PROI OBJCON2 TETAY 'STRESSES' ; 
     si (ega GDIME 3) ; 
       TETZC = PROI OBJCON2 TETAZ 'STRESSES' ; 
     fins ; 
 * [grad(w)] = grad [w] = WSAUTGR 
 * sigma*n 
   AAAAX= (SIGXN * (CHAN (exco B_DEPGR AX,X 'SCAL') TYPE 'SCALAIRE')) 
    + (SIGYN * (CHAN (exco B_DEPGR AY,X 'SCAL') TYPE 'SCALAIRE')) ; 
   AAAAY= (SIGXN * (CHAN (exco B_DEPGR AX,Y 'SCAL') TYPE 'SCALAIRE')) 
    '+' (SIGYN * (CHAN (exco B_DEPGR AY,Y 'SCAL') TYPE 'SCALAIRE')) ; 
     si (ega GDIME 3) ; 
       AAAAX = AAAAX 
             + (SIGZN *  (CHAN(exco B_DEPGR AZ,X) TYPE 'SCALAIRE')) ; 
       AAAAY = AAAAY 
             + (SIGZN *  (CHAN(exco B_DEPGR AZ,Y) TYPE 'SCALAIRE')) ; 
       AAAAZ = (SIGXN *  (CHAN(exco B_DEPGR AX,Z) TYPE 'SCALAIRE')) 
             + (SIGYN *  (CHAN(exco B_DEPGR AY,Z) TYPE 'SCALAIRE')) 
             + (SIGZN *  (CHAN(exco B_DEPGR AZ,Z) TYPE 'SCALAIRE')) ; 
       AAAA111 = (AAAAX * OBJCON2 TETXC) 
               + (AAAAY * OBJCON2 TETYC) 
               + (AAAAZ * OBJCON2 TETZC) ; 
     sino ; 
       AAAA111 = (AAAAX * OBJCON2 TETXC) 
               + (AAAAY * OBJCON2 TETYC) ; 
     fins ; 
     S111 = INTG OBJCON2 AAAA111 ; 
 'SINON' ; 
     S111 = 0.0 ; 
 FINSI ; 
 * fin du cas contact frottant (btrolle 19/02/2013) 
    SI ('>' (XTX PREINT) 1.E-10) ; 
      S90 = XTY PREINT DEP1 MFI MUI ; 
    FINSI ; 
    SI ('>' (XTX A_PREI) 1.E-10) ; 
      S100 = XTY A_PREI DEP0 MFI MUI ; 
    FINSI ; 
    SI BOOL.'THER' ; 
      S110 = INTG MOD_MEC_R (ENER MOD_MEC_R A_SIGF EPSTU) ; 
    FINSI ; 
 *  facteurs d intensite des contraintes 
    GMCANI = (S60 + S70 - S80 + S111) / COE_M2K ; 
    GTERMI = (S110) / COE_M2K ; 
    GPRESS = (-1.*(S100 + S90)) / COE_M2K ; 
    GTOTA = GMCANI + GTERMI + GPRESS ; 
 FINSI ; 
   
   
 *|=====================================================================| 
 *|=======  VII. STOCKAGE DES RESULTATS ET IMPRESSIONS  ================| 
   
   
 *************************************************** 
 ** PROFILE DE G DANS L EPAISSEUR EN CAS DE COQUE ** 
 *************************************************** 
 SI BOOL.'COQ' ; 
   SI BOOL.'PASAPAS' ; 
      SUPTAB.'EPAISSEUR_RESULTATS'.IABC = EVENR * GTOTA ; 
   SINON ; 
      SUPTAB.'EPAISSEUR_RESULTATS' = EVENR * GTOTA ; 
   FINSI ; 
 FINSI ; 
   
 *************************************************** 
 ** STOCKAGE DES RESULTATS DANS SUPTAB.'RESULTATS'** 
 *************************************************** 
 C1 = 'CHAI' GMCANI ' ' ; C2 = 'CHAI' GTERMI ' ' ; 
 C3 = 'CHAI' GPRESS '  ' ; C4 = 'CHAI' GTOTA ; 
 *CAS PASAPAS 
 SI BOOL.'PASAPAS' ; 
   SI (EGA GDIME 2) ; 
     SI  BOOL.'DECOUPLAGE' ; 
       MESS MOTMIA '  ' IABC C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.MOTMIX.IABC = GTOTA ; 
     SINON ; 
       MESS IABC C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.IABC = GTOTA ; 
     FINSI ; 
   FINSI ; 
   SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     SI  BOOL.'DECOUPLAGE' ; 
       MESS MOTMIA ' ' NUNOE IABC C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.MOTMIX.IABC.PM = GTOTA ; 
     SINON ; 
       MESS NUNOE IABC C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.IABC.PM = GTOTA ; 
     FINSI ; 
   FINSI ; 
   SI BOOL.'COQ' ; 
      C1 = 'CHAI' (GMCANI*V_SUPE) ' ' ; C2 = 'CHAI' (GTERMI*V_SUPE) ' ' ; 
      C3 = 'CHAI' (GPRESS*V_SUPE) '  ' ;C4 = 'CHAI' (GTOTA*V_SUPE) ; 
      C5 = 'CHAI' (GMCANI*V_MOYE) ' ' ; C6 = 'CHAI' (GTERMI*V_MOYE) ' ' ; 
      C7 = 'CHAI' (GPRESS*V_MOYE) '  ' ;C8 = 'CHAI' (GTOTA*V_MOYE) ; 
      C9 = 'CHAI' (GMCANI*V_INFE) ' ' ; C10= 'CHAI' (GTERMI*V_INFE) ' ' ; 
      C11= 'CHAI' (GPRESS*V_INFE) '  ' ;C12= 'CHAI' (GTOTA*V_INFE) ; 
     MESS ' Superi ' IABC C1 C2  C3  C4 ; 
     MESS ' Median ' IABC C5 C6  C7  C8 ; 
     MESS ' Inferi ' IABC C9 C10 C11 C12 ; 
      C1 = 'CHAI' GMCANI ' ' ; C2 = 'CHAI' GTERMI ' ' ; 
      C3 = 'CHAI' GPRESS '  ' ; C4 = 'CHAI' GTOTA ; 
     MESS ' Global ' IABC C1 C2 C3 C4 ; 
     SI  BOOL.'DECOUPLAGE' ; 
        SUPTAB.'RESULTATS'.MOTMIX = GTOTA ; 
     SINON ; 
        SUPTAB.'RESULTATS'.IABC.'SUPERI' = GTOTA*V_SUPE ; 
        SUPTAB.'RESULTATS'.IABC.'MEDIAN' = GTOTA*V_MOYE ; 
        SUPTAB.'RESULTATS'.IABC.'INFERI' = GTOTA*V_INFE ; 
        SUPTAB.'RESULTATS'.IABC.'GLOBAL' = GTOTA ; 
     FINSI ; 
   FINSI ; 
 *CAS RESOU 
 SINON ; 
   SI (EGA GDIME 2) ; 
     SI  BOOL.'DECOUPLAGE' ; 
       MESS MOTMIA '  ' C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.MOTMIX = GTOTA ; 
     SINON ; 
       MESS C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS' = GTOTA ; 
     FINSI ; 
   FINSI ; 
   SI ((EGA GDIME 3) ET (NON BOOL.'COQ')) ; 
     SI  BOOL.'DECOUPLAGE' ; 
       MESS ' ' MOTMIA '  ' NUNOE C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.MOTMIX.PM = GTOTA ; 
     SINON ; 
       MESS NUNOE C1 C2 C3 C4 ; 
        SUPTAB.'RESULTATS'.PM = GTOTA ; 
     FINSI ; 
   FINSI ; 
   SI BOOL.'COQ' ; 
      C1 = 'CHAI' (GMCANI*V_SUPE) ' ' ; C2 = 'CHAI' (GTERMI*V_SUPE) ' ' ; 
      C3 = 'CHAI' (GPRESS*V_SUPE) '  ' ;C4 = 'CHAI' (GTOTA*V_SUPE) ; 
      C5 = 'CHAI' (GMCANI*V_MOYE) ' ' ; C6 = 'CHAI' (GTERMI*V_MOYE) ' ' ; 
      C7 = 'CHAI' (GPRESS*V_MOYE) '  ' ;C8 = 'CHAI' (GTOTA*V_MOYE) ; 
      C9 = 'CHAI' (GMCANI*V_INFE) ' ' ; C10= 'CHAI' (GTERMI*V_INFE) ' ' ; 
      C11= 'CHAI' (GPRESS*V_INFE) '  ' ;C12= 'CHAI' (GTOTA*V_INFE) ; 
     MESS ' Superi ' C1 C2  C3  C4 ; 
     MESS ' Median ' C5 C6  C7  C8 ; 
     MESS ' Inferi ' C9 C10 C11 C12 ; 
      C1 = 'CHAI' GMCANI ' ' ; C2 = 'CHAI' GTERMI ' ' ; 
      C3 = 'CHAI' GPRESS '  ' ; C4 = 'CHAI' GTOTA ; 
     MESS ' Global ' C1 C2 C3 C4 ; 
     SI  BOOL.'DECOUPLAGE' ; 
        SUPTAB.'RESULTATS'.MOTMIX = GTOTA ; 
     SINON ; 
        SUPTAB.'RESULTATS'.'SUPERI' = GTOTA*V_SUPE ; 
        SUPTAB.'RESULTATS'.'MEDIAN' = GTOTA*V_MOYE ; 
        SUPTAB.'RESULTATS'.'INFERI' = GTOTA*V_INFE ; 
        SUPTAB.'RESULTATS'.'GLOBAL' = GTOTA ; 
     FINSI ; 
   FINSI ; 
 FINSI ; 
   
 ***BP: PETIT AJOUT *** 
        SI(ega (type PM) 'MAILLAGE') ; 
          SI (EGA (&BCNOEU) 1) ; 
            GCHAM1 = MANU 'CHML' PM MOCOMP GTOTA ; 
          SINO ; 
            GCHAM1 = GCHAM1 
                 et (MANU 'CHML' PM MOCOMP GTOTA) ; 
          FINS ; 
        FINS ; 
        SI(ega (type PM) 'POINT') ; 
          SI (EGA (&BCNOEU) 1) ; 
            GCHPO1 = MANU 'CHPO' PM 1 MOCOMP GTOTA 'NATURE' 'DIFFUS' ; 
          SINO ; 
            GCHPO1 = GCHPO1 
                 et (MANU 'CHPO' PM 1 MOCOMP GTOTA 'NATURE' 'DIFFUS') ; 
          FINS ; 
        FINS ; 
 ***BP: FIN DU PETIT AJOUT *** 
   
 FIN BCNOEU ; 
 *<== FIN DE BOUCLE SUR LES NOEUDS A AVANCER VIRTUELLEMENT =============| 
 *|=====================================================================| 
   
 ********************************************************************* 
 ** STOCKAGE DES CHAMPS RESULTATS (+ logique qu'une table a priori) ** 
 ********************************************************************* 
 SI  ( (NEG (TYPE GCHPO1) 'CHPOINT') 
    ET (EGA (TYPE GCHAM1) 'MCHAML') ) ; 
 *version J constant par morceaux 
 *      GCHPO1 = PROI SUPTAB.'FRONT_FISSURE' GCHAM1 ; 
 *version J lissee (projete sur approximation EF) 
       efJ = EXTR GCHAM1 'MAILLAGE' ; 
 *  mess 'efJ=' ; list efJ ; trac efJ ; 
 *  totoj = inte efJ MAILMOD 'NOVERIF' ; 
 *  mess (nbel efJ) ' =nbel=? ' (nbel totoj) ; 
 *  mess (nbno efJ) ' =nbno=? ' (nbno totoj) ; 
       MOD_MEC_Rj =redu MOD_MEC_R efj ; 
       GCHPO1 = CHAN 'CHPO' GCHAM1 MOD_MEC_Rj 'MOYE' ; 
       GCHPO1 = CHAN 'CHAM' GCHPO1 MOD_MEC_R ; 
 *  mess 'redu ok appel a proi' ; 
       GCHPO1 = PROI SUPTAB.'FRONT_FISSURE' GCHPO1 ; 
 FINS ; 
 *CAS PASAPAS 
 SI(BOOL.'PASAPAS') ; 
   SI (EGA (TYPE GCHPO1) 'CHPOINT') ; 
     SI(NON (EXIS SUPTAB  'CHPO_RESULTATS')) ; 
       SUPTAB . 'CHPO_RESULTATS' = TABL ; 
     FINSI ; 
     SI((EGA &BOUCMIX 1) ou (NON (EXIS SUPTAB.'CHPO_RESULTATS' IABC))) ; 
       SUPTAB.'CHPO_RESULTATS'.IABC = GCHPO1 ; 
     SINO ; 
       SUPTAB.'CHPO_RESULTATS'.IABC 
       = SUPTAB.'CHPO_RESULTATS'.IABC ET GCHPO1 ; 
     FINS ; 
   FINS ; 
   SI (EGA (TYPE GCHAM1) 'MCHAML') ; 
     SI(NON (EXIS SUPTAB  'CHAM_RESULTATS')) ; 
       SUPTAB . 'CHAM_RESULTATS' = TABL ; 
     FINSI ; 
     SI((EGA &BOUCMIX 1) ou (NON (EXIS SUPTAB.'CHAM_RESULTATS' IABC))) ; 
       SUPTAB.'CHAM_RESULTATS'.IABC = GCHAM1 ; 
     SINO ; 
       SUPTAB.'CHAM_RESULTATS'.IABC 
       = SUPTAB.'CHAM_RESULTATS'.IABC ET GCHAM1 ; 
     FINS ; 
   FINS ; 
 *CAS RESOU 
 SINO ; 
   SI (EGA (TYPE GCHPO1) 'CHPOINT') ; 
     SI((EGA &BOUCMIX 1) ou (NON (EXIS SUPTAB 'CHPO_RESULTATS'))) ; 
       SUPTAB.'CHPO_RESULTATS' = GCHPO1 ; 
     SINO ; 
       SUPTAB.'CHPO_RESULTATS' = SUPTAB.'CHPO_RESULTATS' ET GCHPO1 ; 
     FINS ; 
   FINS ; 
   SI (EGA (TYPE GCHAM1) 'MCHAML') ; 
     SI((EGA &BOUCMIX 1) ou (NON (EXIS SUPTAB 'CHAM_RESULTATS'))) ; 
       SUPTAB.'CHAM_RESULTATS' = GCHAM1 ; 
     SINO ; 
       SUPTAB.'CHAM_RESULTATS' = SUPTAB.'CHAM_RESULTATS' ET GCHAM1 ; 
     FINS ; 
  FINS ; 
 FINS ; 
   
 * ON SE PREPARE A PARTIR... 
 MENA ; 
 SI (BOOL.'PASAPAS' ET BOOL.'COQ') ; 
   'SAUT' 1 'LIGNE' ; 
 FINSI ; 
 SI (BOOL.'PASAPAS' ET (NBOU '>' 1)) ; 
   'SAUT' 1 'LIGNE' ; 
 FINSI ; 
 SI (BOOL.'PASAPAS' ET (NBOU EGA 1) ET (NON BOOL.'COQ')) ; 
   SI (EGA ((&BOUCEXT/10)*10) &BOUCEXT) ; 
     'SAUT' 1 'LIGNE' ; 
   FINSI ; 
 FINSI ; 
   
 FINPROC SUPTAB ; 
 K1G = GTAB. 'RESULTATS'. 'I'  ; 
 K2G = GTAB . 'RESULTATS'. 'II'  ; 
   
   
 ************* DETERMINATION OF G 
 *----Using G-theta  ---------------------; 
 GTAB = TABL; 
 GTAB . 'OBJECTIF' = MOT 'J'; 
 GTAB . 'FRONT_FISSURE'  = pF0 ; 
 GTAB . 'LEVRE_SUPERIEURE' = liptopL; 
 GTAB . 'LEVRE_INFERIEURE' = lipbotL; 
 GTAB . 'COUCHE' = 6; 
 GTAB . 'SOLUTION_RESO'  = u0; 
 GTAB . 'CARACTERISTIQUES' = mat0; 
 GTAB . 'MODELE' = mod0; 
 GTAB . 'CHARGEMENTS_MECANIQUES' = cha0 ; 
 G_THETA GTAB; 
 G_cal = GTAB . 'RESULTATS'  ; 
 SI (EGA CPDP  'DP'); 
 A0= (1. - (v0*v0)); 
 FINSI; 
 *Plane stresses * 
 SI (EGA CPDP  'CP'); 
 A0= 1.; 
 FINSI; 
 GIrw= (A0/YOU0)*((K1G * K1G)+(K2G * K2G)); 
 mess '--------------------------'; 
 mess 'K1  Gtheta :'  K1G; 
 mess 'K2  Gtheta:'  K2G; 
 mess '---G  Gtheta :'  G_cal; 
 mess '---G  J-Irwin :' GIrw; 
 *OPTI SAUV 'FORMAT' 'Ficher.sauv'; 
 *SAUV K1G; 
   
 *opti donn 5; 
 fin; 
